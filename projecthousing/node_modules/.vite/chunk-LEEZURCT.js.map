{
  "version": 3,
  "sources": ["../geotiff/src/predictor.js", "../geotiff/src/compression/basedecoder.js"],
  "sourcesContent": ["function decodeRowAcc(row, stride) {\n  let length = row.length - stride;\n  let offset = 0;\n  do {\n    for (let i = stride; i > 0; i--) {\n      row[offset + stride] += row[offset];\n      offset++;\n    }\n\n    length -= stride;\n  } while (length > 0);\n}\n\nfunction decodeRowFloatingPoint(row, stride, bytesPerSample) {\n  let index = 0;\n  let count = row.length;\n  const wc = count / bytesPerSample;\n\n  while (count > stride) {\n    for (let i = stride; i > 0; --i) {\n      row[index + stride] += row[index];\n      ++index;\n    }\n    count -= stride;\n  }\n\n  const copy = row.slice();\n  for (let i = 0; i < wc; ++i) {\n    for (let b = 0; b < bytesPerSample; ++b) {\n      row[(bytesPerSample * i) + b] = copy[((bytesPerSample - b - 1) * wc) + i];\n    }\n  }\n}\n\nexport function applyPredictor(block, predictor, width, height, bitsPerSample,\n  planarConfiguration) {\n  if (!predictor || predictor === 1) {\n    return block;\n  }\n\n  for (let i = 0; i < bitsPerSample.length; ++i) {\n    if (bitsPerSample[i] % 8 !== 0) {\n      throw new Error('When decoding with predictor, only multiple of 8 bits are supported.');\n    }\n    if (bitsPerSample[i] !== bitsPerSample[0]) {\n      throw new Error('When decoding with predictor, all samples must have the same size.');\n    }\n  }\n\n  const bytesPerSample = bitsPerSample[0] / 8;\n  const stride = planarConfiguration === 2 ? 1 : bitsPerSample.length;\n\n  for (let i = 0; i < height; ++i) {\n    // Last strip will be truncated if height % stripHeight != 0\n    if (i * stride * width * bytesPerSample >= block.byteLength) {\n      break;\n    }\n    let row;\n    if (predictor === 2) { // horizontal prediction\n      switch (bitsPerSample[0]) {\n        case 8:\n          row = new Uint8Array(\n            block, i * stride * width * bytesPerSample, stride * width * bytesPerSample,\n          );\n          break;\n        case 16:\n          row = new Uint16Array(\n            block, i * stride * width * bytesPerSample, stride * width * bytesPerSample / 2,\n          );\n          break;\n        case 32:\n          row = new Uint32Array(\n            block, i * stride * width * bytesPerSample, stride * width * bytesPerSample / 4,\n          );\n          break;\n        default:\n          throw new Error(`Predictor 2 not allowed with ${bitsPerSample[0]} bits per sample.`);\n      }\n      decodeRowAcc(row, stride, bytesPerSample);\n    } else if (predictor === 3) { // horizontal floating point\n      row = new Uint8Array(\n        block, i * stride * width * bytesPerSample, stride * width * bytesPerSample,\n      );\n      decodeRowFloatingPoint(row, stride, bytesPerSample);\n    }\n  }\n  return block;\n}\n", "import { applyPredictor } from '../predictor';\n\nexport default class BaseDecoder {\n  async decode(fileDirectory, buffer) {\n    const decoded = await this.decodeBlock(buffer);\n    const predictor = fileDirectory.Predictor || 1;\n    if (predictor !== 1) {\n      const isTiled = !fileDirectory.StripOffsets;\n      const tileWidth = isTiled ? fileDirectory.TileWidth : fileDirectory.ImageWidth;\n      const tileHeight = isTiled ? fileDirectory.TileLength : (\n        fileDirectory.RowsPerStrip || fileDirectory.ImageLength\n      );\n      return applyPredictor(\n        decoded, predictor, tileWidth, tileHeight, fileDirectory.BitsPerSample,\n        fileDirectory.PlanarConfiguration,\n      );\n    }\n    return decoded;\n  }\n}\n"],
  "mappings": ";AAAA,sBAAsB,KAAK,QAAQ;AACjC,MAAI,SAAS,IAAI,SAAS;AAC1B,MAAI,SAAS;AACb,KAAG;AACD,aAAS,IAAI,QAAQ,IAAI,GAAG,KAAK;AAC/B,UAAI,SAAS,WAAW,IAAI;AAC5B;AAAA;AAGF,cAAU;AAAA,WACH,SAAS;AAAA;AAGpB,gCAAgC,KAAK,QAAQ,gBAAgB;AAC3D,MAAI,QAAQ;AACZ,MAAI,QAAQ,IAAI;AAChB,QAAM,KAAK,QAAQ;AAEnB,SAAO,QAAQ,QAAQ;AACrB,aAAS,IAAI,QAAQ,IAAI,GAAG,EAAE,GAAG;AAC/B,UAAI,QAAQ,WAAW,IAAI;AAC3B,QAAE;AAAA;AAEJ,aAAS;AAAA;AAGX,QAAM,OAAO,IAAI;AACjB,WAAS,IAAI,GAAG,IAAI,IAAI,EAAE,GAAG;AAC3B,aAAS,IAAI,GAAG,IAAI,gBAAgB,EAAE,GAAG;AACvC,UAAK,iBAAiB,IAAK,KAAK,KAAO,kBAAiB,IAAI,KAAK,KAAM;AAAA;AAAA;AAAA;AAKtE,wBAAwB,OAAO,WAAW,OAAO,QAAQ,eAC9D,qBAAqB;AACrB,MAAI,CAAC,aAAa,cAAc,GAAG;AACjC,WAAO;AAAA;AAGT,WAAS,IAAI,GAAG,IAAI,cAAc,QAAQ,EAAE,GAAG;AAC7C,QAAI,cAAc,KAAK,MAAM,GAAG;AAC9B,YAAM,IAAI,MAAM;AAAA;AAElB,QAAI,cAAc,OAAO,cAAc,IAAI;AACzC,YAAM,IAAI,MAAM;AAAA;AAAA;AAIpB,QAAM,iBAAiB,cAAc,KAAK;AAC1C,QAAM,SAAS,wBAAwB,IAAI,IAAI,cAAc;AAE7D,WAAS,IAAI,GAAG,IAAI,QAAQ,EAAE,GAAG;AAE/B,QAAI,IAAI,SAAS,QAAQ,kBAAkB,MAAM,YAAY;AAC3D;AAAA;AAEF,QAAI;AACJ,QAAI,cAAc,GAAG;AACnB,cAAQ,cAAc;AAAA,aACf;AACH,gBAAM,IAAI,WACR,OAAO,IAAI,SAAS,QAAQ,gBAAgB,SAAS,QAAQ;AAE/D;AAAA,aACG;AACH,gBAAM,IAAI,YACR,OAAO,IAAI,SAAS,QAAQ,gBAAgB,SAAS,QAAQ,iBAAiB;AAEhF;AAAA,aACG;AACH,gBAAM,IAAI,YACR,OAAO,IAAI,SAAS,QAAQ,gBAAgB,SAAS,QAAQ,iBAAiB;AAEhF;AAAA;AAEA,gBAAM,IAAI,MAAM,gCAAgC,cAAc;AAAA;AAElE,mBAAa,KAAK,QAAQ;AAAA,eACjB,cAAc,GAAG;AAC1B,YAAM,IAAI,WACR,OAAO,IAAI,SAAS,QAAQ,gBAAgB,SAAS,QAAQ;AAE/D,6BAAuB,KAAK,QAAQ;AAAA;AAAA;AAGxC,SAAO;AAAA;;;ACpFT,wBAAiC;AAAA,QACzB,OAAO,eAAe,QAAQ;AAClC,UAAM,UAAU,MAAM,KAAK,YAAY;AACvC,UAAM,YAAY,cAAc,aAAa;AAC7C,QAAI,cAAc,GAAG;AACnB,YAAM,UAAU,CAAC,cAAc;AAC/B,YAAM,YAAY,UAAU,cAAc,YAAY,cAAc;AACpE,YAAM,aAAa,UAAU,cAAc,aACzC,cAAc,gBAAgB,cAAc;AAE9C,aAAO,eACL,SAAS,WAAW,WAAW,YAAY,cAAc,eACzD,cAAc;AAAA;AAGlB,WAAO;AAAA;AAAA;",
  "names": []
}
