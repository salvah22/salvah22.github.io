import {
  Source_default
} from "./chunk-WSGYOD7F.js";
import {
  CollectionEventType_default,
  Collection_default
} from "./chunk-MXUD2ERE.js";
import {
  State_default
} from "./chunk-WY5HO4B4.js";
import {
  ObjectEventType_default,
  Object_default
} from "./chunk-KYXP4QQS.js";
import {
  EventType_default,
  Event_default,
  TRUE,
  VOID,
  extend,
  listen,
  unlistenByKey
} from "./chunk-XYO5KJKP.js";
import {
  getValues,
  isEmpty
} from "./chunk-WONFBMYW.js";
import {
  assert,
  containsExtent,
  createOrUpdate,
  equals,
  getUid
} from "./chunk-V7OLV3U6.js";

// node_modules/ol/Feature.js
var __extends = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var Feature = function(_super) {
  __extends(Feature2, _super);
  function Feature2(opt_geometryOrProperties) {
    var _this = _super.call(this) || this;
    _this.on;
    _this.once;
    _this.un;
    _this.id_ = void 0;
    _this.geometryName_ = "geometry";
    _this.style_ = null;
    _this.styleFunction_ = void 0;
    _this.geometryChangeKey_ = null;
    _this.addChangeListener(_this.geometryName_, _this.handleGeometryChanged_);
    if (opt_geometryOrProperties) {
      if (typeof opt_geometryOrProperties.getSimplifiedGeometry === "function") {
        var geometry = opt_geometryOrProperties;
        _this.setGeometry(geometry);
      } else {
        var properties = opt_geometryOrProperties;
        _this.setProperties(properties);
      }
    }
    return _this;
  }
  Feature2.prototype.clone = function() {
    var clone = new Feature2(this.hasProperties() ? this.getProperties() : null);
    clone.setGeometryName(this.getGeometryName());
    var geometry = this.getGeometry();
    if (geometry) {
      clone.setGeometry(geometry.clone());
    }
    var style = this.getStyle();
    if (style) {
      clone.setStyle(style);
    }
    return clone;
  };
  Feature2.prototype.getGeometry = function() {
    return this.get(this.geometryName_);
  };
  Feature2.prototype.getId = function() {
    return this.id_;
  };
  Feature2.prototype.getGeometryName = function() {
    return this.geometryName_;
  };
  Feature2.prototype.getStyle = function() {
    return this.style_;
  };
  Feature2.prototype.getStyleFunction = function() {
    return this.styleFunction_;
  };
  Feature2.prototype.handleGeometryChange_ = function() {
    this.changed();
  };
  Feature2.prototype.handleGeometryChanged_ = function() {
    if (this.geometryChangeKey_) {
      unlistenByKey(this.geometryChangeKey_);
      this.geometryChangeKey_ = null;
    }
    var geometry = this.getGeometry();
    if (geometry) {
      this.geometryChangeKey_ = listen(geometry, EventType_default.CHANGE, this.handleGeometryChange_, this);
    }
    this.changed();
  };
  Feature2.prototype.setGeometry = function(geometry) {
    this.set(this.geometryName_, geometry);
  };
  Feature2.prototype.setStyle = function(opt_style) {
    this.style_ = opt_style;
    this.styleFunction_ = !opt_style ? void 0 : createStyleFunction(opt_style);
    this.changed();
  };
  Feature2.prototype.setId = function(id) {
    this.id_ = id;
    this.changed();
  };
  Feature2.prototype.setGeometryName = function(name) {
    this.removeChangeListener(this.geometryName_, this.handleGeometryChanged_);
    this.geometryName_ = name;
    this.addChangeListener(this.geometryName_, this.handleGeometryChanged_);
    this.handleGeometryChanged_();
  };
  return Feature2;
}(Object_default);
function createStyleFunction(obj) {
  if (typeof obj === "function") {
    return obj;
  } else {
    var styles_1;
    if (Array.isArray(obj)) {
      styles_1 = obj;
    } else {
      assert(typeof obj.getZIndex === "function", 41);
      var style = obj;
      styles_1 = [style];
    }
    return function() {
      return styles_1;
    };
  }
}
var Feature_default = Feature;

// node_modules/quickselect/index.js
function quickselect(arr, k, left, right, compare) {
  quickselectStep(arr, k, left || 0, right || arr.length - 1, compare || defaultCompare);
}
function quickselectStep(arr, k, left, right, compare) {
  while (right > left) {
    if (right - left > 600) {
      var n = right - left + 1;
      var m = k - left + 1;
      var z = Math.log(n);
      var s = 0.5 * Math.exp(2 * z / 3);
      var sd = 0.5 * Math.sqrt(z * s * (n - s) / n) * (m - n / 2 < 0 ? -1 : 1);
      var newLeft = Math.max(left, Math.floor(k - m * s / n + sd));
      var newRight = Math.min(right, Math.floor(k + (n - m) * s / n + sd));
      quickselectStep(arr, k, newLeft, newRight, compare);
    }
    var t = arr[k];
    var i = left;
    var j = right;
    swap(arr, left, k);
    if (compare(arr[right], t) > 0)
      swap(arr, left, right);
    while (i < j) {
      swap(arr, i, j);
      i++;
      j--;
      while (compare(arr[i], t) < 0)
        i++;
      while (compare(arr[j], t) > 0)
        j--;
    }
    if (compare(arr[left], t) === 0)
      swap(arr, left, j);
    else {
      j++;
      swap(arr, j, right);
    }
    if (j <= k)
      left = j + 1;
    if (k <= j)
      right = j - 1;
  }
}
function swap(arr, i, j) {
  var tmp = arr[i];
  arr[i] = arr[j];
  arr[j] = tmp;
}
function defaultCompare(a, b) {
  return a < b ? -1 : a > b ? 1 : 0;
}

// node_modules/rbush/index.js
var RBush = class {
  constructor(maxEntries = 9) {
    this._maxEntries = Math.max(4, maxEntries);
    this._minEntries = Math.max(2, Math.ceil(this._maxEntries * 0.4));
    this.clear();
  }
  all() {
    return this._all(this.data, []);
  }
  search(bbox) {
    let node = this.data;
    const result = [];
    if (!intersects(bbox, node))
      return result;
    const toBBox = this.toBBox;
    const nodesToSearch = [];
    while (node) {
      for (let i = 0; i < node.children.length; i++) {
        const child = node.children[i];
        const childBBox = node.leaf ? toBBox(child) : child;
        if (intersects(bbox, childBBox)) {
          if (node.leaf)
            result.push(child);
          else if (contains(bbox, childBBox))
            this._all(child, result);
          else
            nodesToSearch.push(child);
        }
      }
      node = nodesToSearch.pop();
    }
    return result;
  }
  collides(bbox) {
    let node = this.data;
    if (!intersects(bbox, node))
      return false;
    const nodesToSearch = [];
    while (node) {
      for (let i = 0; i < node.children.length; i++) {
        const child = node.children[i];
        const childBBox = node.leaf ? this.toBBox(child) : child;
        if (intersects(bbox, childBBox)) {
          if (node.leaf || contains(bbox, childBBox))
            return true;
          nodesToSearch.push(child);
        }
      }
      node = nodesToSearch.pop();
    }
    return false;
  }
  load(data) {
    if (!(data && data.length))
      return this;
    if (data.length < this._minEntries) {
      for (let i = 0; i < data.length; i++) {
        this.insert(data[i]);
      }
      return this;
    }
    let node = this._build(data.slice(), 0, data.length - 1, 0);
    if (!this.data.children.length) {
      this.data = node;
    } else if (this.data.height === node.height) {
      this._splitRoot(this.data, node);
    } else {
      if (this.data.height < node.height) {
        const tmpNode = this.data;
        this.data = node;
        node = tmpNode;
      }
      this._insert(node, this.data.height - node.height - 1, true);
    }
    return this;
  }
  insert(item) {
    if (item)
      this._insert(item, this.data.height - 1);
    return this;
  }
  clear() {
    this.data = createNode([]);
    return this;
  }
  remove(item, equalsFn) {
    if (!item)
      return this;
    let node = this.data;
    const bbox = this.toBBox(item);
    const path = [];
    const indexes = [];
    let i, parent, goingUp;
    while (node || path.length) {
      if (!node) {
        node = path.pop();
        parent = path[path.length - 1];
        i = indexes.pop();
        goingUp = true;
      }
      if (node.leaf) {
        const index = findItem(item, node.children, equalsFn);
        if (index !== -1) {
          node.children.splice(index, 1);
          path.push(node);
          this._condense(path);
          return this;
        }
      }
      if (!goingUp && !node.leaf && contains(node, bbox)) {
        path.push(node);
        indexes.push(i);
        i = 0;
        parent = node;
        node = node.children[0];
      } else if (parent) {
        i++;
        node = parent.children[i];
        goingUp = false;
      } else
        node = null;
    }
    return this;
  }
  toBBox(item) {
    return item;
  }
  compareMinX(a, b) {
    return a.minX - b.minX;
  }
  compareMinY(a, b) {
    return a.minY - b.minY;
  }
  toJSON() {
    return this.data;
  }
  fromJSON(data) {
    this.data = data;
    return this;
  }
  _all(node, result) {
    const nodesToSearch = [];
    while (node) {
      if (node.leaf)
        result.push(...node.children);
      else
        nodesToSearch.push(...node.children);
      node = nodesToSearch.pop();
    }
    return result;
  }
  _build(items, left, right, height) {
    const N = right - left + 1;
    let M = this._maxEntries;
    let node;
    if (N <= M) {
      node = createNode(items.slice(left, right + 1));
      calcBBox(node, this.toBBox);
      return node;
    }
    if (!height) {
      height = Math.ceil(Math.log(N) / Math.log(M));
      M = Math.ceil(N / Math.pow(M, height - 1));
    }
    node = createNode([]);
    node.leaf = false;
    node.height = height;
    const N2 = Math.ceil(N / M);
    const N1 = N2 * Math.ceil(Math.sqrt(M));
    multiSelect(items, left, right, N1, this.compareMinX);
    for (let i = left; i <= right; i += N1) {
      const right2 = Math.min(i + N1 - 1, right);
      multiSelect(items, i, right2, N2, this.compareMinY);
      for (let j = i; j <= right2; j += N2) {
        const right3 = Math.min(j + N2 - 1, right2);
        node.children.push(this._build(items, j, right3, height - 1));
      }
    }
    calcBBox(node, this.toBBox);
    return node;
  }
  _chooseSubtree(bbox, node, level, path) {
    while (true) {
      path.push(node);
      if (node.leaf || path.length - 1 === level)
        break;
      let minArea = Infinity;
      let minEnlargement = Infinity;
      let targetNode;
      for (let i = 0; i < node.children.length; i++) {
        const child = node.children[i];
        const area = bboxArea(child);
        const enlargement = enlargedArea(bbox, child) - area;
        if (enlargement < minEnlargement) {
          minEnlargement = enlargement;
          minArea = area < minArea ? area : minArea;
          targetNode = child;
        } else if (enlargement === minEnlargement) {
          if (area < minArea) {
            minArea = area;
            targetNode = child;
          }
        }
      }
      node = targetNode || node.children[0];
    }
    return node;
  }
  _insert(item, level, isNode) {
    const bbox = isNode ? item : this.toBBox(item);
    const insertPath = [];
    const node = this._chooseSubtree(bbox, this.data, level, insertPath);
    node.children.push(item);
    extend2(node, bbox);
    while (level >= 0) {
      if (insertPath[level].children.length > this._maxEntries) {
        this._split(insertPath, level);
        level--;
      } else
        break;
    }
    this._adjustParentBBoxes(bbox, insertPath, level);
  }
  _split(insertPath, level) {
    const node = insertPath[level];
    const M = node.children.length;
    const m = this._minEntries;
    this._chooseSplitAxis(node, m, M);
    const splitIndex = this._chooseSplitIndex(node, m, M);
    const newNode = createNode(node.children.splice(splitIndex, node.children.length - splitIndex));
    newNode.height = node.height;
    newNode.leaf = node.leaf;
    calcBBox(node, this.toBBox);
    calcBBox(newNode, this.toBBox);
    if (level)
      insertPath[level - 1].children.push(newNode);
    else
      this._splitRoot(node, newNode);
  }
  _splitRoot(node, newNode) {
    this.data = createNode([node, newNode]);
    this.data.height = node.height + 1;
    this.data.leaf = false;
    calcBBox(this.data, this.toBBox);
  }
  _chooseSplitIndex(node, m, M) {
    let index;
    let minOverlap = Infinity;
    let minArea = Infinity;
    for (let i = m; i <= M - m; i++) {
      const bbox1 = distBBox(node, 0, i, this.toBBox);
      const bbox2 = distBBox(node, i, M, this.toBBox);
      const overlap = intersectionArea(bbox1, bbox2);
      const area = bboxArea(bbox1) + bboxArea(bbox2);
      if (overlap < minOverlap) {
        minOverlap = overlap;
        index = i;
        minArea = area < minArea ? area : minArea;
      } else if (overlap === minOverlap) {
        if (area < minArea) {
          minArea = area;
          index = i;
        }
      }
    }
    return index || M - m;
  }
  _chooseSplitAxis(node, m, M) {
    const compareMinX = node.leaf ? this.compareMinX : compareNodeMinX;
    const compareMinY = node.leaf ? this.compareMinY : compareNodeMinY;
    const xMargin = this._allDistMargin(node, m, M, compareMinX);
    const yMargin = this._allDistMargin(node, m, M, compareMinY);
    if (xMargin < yMargin)
      node.children.sort(compareMinX);
  }
  _allDistMargin(node, m, M, compare) {
    node.children.sort(compare);
    const toBBox = this.toBBox;
    const leftBBox = distBBox(node, 0, m, toBBox);
    const rightBBox = distBBox(node, M - m, M, toBBox);
    let margin = bboxMargin(leftBBox) + bboxMargin(rightBBox);
    for (let i = m; i < M - m; i++) {
      const child = node.children[i];
      extend2(leftBBox, node.leaf ? toBBox(child) : child);
      margin += bboxMargin(leftBBox);
    }
    for (let i = M - m - 1; i >= m; i--) {
      const child = node.children[i];
      extend2(rightBBox, node.leaf ? toBBox(child) : child);
      margin += bboxMargin(rightBBox);
    }
    return margin;
  }
  _adjustParentBBoxes(bbox, path, level) {
    for (let i = level; i >= 0; i--) {
      extend2(path[i], bbox);
    }
  }
  _condense(path) {
    for (let i = path.length - 1, siblings; i >= 0; i--) {
      if (path[i].children.length === 0) {
        if (i > 0) {
          siblings = path[i - 1].children;
          siblings.splice(siblings.indexOf(path[i]), 1);
        } else
          this.clear();
      } else
        calcBBox(path[i], this.toBBox);
    }
  }
};
function findItem(item, items, equalsFn) {
  if (!equalsFn)
    return items.indexOf(item);
  for (let i = 0; i < items.length; i++) {
    if (equalsFn(item, items[i]))
      return i;
  }
  return -1;
}
function calcBBox(node, toBBox) {
  distBBox(node, 0, node.children.length, toBBox, node);
}
function distBBox(node, k, p, toBBox, destNode) {
  if (!destNode)
    destNode = createNode(null);
  destNode.minX = Infinity;
  destNode.minY = Infinity;
  destNode.maxX = -Infinity;
  destNode.maxY = -Infinity;
  for (let i = k; i < p; i++) {
    const child = node.children[i];
    extend2(destNode, node.leaf ? toBBox(child) : child);
  }
  return destNode;
}
function extend2(a, b) {
  a.minX = Math.min(a.minX, b.minX);
  a.minY = Math.min(a.minY, b.minY);
  a.maxX = Math.max(a.maxX, b.maxX);
  a.maxY = Math.max(a.maxY, b.maxY);
  return a;
}
function compareNodeMinX(a, b) {
  return a.minX - b.minX;
}
function compareNodeMinY(a, b) {
  return a.minY - b.minY;
}
function bboxArea(a) {
  return (a.maxX - a.minX) * (a.maxY - a.minY);
}
function bboxMargin(a) {
  return a.maxX - a.minX + (a.maxY - a.minY);
}
function enlargedArea(a, b) {
  return (Math.max(b.maxX, a.maxX) - Math.min(b.minX, a.minX)) * (Math.max(b.maxY, a.maxY) - Math.min(b.minY, a.minY));
}
function intersectionArea(a, b) {
  const minX = Math.max(a.minX, b.minX);
  const minY = Math.max(a.minY, b.minY);
  const maxX = Math.min(a.maxX, b.maxX);
  const maxY = Math.min(a.maxY, b.maxY);
  return Math.max(0, maxX - minX) * Math.max(0, maxY - minY);
}
function contains(a, b) {
  return a.minX <= b.minX && a.minY <= b.minY && b.maxX <= a.maxX && b.maxY <= a.maxY;
}
function intersects(a, b) {
  return b.minX <= a.maxX && b.minY <= a.maxY && b.maxX >= a.minX && b.maxY >= a.minY;
}
function createNode(children) {
  return {
    children,
    height: 1,
    leaf: true,
    minX: Infinity,
    minY: Infinity,
    maxX: -Infinity,
    maxY: -Infinity
  };
}
function multiSelect(arr, left, right, n, compare) {
  const stack = [left, right];
  while (stack.length) {
    right = stack.pop();
    left = stack.pop();
    if (right - left <= n)
      continue;
    const mid = left + Math.ceil((right - left) / n / 2) * n;
    quickselect(arr, mid, left, right, compare);
    stack.push(left, mid, mid, right);
  }
}

// node_modules/ol/structs/RBush.js
var RBush2 = function() {
  function RBush3(opt_maxEntries) {
    this.rbush_ = new RBush(opt_maxEntries);
    this.items_ = {};
  }
  RBush3.prototype.insert = function(extent, value) {
    var item = {
      minX: extent[0],
      minY: extent[1],
      maxX: extent[2],
      maxY: extent[3],
      value
    };
    this.rbush_.insert(item);
    this.items_[getUid(value)] = item;
  };
  RBush3.prototype.load = function(extents, values) {
    var items = new Array(values.length);
    for (var i = 0, l = values.length; i < l; i++) {
      var extent = extents[i];
      var value = values[i];
      var item = {
        minX: extent[0],
        minY: extent[1],
        maxX: extent[2],
        maxY: extent[3],
        value
      };
      items[i] = item;
      this.items_[getUid(value)] = item;
    }
    this.rbush_.load(items);
  };
  RBush3.prototype.remove = function(value) {
    var uid = getUid(value);
    var item = this.items_[uid];
    delete this.items_[uid];
    return this.rbush_.remove(item) !== null;
  };
  RBush3.prototype.update = function(extent, value) {
    var item = this.items_[getUid(value)];
    var bbox = [item.minX, item.minY, item.maxX, item.maxY];
    if (!equals(bbox, extent)) {
      this.remove(value);
      this.insert(extent, value);
    }
  };
  RBush3.prototype.getAll = function() {
    var items = this.rbush_.all();
    return items.map(function(item) {
      return item.value;
    });
  };
  RBush3.prototype.getInExtent = function(extent) {
    var bbox = {
      minX: extent[0],
      minY: extent[1],
      maxX: extent[2],
      maxY: extent[3]
    };
    var items = this.rbush_.search(bbox);
    return items.map(function(item) {
      return item.value;
    });
  };
  RBush3.prototype.forEach = function(callback) {
    return this.forEach_(this.getAll(), callback);
  };
  RBush3.prototype.forEachInExtent = function(extent, callback) {
    return this.forEach_(this.getInExtent(extent), callback);
  };
  RBush3.prototype.forEach_ = function(values, callback) {
    var result;
    for (var i = 0, l = values.length; i < l; i++) {
      result = callback(values[i]);
      if (result) {
        return result;
      }
    }
    return result;
  };
  RBush3.prototype.isEmpty = function() {
    return isEmpty(this.items_);
  };
  RBush3.prototype.clear = function() {
    this.rbush_.clear();
    this.items_ = {};
  };
  RBush3.prototype.getExtent = function(opt_extent) {
    var data = this.rbush_.toJSON();
    return createOrUpdate(data.minX, data.minY, data.maxX, data.maxY, opt_extent);
  };
  RBush3.prototype.concat = function(rbush) {
    this.rbush_.load(rbush.rbush_.all());
    for (var i in rbush.items_) {
      this.items_[i] = rbush.items_[i];
    }
  };
  return RBush3;
}();
var RBush_default = RBush2;

// node_modules/ol/source/VectorEventType.js
var VectorEventType_default = {
  ADDFEATURE: "addfeature",
  CHANGEFEATURE: "changefeature",
  CLEAR: "clear",
  REMOVEFEATURE: "removefeature",
  FEATURESLOADSTART: "featuresloadstart",
  FEATURESLOADEND: "featuresloadend",
  FEATURESLOADERROR: "featuresloaderror"
};

// node_modules/ol/loadingstrategy.js
function all(extent, resolution) {
  return [[-Infinity, -Infinity, Infinity, Infinity]];
}

// node_modules/ol/format/FormatType.js
var FormatType_default = {
  ARRAY_BUFFER: "arraybuffer",
  JSON: "json",
  TEXT: "text",
  XML: "xml"
};

// node_modules/ol/featureloader.js
var withCredentials = false;
function loadFeaturesXhr(url, format, extent, resolution, projection, success, failure) {
  var xhr2 = new XMLHttpRequest();
  xhr2.open("GET", typeof url === "function" ? url(extent, resolution, projection) : url, true);
  if (format.getType() == FormatType_default.ARRAY_BUFFER) {
    xhr2.responseType = "arraybuffer";
  }
  xhr2.withCredentials = withCredentials;
  xhr2.onload = function(event) {
    if (!xhr2.status || xhr2.status >= 200 && xhr2.status < 300) {
      var type = format.getType();
      var source = void 0;
      if (type == FormatType_default.JSON || type == FormatType_default.TEXT) {
        source = xhr2.responseText;
      } else if (type == FormatType_default.XML) {
        source = xhr2.responseXML;
        if (!source) {
          source = new DOMParser().parseFromString(xhr2.responseText, "application/xml");
        }
      } else if (type == FormatType_default.ARRAY_BUFFER) {
        source = xhr2.response;
      }
      if (source) {
        success(format.readFeatures(source, {
          extent,
          featureProjection: projection
        }), format.readProjection(source));
      } else {
        failure();
      }
    } else {
      failure();
    }
  };
  xhr2.onerror = failure;
  xhr2.send();
}
function xhr(url, format) {
  return function(extent, resolution, projection, success, failure) {
    var source = this;
    loadFeaturesXhr(url, format, extent, resolution, projection, function(features, dataProjection) {
      source.addFeatures(features);
      if (success !== void 0) {
        success(features);
      }
    }, failure ? failure : VOID);
  };
}

// node_modules/ol/source/Vector.js
var __extends2 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var VectorSourceEvent = function(_super) {
  __extends2(VectorSourceEvent2, _super);
  function VectorSourceEvent2(type, opt_feature, opt_features) {
    var _this = _super.call(this, type) || this;
    _this.feature = opt_feature;
    _this.features = opt_features;
    return _this;
  }
  return VectorSourceEvent2;
}(Event_default);
var VectorSource = function(_super) {
  __extends2(VectorSource2, _super);
  function VectorSource2(opt_options) {
    var _this = this;
    var options = opt_options || {};
    _this = _super.call(this, {
      attributions: options.attributions,
      projection: void 0,
      state: State_default.READY,
      wrapX: options.wrapX !== void 0 ? options.wrapX : true
    }) || this;
    _this.on;
    _this.once;
    _this.un;
    _this.loader_ = VOID;
    _this.format_ = options.format;
    _this.overlaps_ = options.overlaps === void 0 ? true : options.overlaps;
    _this.url_ = options.url;
    if (options.loader !== void 0) {
      _this.loader_ = options.loader;
    } else if (_this.url_ !== void 0) {
      assert(_this.format_, 7);
      _this.loader_ = xhr(_this.url_, _this.format_);
    }
    _this.strategy_ = options.strategy !== void 0 ? options.strategy : all;
    var useSpatialIndex = options.useSpatialIndex !== void 0 ? options.useSpatialIndex : true;
    _this.featuresRtree_ = useSpatialIndex ? new RBush_default() : null;
    _this.loadedExtentsRtree_ = new RBush_default();
    _this.loadingExtentsCount_ = 0;
    _this.nullGeometryFeatures_ = {};
    _this.idIndex_ = {};
    _this.uidIndex_ = {};
    _this.featureChangeKeys_ = {};
    _this.featuresCollection_ = null;
    var collection, features;
    if (Array.isArray(options.features)) {
      features = options.features;
    } else if (options.features) {
      collection = options.features;
      features = collection.getArray();
    }
    if (!useSpatialIndex && collection === void 0) {
      collection = new Collection_default(features);
    }
    if (features !== void 0) {
      _this.addFeaturesInternal(features);
    }
    if (collection !== void 0) {
      _this.bindFeaturesCollection_(collection);
    }
    return _this;
  }
  VectorSource2.prototype.addFeature = function(feature) {
    this.addFeatureInternal(feature);
    this.changed();
  };
  VectorSource2.prototype.addFeatureInternal = function(feature) {
    var featureKey = getUid(feature);
    if (!this.addToIndex_(featureKey, feature)) {
      if (this.featuresCollection_) {
        this.featuresCollection_.remove(feature);
      }
      return;
    }
    this.setupChangeEvents_(featureKey, feature);
    var geometry = feature.getGeometry();
    if (geometry) {
      var extent = geometry.getExtent();
      if (this.featuresRtree_) {
        this.featuresRtree_.insert(extent, feature);
      }
    } else {
      this.nullGeometryFeatures_[featureKey] = feature;
    }
    this.dispatchEvent(new VectorSourceEvent(VectorEventType_default.ADDFEATURE, feature));
  };
  VectorSource2.prototype.setupChangeEvents_ = function(featureKey, feature) {
    this.featureChangeKeys_[featureKey] = [
      listen(feature, EventType_default.CHANGE, this.handleFeatureChange_, this),
      listen(feature, ObjectEventType_default.PROPERTYCHANGE, this.handleFeatureChange_, this)
    ];
  };
  VectorSource2.prototype.addToIndex_ = function(featureKey, feature) {
    var valid = true;
    var id = feature.getId();
    if (id !== void 0) {
      if (!(id.toString() in this.idIndex_)) {
        this.idIndex_[id.toString()] = feature;
      } else {
        valid = false;
      }
    }
    if (valid) {
      assert(!(featureKey in this.uidIndex_), 30);
      this.uidIndex_[featureKey] = feature;
    }
    return valid;
  };
  VectorSource2.prototype.addFeatures = function(features) {
    this.addFeaturesInternal(features);
    this.changed();
  };
  VectorSource2.prototype.addFeaturesInternal = function(features) {
    var extents = [];
    var newFeatures = [];
    var geometryFeatures = [];
    for (var i = 0, length_1 = features.length; i < length_1; i++) {
      var feature = features[i];
      var featureKey = getUid(feature);
      if (this.addToIndex_(featureKey, feature)) {
        newFeatures.push(feature);
      }
    }
    for (var i = 0, length_2 = newFeatures.length; i < length_2; i++) {
      var feature = newFeatures[i];
      var featureKey = getUid(feature);
      this.setupChangeEvents_(featureKey, feature);
      var geometry = feature.getGeometry();
      if (geometry) {
        var extent = geometry.getExtent();
        extents.push(extent);
        geometryFeatures.push(feature);
      } else {
        this.nullGeometryFeatures_[featureKey] = feature;
      }
    }
    if (this.featuresRtree_) {
      this.featuresRtree_.load(extents, geometryFeatures);
    }
    for (var i = 0, length_3 = newFeatures.length; i < length_3; i++) {
      this.dispatchEvent(new VectorSourceEvent(VectorEventType_default.ADDFEATURE, newFeatures[i]));
    }
  };
  VectorSource2.prototype.bindFeaturesCollection_ = function(collection) {
    var modifyingCollection = false;
    this.addEventListener(VectorEventType_default.ADDFEATURE, function(evt) {
      if (!modifyingCollection) {
        modifyingCollection = true;
        collection.push(evt.feature);
        modifyingCollection = false;
      }
    });
    this.addEventListener(VectorEventType_default.REMOVEFEATURE, function(evt) {
      if (!modifyingCollection) {
        modifyingCollection = true;
        collection.remove(evt.feature);
        modifyingCollection = false;
      }
    });
    collection.addEventListener(CollectionEventType_default.ADD, function(evt) {
      if (!modifyingCollection) {
        modifyingCollection = true;
        this.addFeature(evt.element);
        modifyingCollection = false;
      }
    }.bind(this));
    collection.addEventListener(CollectionEventType_default.REMOVE, function(evt) {
      if (!modifyingCollection) {
        modifyingCollection = true;
        this.removeFeature(evt.element);
        modifyingCollection = false;
      }
    }.bind(this));
    this.featuresCollection_ = collection;
  };
  VectorSource2.prototype.clear = function(opt_fast) {
    if (opt_fast) {
      for (var featureId in this.featureChangeKeys_) {
        var keys = this.featureChangeKeys_[featureId];
        keys.forEach(unlistenByKey);
      }
      if (!this.featuresCollection_) {
        this.featureChangeKeys_ = {};
        this.idIndex_ = {};
        this.uidIndex_ = {};
      }
    } else {
      if (this.featuresRtree_) {
        this.featuresRtree_.forEach(this.removeFeatureInternal.bind(this));
        for (var id in this.nullGeometryFeatures_) {
          this.removeFeatureInternal(this.nullGeometryFeatures_[id]);
        }
      }
    }
    if (this.featuresCollection_) {
      this.featuresCollection_.clear();
    }
    if (this.featuresRtree_) {
      this.featuresRtree_.clear();
    }
    this.nullGeometryFeatures_ = {};
    var clearEvent = new VectorSourceEvent(VectorEventType_default.CLEAR);
    this.dispatchEvent(clearEvent);
    this.changed();
  };
  VectorSource2.prototype.forEachFeature = function(callback) {
    if (this.featuresRtree_) {
      return this.featuresRtree_.forEach(callback);
    } else if (this.featuresCollection_) {
      this.featuresCollection_.forEach(callback);
    }
  };
  VectorSource2.prototype.forEachFeatureAtCoordinateDirect = function(coordinate, callback) {
    var extent = [coordinate[0], coordinate[1], coordinate[0], coordinate[1]];
    return this.forEachFeatureInExtent(extent, function(feature) {
      var geometry = feature.getGeometry();
      if (geometry.intersectsCoordinate(coordinate)) {
        return callback(feature);
      } else {
        return void 0;
      }
    });
  };
  VectorSource2.prototype.forEachFeatureInExtent = function(extent, callback) {
    if (this.featuresRtree_) {
      return this.featuresRtree_.forEachInExtent(extent, callback);
    } else if (this.featuresCollection_) {
      this.featuresCollection_.forEach(callback);
    }
  };
  VectorSource2.prototype.forEachFeatureIntersectingExtent = function(extent, callback) {
    return this.forEachFeatureInExtent(extent, function(feature) {
      var geometry = feature.getGeometry();
      if (geometry.intersectsExtent(extent)) {
        var result = callback(feature);
        if (result) {
          return result;
        }
      }
    });
  };
  VectorSource2.prototype.getFeaturesCollection = function() {
    return this.featuresCollection_;
  };
  VectorSource2.prototype.getFeatures = function() {
    var features;
    if (this.featuresCollection_) {
      features = this.featuresCollection_.getArray().slice(0);
    } else if (this.featuresRtree_) {
      features = this.featuresRtree_.getAll();
      if (!isEmpty(this.nullGeometryFeatures_)) {
        extend(features, getValues(this.nullGeometryFeatures_));
      }
    }
    return features;
  };
  VectorSource2.prototype.getFeaturesAtCoordinate = function(coordinate) {
    var features = [];
    this.forEachFeatureAtCoordinateDirect(coordinate, function(feature) {
      features.push(feature);
    });
    return features;
  };
  VectorSource2.prototype.getFeaturesInExtent = function(extent) {
    if (this.featuresRtree_) {
      return this.featuresRtree_.getInExtent(extent);
    } else if (this.featuresCollection_) {
      return this.featuresCollection_.getArray().slice(0);
    } else {
      return [];
    }
  };
  VectorSource2.prototype.getClosestFeatureToCoordinate = function(coordinate, opt_filter) {
    var x = coordinate[0];
    var y = coordinate[1];
    var closestFeature = null;
    var closestPoint = [NaN, NaN];
    var minSquaredDistance = Infinity;
    var extent = [-Infinity, -Infinity, Infinity, Infinity];
    var filter = opt_filter ? opt_filter : TRUE;
    this.featuresRtree_.forEachInExtent(extent, function(feature) {
      if (filter(feature)) {
        var geometry = feature.getGeometry();
        var previousMinSquaredDistance = minSquaredDistance;
        minSquaredDistance = geometry.closestPointXY(x, y, closestPoint, minSquaredDistance);
        if (minSquaredDistance < previousMinSquaredDistance) {
          closestFeature = feature;
          var minDistance = Math.sqrt(minSquaredDistance);
          extent[0] = x - minDistance;
          extent[1] = y - minDistance;
          extent[2] = x + minDistance;
          extent[3] = y + minDistance;
        }
      }
    });
    return closestFeature;
  };
  VectorSource2.prototype.getExtent = function(opt_extent) {
    return this.featuresRtree_.getExtent(opt_extent);
  };
  VectorSource2.prototype.getFeatureById = function(id) {
    var feature = this.idIndex_[id.toString()];
    return feature !== void 0 ? feature : null;
  };
  VectorSource2.prototype.getFeatureByUid = function(uid) {
    var feature = this.uidIndex_[uid];
    return feature !== void 0 ? feature : null;
  };
  VectorSource2.prototype.getFormat = function() {
    return this.format_;
  };
  VectorSource2.prototype.getOverlaps = function() {
    return this.overlaps_;
  };
  VectorSource2.prototype.getUrl = function() {
    return this.url_;
  };
  VectorSource2.prototype.handleFeatureChange_ = function(event) {
    var feature = event.target;
    var featureKey = getUid(feature);
    var geometry = feature.getGeometry();
    if (!geometry) {
      if (!(featureKey in this.nullGeometryFeatures_)) {
        if (this.featuresRtree_) {
          this.featuresRtree_.remove(feature);
        }
        this.nullGeometryFeatures_[featureKey] = feature;
      }
    } else {
      var extent = geometry.getExtent();
      if (featureKey in this.nullGeometryFeatures_) {
        delete this.nullGeometryFeatures_[featureKey];
        if (this.featuresRtree_) {
          this.featuresRtree_.insert(extent, feature);
        }
      } else {
        if (this.featuresRtree_) {
          this.featuresRtree_.update(extent, feature);
        }
      }
    }
    var id = feature.getId();
    if (id !== void 0) {
      var sid = id.toString();
      if (this.idIndex_[sid] !== feature) {
        this.removeFromIdIndex_(feature);
        this.idIndex_[sid] = feature;
      }
    } else {
      this.removeFromIdIndex_(feature);
      this.uidIndex_[featureKey] = feature;
    }
    this.changed();
    this.dispatchEvent(new VectorSourceEvent(VectorEventType_default.CHANGEFEATURE, feature));
  };
  VectorSource2.prototype.hasFeature = function(feature) {
    var id = feature.getId();
    if (id !== void 0) {
      return id in this.idIndex_;
    } else {
      return getUid(feature) in this.uidIndex_;
    }
  };
  VectorSource2.prototype.isEmpty = function() {
    return this.featuresRtree_.isEmpty() && isEmpty(this.nullGeometryFeatures_);
  };
  VectorSource2.prototype.loadFeatures = function(extent, resolution, projection) {
    var loadedExtentsRtree = this.loadedExtentsRtree_;
    var extentsToLoad = this.strategy_(extent, resolution, projection);
    var _loop_1 = function(i2, ii2) {
      var extentToLoad = extentsToLoad[i2];
      var alreadyLoaded = loadedExtentsRtree.forEachInExtent(extentToLoad, function(object) {
        return containsExtent(object.extent, extentToLoad);
      });
      if (!alreadyLoaded) {
        ++this_1.loadingExtentsCount_;
        this_1.dispatchEvent(new VectorSourceEvent(VectorEventType_default.FEATURESLOADSTART));
        this_1.loader_.call(this_1, extentToLoad, resolution, projection, function(features) {
          --this.loadingExtentsCount_;
          this.dispatchEvent(new VectorSourceEvent(VectorEventType_default.FEATURESLOADEND, void 0, features));
        }.bind(this_1), function() {
          --this.loadingExtentsCount_;
          this.dispatchEvent(new VectorSourceEvent(VectorEventType_default.FEATURESLOADERROR));
        }.bind(this_1));
        loadedExtentsRtree.insert(extentToLoad, { extent: extentToLoad.slice() });
      }
    };
    var this_1 = this;
    for (var i = 0, ii = extentsToLoad.length; i < ii; ++i) {
      _loop_1(i, ii);
    }
    this.loading = this.loader_.length < 4 ? false : this.loadingExtentsCount_ > 0;
  };
  VectorSource2.prototype.refresh = function() {
    this.clear(true);
    this.loadedExtentsRtree_.clear();
    _super.prototype.refresh.call(this);
  };
  VectorSource2.prototype.removeLoadedExtent = function(extent) {
    var loadedExtentsRtree = this.loadedExtentsRtree_;
    var obj;
    loadedExtentsRtree.forEachInExtent(extent, function(object) {
      if (equals(object.extent, extent)) {
        obj = object;
        return true;
      }
    });
    if (obj) {
      loadedExtentsRtree.remove(obj);
    }
  };
  VectorSource2.prototype.removeFeature = function(feature) {
    var featureKey = getUid(feature);
    if (featureKey in this.nullGeometryFeatures_) {
      delete this.nullGeometryFeatures_[featureKey];
    } else {
      if (this.featuresRtree_) {
        this.featuresRtree_.remove(feature);
      }
    }
    this.removeFeatureInternal(feature);
    this.changed();
  };
  VectorSource2.prototype.removeFeatureInternal = function(feature) {
    var featureKey = getUid(feature);
    this.featureChangeKeys_[featureKey].forEach(unlistenByKey);
    delete this.featureChangeKeys_[featureKey];
    var id = feature.getId();
    if (id !== void 0) {
      delete this.idIndex_[id.toString()];
    }
    delete this.uidIndex_[featureKey];
    this.dispatchEvent(new VectorSourceEvent(VectorEventType_default.REMOVEFEATURE, feature));
  };
  VectorSource2.prototype.removeFromIdIndex_ = function(feature) {
    var removed = false;
    for (var id in this.idIndex_) {
      if (this.idIndex_[id] === feature) {
        delete this.idIndex_[id];
        removed = true;
        break;
      }
    }
    return removed;
  };
  VectorSource2.prototype.setLoader = function(loader) {
    this.loader_ = loader;
  };
  VectorSource2.prototype.setUrl = function(url) {
    assert(this.format_, 7);
    this.url_ = url;
    this.setLoader(xhr(url, this.format_));
  };
  return VectorSource2;
}(Source_default);
var Vector_default = VectorSource;

export {
  Feature_default,
  RBush,
  RBush_default,
  VectorEventType_default,
  FormatType_default,
  loadFeaturesXhr,
  Vector_default
};
//# sourceMappingURL=chunk-R2N4A362.js.map
