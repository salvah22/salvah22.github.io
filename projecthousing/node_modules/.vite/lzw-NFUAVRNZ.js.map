{
  "version": 3,
  "sources": ["../geotiff/src/compression/lzw.js"],
  "sourcesContent": ["import BaseDecoder from './basedecoder';\n\nconst MIN_BITS = 9;\nconst CLEAR_CODE = 256; // clear code\nconst EOI_CODE = 257; // end of information\nconst MAX_BYTELENGTH = 12;\n\nfunction getByte(array, position, length) {\n  const d = position % 8;\n  const a = Math.floor(position / 8);\n  const de = 8 - d;\n  const ef = (position + length) - ((a + 1) * 8);\n  let fg = (8 * (a + 2)) - (position + length);\n  const dg = ((a + 2) * 8) - position;\n  fg = Math.max(0, fg);\n  if (a >= array.length) {\n    console.warn('ran off the end of the buffer before finding EOI_CODE (end on input code)');\n    return EOI_CODE;\n  }\n  let chunk1 = array[a] & ((2 ** (8 - d)) - 1);\n  chunk1 <<= (length - de);\n  let chunks = chunk1;\n  if (a + 1 < array.length) {\n    let chunk2 = array[a + 1] >>> fg;\n    chunk2 <<= Math.max(0, (length - dg));\n    chunks += chunk2;\n  }\n  if (ef > 8 && a + 2 < array.length) {\n    const hi = ((a + 3) * 8) - (position + length);\n    const chunk3 = array[a + 2] >>> hi;\n    chunks += chunk3;\n  }\n  return chunks;\n}\n\nfunction appendReversed(dest, source) {\n  for (let i = source.length - 1; i >= 0; i--) {\n    dest.push(source[i]);\n  }\n  return dest;\n}\n\nfunction decompress(input) {\n  const dictionaryIndex = new Uint16Array(4093);\n  const dictionaryChar = new Uint8Array(4093);\n  for (let i = 0; i <= 257; i++) {\n    dictionaryIndex[i] = 4096;\n    dictionaryChar[i] = i;\n  }\n  let dictionaryLength = 258;\n  let byteLength = MIN_BITS;\n  let position = 0;\n\n  function initDictionary() {\n    dictionaryLength = 258;\n    byteLength = MIN_BITS;\n  }\n  function getNext(array) {\n    const byte = getByte(array, position, byteLength);\n    position += byteLength;\n    return byte;\n  }\n  function addToDictionary(i, c) {\n    dictionaryChar[dictionaryLength] = c;\n    dictionaryIndex[dictionaryLength] = i;\n    dictionaryLength++;\n    return dictionaryLength - 1;\n  }\n  function getDictionaryReversed(n) {\n    const rev = [];\n    for (let i = n; i !== 4096; i = dictionaryIndex[i]) {\n      rev.push(dictionaryChar[i]);\n    }\n    return rev;\n  }\n\n  const result = [];\n  initDictionary();\n  const array = new Uint8Array(input);\n  let code = getNext(array);\n  let oldCode;\n  while (code !== EOI_CODE) {\n    if (code === CLEAR_CODE) {\n      initDictionary();\n      code = getNext(array);\n      while (code === CLEAR_CODE) {\n        code = getNext(array);\n      }\n\n      if (code === EOI_CODE) {\n        break;\n      } else if (code > CLEAR_CODE) {\n        throw new Error(`corrupted code at scanline ${code}`);\n      } else {\n        const val = getDictionaryReversed(code);\n        appendReversed(result, val);\n        oldCode = code;\n      }\n    } else if (code < dictionaryLength) {\n      const val = getDictionaryReversed(code);\n      appendReversed(result, val);\n      addToDictionary(oldCode, val[val.length - 1]);\n      oldCode = code;\n    } else {\n      const oldVal = getDictionaryReversed(oldCode);\n      if (!oldVal) {\n        throw new Error(`Bogus entry. Not in dictionary, ${oldCode} / ${dictionaryLength}, position: ${position}`);\n      }\n      appendReversed(result, oldVal);\n      result.push(oldVal[oldVal.length - 1]);\n      addToDictionary(oldCode, oldVal[oldVal.length - 1]);\n      oldCode = code;\n    }\n\n    if (dictionaryLength + 1 >= (2 ** byteLength)) {\n      if (byteLength === MAX_BYTELENGTH) {\n        oldCode = undefined;\n      } else {\n        byteLength++;\n      }\n    }\n    code = getNext(array);\n  }\n  return new Uint8Array(result);\n}\n\nexport default class LZWDecoder extends BaseDecoder {\n  decodeBlock(buffer) {\n    return decompress(buffer, false).buffer;\n  }\n}\n"],
  "mappings": "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",
  "names": []
}
