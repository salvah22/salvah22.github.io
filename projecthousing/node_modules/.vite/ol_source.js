import {
  ExtraSamplesValues,
  arrayFields,
  fieldTagNames,
  fieldTypeNames,
  fieldTypes,
  geoKeyNames,
  photometricInterpretations
} from "./chunk-DQ7TIUXH.js";
import {
  Image_default as Image_default2,
  TileJSON_default,
  VectorTile_default,
  jsonp
} from "./chunk-WPVEXRRC.js";
import {
  ImageCanvas_default
} from "./chunk-WOA466RL.js";
import {
  Tile_default as Tile_default3
} from "./chunk-NW7TRGHZ.js";
import {
  ATTRIBUTION,
  OSM_default,
  XYZ_default
} from "./chunk-5RB4YYSZ.js";
import {
  DEFAULT_WMS_VERSION,
  ENABLE_RASTER_REPROJECTION,
  ERROR_THRESHOLD,
  IMAGE_SMOOTHING_DISABLED,
  TileEventType_default,
  TileGrid_default,
  TileImage_default,
  TileSourceEvent,
  Tile_default as Tile_default2,
  Triangulation_default,
  UrlTile_default,
  calculateSourceResolution,
  createFromTemplates,
  createFromTileUrlFunctions,
  createXYZ,
  expandUrl,
  extentFromProjection,
  nullTileUrlFunction,
  render
} from "./chunk-4KX2Z7AN.js";
import {
  ImageTile_default,
  Tile_default,
  createOrUpdate,
  getKeyZXY,
  hash
} from "./chunk-NJKL6WNU.js";
import "./chunk-3PBZTSJN.js";
import {
  TileQueue_default
} from "./chunk-JEWKH23N.js";
import {
  TileState_default
} from "./chunk-HED2RAPS.js";
import {
  Feature_default,
  Vector_default
} from "./chunk-R2N4A362.js";
import "./chunk-ZFBLI5RQ.js";
import {
  Source_default
} from "./chunk-WSGYOD7F.js";
import "./chunk-MXUD2ERE.js";
import "./chunk-UP4W2OAM.js";
import {
  State_default
} from "./chunk-WY5HO4B4.js";
import {
  DEFAULT_TILE_SIZE
} from "./chunk-B652NQ5D.js";
import "./chunk-ASMMZL4F.js";
import {
  Point_default
} from "./chunk-PTILDF6P.js";
import {
  create
} from "./chunk-PFTE5SWF.js";
import "./chunk-JTYCLD24.js";
import {
  Projection_default,
  equivalent,
  fromCode,
  get,
  getTransformFromProjections,
  toUserCoordinate,
  toUserExtent,
  transform,
  transformExtent
} from "./chunk-JXQAEIDL.js";
import "./chunk-EICDL4AO.js";
import {
  add,
  compareVersions,
  scale
} from "./chunk-LHS2CK4K.js";
import {
  ImageBase_default,
  Image_default
} from "./chunk-5VKD2OW7.js";
import {
  ImageState_default
} from "./chunk-BH46YA6A.js";
import {
  buffer as buffer2,
  scale as scale2,
  toSize
} from "./chunk-RV5QOKWV.js";
import "./chunk-DZUBOF3Z.js";
import {
  createCanvasContext2D
} from "./chunk-R7IGQKZX.js";
import {
  GeometryType_default
} from "./chunk-IE72MASW.js";
import {
  clamp,
  modulo
} from "./chunk-LZTVAMAD.js";
import "./chunk-KYXP4QQS.js";
import {
  Disposable_default,
  EventType_default,
  Event_default,
  includes,
  linearFindNearest,
  listen,
  listenOnce,
  unlistenByKey
} from "./chunk-XYO5KJKP.js";
import {
  assign
} from "./chunk-WONFBMYW.js";
import {
  abstract,
  applyTransform,
  assert,
  buffer,
  containsExtent,
  createEmpty,
  createOrUpdateFromCoordinate,
  equals,
  getCenter,
  getForViewAndSize,
  getHeight,
  getIntersection,
  getTopLeft,
  getUid,
  getWidth,
  intersects,
  scaleFromCenter
} from "./chunk-V7OLV3U6.js";
import {
  __commonJS,
  __objRest,
  __spreadProps,
  __spreadValues,
  __toModule
} from "./chunk-RITGDPBK.js";

// node_modules/xml-utils/get-attribute.js
var require_get_attribute = __commonJS({
  "node_modules/xml-utils/get-attribute.js"(exports, module) {
    function getAttribute2(tag, attributeName, options) {
      const debug = options && options.debug || false;
      if (debug)
        console.log("getting " + attributeName + " in " + tag);
      const xml = typeof tag === "object" ? tag.outer : tag;
      const pattern = `${attributeName}\\="([^"]*)"`;
      if (debug)
        console.log("pattern:", pattern);
      const re = new RegExp(pattern);
      const match = re.exec(xml);
      if (debug)
        console.log("match:", match);
      if (match)
        return match[1];
    }
    module.exports = getAttribute2;
  }
});

// node_modules/xml-utils/index-of-match.js
var require_index_of_match = __commonJS({
  "node_modules/xml-utils/index-of-match.js"(exports, module) {
    function indexOfMatch(xml, pattern, startIndex) {
      const re = new RegExp(pattern);
      const match = re.exec(xml.slice(startIndex));
      if (match)
        return startIndex + match.index;
      else
        return -1;
    }
    module.exports = indexOfMatch;
  }
});

// node_modules/xml-utils/find-tag-by-name.js
var require_find_tag_by_name = __commonJS({
  "node_modules/xml-utils/find-tag-by-name.js"(exports, module) {
    var indexOfMatch = require_index_of_match();
    function findTagByName(xml, tagName, options) {
      const debug = options && options.debug || false;
      const startIndex = options && options.startIndex || 0;
      if (debug)
        console.log("starting findTagByName with", tagName, " and ", options);
      const start = indexOfMatch(xml, `<${tagName}[ >]`, startIndex);
      if (debug)
        console.log("start:", start);
      if (start === -1)
        return void 0;
      const afterStart = xml.slice(start + tagName.length);
      let relativeEnd = indexOfMatch(afterStart, "[ /]" + tagName + ">", 0);
      const selfClosing = relativeEnd === -1;
      if (selfClosing) {
        relativeEnd = indexOfMatch(afterStart, "[ /]>", 0);
      }
      const end = start + tagName.length + relativeEnd + 1 + (selfClosing ? 0 : tagName.length) + 1;
      if (debug)
        console.log("end:", end);
      if (end === -1)
        return void 0;
      const outer = xml.slice(start, end);
      let inner;
      if (selfClosing) {
        inner = null;
      } else {
        inner = outer.slice(outer.indexOf(">") + 1, outer.lastIndexOf("<"));
      }
      return { inner, outer, start, end };
    }
    module.exports = findTagByName;
  }
});

// node_modules/xml-utils/find-tags-by-name.js
var require_find_tags_by_name = __commonJS({
  "node_modules/xml-utils/find-tags-by-name.js"(exports, module) {
    var findTagByName = require_find_tag_by_name();
    function findTagsByName2(xml, tagName, options) {
      const tags = [];
      const debug = options && options.debug || false;
      let startIndex = options && options.startIndex || 0;
      let tag;
      while (tag = findTagByName(xml, tagName, { debug, startIndex })) {
        startIndex = tag.end;
        tags.push(tag);
      }
      if (debug)
        console.log("findTagsByName found", tags.length, "tags");
      return tags;
    }
    module.exports = findTagsByName2;
  }
});

// node_modules/ms/index.js
var require_ms = __commonJS({
  "node_modules/ms/index.js"(exports, module) {
    var s = 1e3;
    var m = s * 60;
    var h = m * 60;
    var d = h * 24;
    var w = d * 7;
    var y = d * 365.25;
    module.exports = function(val, options) {
      options = options || {};
      var type = typeof val;
      if (type === "string" && val.length > 0) {
        return parse(val);
      } else if (type === "number" && isFinite(val)) {
        return options.long ? fmtLong(val) : fmtShort(val);
      }
      throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(val));
    };
    function parse(str) {
      str = String(str);
      if (str.length > 100) {
        return;
      }
      var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(str);
      if (!match) {
        return;
      }
      var n = parseFloat(match[1]);
      var type = (match[2] || "ms").toLowerCase();
      switch (type) {
        case "years":
        case "year":
        case "yrs":
        case "yr":
        case "y":
          return n * y;
        case "weeks":
        case "week":
        case "w":
          return n * w;
        case "days":
        case "day":
        case "d":
          return n * d;
        case "hours":
        case "hour":
        case "hrs":
        case "hr":
        case "h":
          return n * h;
        case "minutes":
        case "minute":
        case "mins":
        case "min":
        case "m":
          return n * m;
        case "seconds":
        case "second":
        case "secs":
        case "sec":
        case "s":
          return n * s;
        case "milliseconds":
        case "millisecond":
        case "msecs":
        case "msec":
        case "ms":
          return n;
        default:
          return void 0;
      }
    }
    function fmtShort(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return Math.round(ms / d) + "d";
      }
      if (msAbs >= h) {
        return Math.round(ms / h) + "h";
      }
      if (msAbs >= m) {
        return Math.round(ms / m) + "m";
      }
      if (msAbs >= s) {
        return Math.round(ms / s) + "s";
      }
      return ms + "ms";
    }
    function fmtLong(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return plural(ms, msAbs, d, "day");
      }
      if (msAbs >= h) {
        return plural(ms, msAbs, h, "hour");
      }
      if (msAbs >= m) {
        return plural(ms, msAbs, m, "minute");
      }
      if (msAbs >= s) {
        return plural(ms, msAbs, s, "second");
      }
      return ms + " ms";
    }
    function plural(ms, msAbs, n, name) {
      var isPlural = msAbs >= n * 1.5;
      return Math.round(ms / n) + " " + name + (isPlural ? "s" : "");
    }
  }
});

// node_modules/debug/src/common.js
var require_common = __commonJS({
  "node_modules/debug/src/common.js"(exports, module) {
    function setup(env) {
      createDebug.debug = createDebug;
      createDebug.default = createDebug;
      createDebug.coerce = coerce;
      createDebug.disable = disable;
      createDebug.enable = enable;
      createDebug.enabled = enabled;
      createDebug.humanize = require_ms();
      createDebug.destroy = destroy;
      Object.keys(env).forEach((key) => {
        createDebug[key] = env[key];
      });
      createDebug.names = [];
      createDebug.skips = [];
      createDebug.formatters = {};
      function selectColor(namespace) {
        let hash2 = 0;
        for (let i = 0; i < namespace.length; i++) {
          hash2 = (hash2 << 5) - hash2 + namespace.charCodeAt(i);
          hash2 |= 0;
        }
        return createDebug.colors[Math.abs(hash2) % createDebug.colors.length];
      }
      createDebug.selectColor = selectColor;
      function createDebug(namespace) {
        let prevTime;
        let enableOverride = null;
        let namespacesCache;
        let enabledCache;
        function debug(...args) {
          if (!debug.enabled) {
            return;
          }
          const self2 = debug;
          const curr = Number(new Date());
          const ms = curr - (prevTime || curr);
          self2.diff = ms;
          self2.prev = prevTime;
          self2.curr = curr;
          prevTime = curr;
          args[0] = createDebug.coerce(args[0]);
          if (typeof args[0] !== "string") {
            args.unshift("%O");
          }
          let index = 0;
          args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
            if (match === "%%") {
              return "%";
            }
            index++;
            const formatter = createDebug.formatters[format];
            if (typeof formatter === "function") {
              const val = args[index];
              match = formatter.call(self2, val);
              args.splice(index, 1);
              index--;
            }
            return match;
          });
          createDebug.formatArgs.call(self2, args);
          const logFn = self2.log || createDebug.log;
          logFn.apply(self2, args);
        }
        debug.namespace = namespace;
        debug.useColors = createDebug.useColors();
        debug.color = createDebug.selectColor(namespace);
        debug.extend = extend;
        debug.destroy = createDebug.destroy;
        Object.defineProperty(debug, "enabled", {
          enumerable: true,
          configurable: false,
          get: () => {
            if (enableOverride !== null) {
              return enableOverride;
            }
            if (namespacesCache !== createDebug.namespaces) {
              namespacesCache = createDebug.namespaces;
              enabledCache = createDebug.enabled(namespace);
            }
            return enabledCache;
          },
          set: (v) => {
            enableOverride = v;
          }
        });
        if (typeof createDebug.init === "function") {
          createDebug.init(debug);
        }
        return debug;
      }
      function extend(namespace, delimiter) {
        const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
        newDebug.log = this.log;
        return newDebug;
      }
      function enable(namespaces) {
        createDebug.save(namespaces);
        createDebug.namespaces = namespaces;
        createDebug.names = [];
        createDebug.skips = [];
        let i;
        const split = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
        const len = split.length;
        for (i = 0; i < len; i++) {
          if (!split[i]) {
            continue;
          }
          namespaces = split[i].replace(/\*/g, ".*?");
          if (namespaces[0] === "-") {
            createDebug.skips.push(new RegExp("^" + namespaces.substr(1) + "$"));
          } else {
            createDebug.names.push(new RegExp("^" + namespaces + "$"));
          }
        }
      }
      function disable() {
        const namespaces = [
          ...createDebug.names.map(toNamespace),
          ...createDebug.skips.map(toNamespace).map((namespace) => "-" + namespace)
        ].join(",");
        createDebug.enable("");
        return namespaces;
      }
      function enabled(name) {
        if (name[name.length - 1] === "*") {
          return true;
        }
        let i;
        let len;
        for (i = 0, len = createDebug.skips.length; i < len; i++) {
          if (createDebug.skips[i].test(name)) {
            return false;
          }
        }
        for (i = 0, len = createDebug.names.length; i < len; i++) {
          if (createDebug.names[i].test(name)) {
            return true;
          }
        }
        return false;
      }
      function toNamespace(regexp) {
        return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\.\*\?$/, "*");
      }
      function coerce(val) {
        if (val instanceof Error) {
          return val.stack || val.message;
        }
        return val;
      }
      function destroy() {
        console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
      }
      createDebug.enable(createDebug.load());
      return createDebug;
    }
    module.exports = setup;
  }
});

// node_modules/debug/src/browser.js
var require_browser = __commonJS({
  "node_modules/debug/src/browser.js"(exports, module) {
    exports.formatArgs = formatArgs;
    exports.save = save;
    exports.load = load;
    exports.useColors = useColors;
    exports.storage = localstorage();
    exports.destroy = (() => {
      let warned = false;
      return () => {
        if (!warned) {
          warned = true;
          console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
        }
      };
    })();
    exports.colors = [
      "#0000CC",
      "#0000FF",
      "#0033CC",
      "#0033FF",
      "#0066CC",
      "#0066FF",
      "#0099CC",
      "#0099FF",
      "#00CC00",
      "#00CC33",
      "#00CC66",
      "#00CC99",
      "#00CCCC",
      "#00CCFF",
      "#3300CC",
      "#3300FF",
      "#3333CC",
      "#3333FF",
      "#3366CC",
      "#3366FF",
      "#3399CC",
      "#3399FF",
      "#33CC00",
      "#33CC33",
      "#33CC66",
      "#33CC99",
      "#33CCCC",
      "#33CCFF",
      "#6600CC",
      "#6600FF",
      "#6633CC",
      "#6633FF",
      "#66CC00",
      "#66CC33",
      "#9900CC",
      "#9900FF",
      "#9933CC",
      "#9933FF",
      "#99CC00",
      "#99CC33",
      "#CC0000",
      "#CC0033",
      "#CC0066",
      "#CC0099",
      "#CC00CC",
      "#CC00FF",
      "#CC3300",
      "#CC3333",
      "#CC3366",
      "#CC3399",
      "#CC33CC",
      "#CC33FF",
      "#CC6600",
      "#CC6633",
      "#CC9900",
      "#CC9933",
      "#CCCC00",
      "#CCCC33",
      "#FF0000",
      "#FF0033",
      "#FF0066",
      "#FF0099",
      "#FF00CC",
      "#FF00FF",
      "#FF3300",
      "#FF3333",
      "#FF3366",
      "#FF3399",
      "#FF33CC",
      "#FF33FF",
      "#FF6600",
      "#FF6633",
      "#FF9900",
      "#FF9933",
      "#FFCC00",
      "#FFCC33"
    ];
    function useColors() {
      if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
        return true;
      }
      if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
        return false;
      }
      return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    function formatArgs(args) {
      args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module.exports.humanize(this.diff);
      if (!this.useColors) {
        return;
      }
      const c = "color: " + this.color;
      args.splice(1, 0, c, "color: inherit");
      let index = 0;
      let lastC = 0;
      args[0].replace(/%[a-zA-Z%]/g, (match) => {
        if (match === "%%") {
          return;
        }
        index++;
        if (match === "%c") {
          lastC = index;
        }
      });
      args.splice(lastC, 0, c);
    }
    exports.log = console.debug || console.log || (() => {
    });
    function save(namespaces) {
      try {
        if (namespaces) {
          exports.storage.setItem("debug", namespaces);
        } else {
          exports.storage.removeItem("debug");
        }
      } catch (error) {
      }
    }
    function load() {
      let r;
      try {
        r = exports.storage.getItem("debug");
      } catch (error) {
      }
      if (!r && typeof process !== "undefined" && "env" in process) {
        r = process.env.DEBUG;
      }
      return r;
    }
    function localstorage() {
      try {
        return localStorage;
      } catch (error) {
      }
    }
    module.exports = require_common()(exports);
    var { formatters } = module.exports;
    formatters.j = function(v) {
      try {
        return JSON.stringify(v);
      } catch (error) {
        return "[UnexpectedJSONParseError]: " + error.message;
      }
    };
  }
});

// node_modules/is-observable/index.js
var require_is_observable = __commonJS({
  "node_modules/is-observable/index.js"(exports, module) {
    "use strict";
    module.exports = (value) => {
      if (!value) {
        return false;
      }
      if (typeof Symbol.observable === "symbol" && typeof value[Symbol.observable] === "function") {
        return value === value[Symbol.observable]();
      }
      if (typeof value["@@observable"] === "function") {
        return value === value["@@observable"]();
      }
      return false;
    };
  }
});

// node_modules/yallist/iterator.js
var require_iterator = __commonJS({
  "node_modules/yallist/iterator.js"(exports, module) {
    "use strict";
    module.exports = function(Yallist) {
      Yallist.prototype[Symbol.iterator] = function* () {
        for (let walker = this.head; walker; walker = walker.next) {
          yield walker.value;
        }
      };
    };
  }
});

// node_modules/yallist/yallist.js
var require_yallist = __commonJS({
  "node_modules/yallist/yallist.js"(exports, module) {
    "use strict";
    module.exports = Yallist;
    Yallist.Node = Node;
    Yallist.create = Yallist;
    function Yallist(list) {
      var self2 = this;
      if (!(self2 instanceof Yallist)) {
        self2 = new Yallist();
      }
      self2.tail = null;
      self2.head = null;
      self2.length = 0;
      if (list && typeof list.forEach === "function") {
        list.forEach(function(item) {
          self2.push(item);
        });
      } else if (arguments.length > 0) {
        for (var i = 0, l = arguments.length; i < l; i++) {
          self2.push(arguments[i]);
        }
      }
      return self2;
    }
    Yallist.prototype.removeNode = function(node) {
      if (node.list !== this) {
        throw new Error("removing node which does not belong to this list");
      }
      var next2 = node.next;
      var prev = node.prev;
      if (next2) {
        next2.prev = prev;
      }
      if (prev) {
        prev.next = next2;
      }
      if (node === this.head) {
        this.head = next2;
      }
      if (node === this.tail) {
        this.tail = prev;
      }
      node.list.length--;
      node.next = null;
      node.prev = null;
      node.list = null;
      return next2;
    };
    Yallist.prototype.unshiftNode = function(node) {
      if (node === this.head) {
        return;
      }
      if (node.list) {
        node.list.removeNode(node);
      }
      var head = this.head;
      node.list = this;
      node.next = head;
      if (head) {
        head.prev = node;
      }
      this.head = node;
      if (!this.tail) {
        this.tail = node;
      }
      this.length++;
    };
    Yallist.prototype.pushNode = function(node) {
      if (node === this.tail) {
        return;
      }
      if (node.list) {
        node.list.removeNode(node);
      }
      var tail = this.tail;
      node.list = this;
      node.prev = tail;
      if (tail) {
        tail.next = node;
      }
      this.tail = node;
      if (!this.head) {
        this.head = node;
      }
      this.length++;
    };
    Yallist.prototype.push = function() {
      for (var i = 0, l = arguments.length; i < l; i++) {
        push(this, arguments[i]);
      }
      return this.length;
    };
    Yallist.prototype.unshift = function() {
      for (var i = 0, l = arguments.length; i < l; i++) {
        unshift(this, arguments[i]);
      }
      return this.length;
    };
    Yallist.prototype.pop = function() {
      if (!this.tail) {
        return void 0;
      }
      var res = this.tail.value;
      this.tail = this.tail.prev;
      if (this.tail) {
        this.tail.next = null;
      } else {
        this.head = null;
      }
      this.length--;
      return res;
    };
    Yallist.prototype.shift = function() {
      if (!this.head) {
        return void 0;
      }
      var res = this.head.value;
      this.head = this.head.next;
      if (this.head) {
        this.head.prev = null;
      } else {
        this.tail = null;
      }
      this.length--;
      return res;
    };
    Yallist.prototype.forEach = function(fn, thisp) {
      thisp = thisp || this;
      for (var walker = this.head, i = 0; walker !== null; i++) {
        fn.call(thisp, walker.value, i, this);
        walker = walker.next;
      }
    };
    Yallist.prototype.forEachReverse = function(fn, thisp) {
      thisp = thisp || this;
      for (var walker = this.tail, i = this.length - 1; walker !== null; i--) {
        fn.call(thisp, walker.value, i, this);
        walker = walker.prev;
      }
    };
    Yallist.prototype.get = function(n) {
      for (var i = 0, walker = this.head; walker !== null && i < n; i++) {
        walker = walker.next;
      }
      if (i === n && walker !== null) {
        return walker.value;
      }
    };
    Yallist.prototype.getReverse = function(n) {
      for (var i = 0, walker = this.tail; walker !== null && i < n; i++) {
        walker = walker.prev;
      }
      if (i === n && walker !== null) {
        return walker.value;
      }
    };
    Yallist.prototype.map = function(fn, thisp) {
      thisp = thisp || this;
      var res = new Yallist();
      for (var walker = this.head; walker !== null; ) {
        res.push(fn.call(thisp, walker.value, this));
        walker = walker.next;
      }
      return res;
    };
    Yallist.prototype.mapReverse = function(fn, thisp) {
      thisp = thisp || this;
      var res = new Yallist();
      for (var walker = this.tail; walker !== null; ) {
        res.push(fn.call(thisp, walker.value, this));
        walker = walker.prev;
      }
      return res;
    };
    Yallist.prototype.reduce = function(fn, initial) {
      var acc;
      var walker = this.head;
      if (arguments.length > 1) {
        acc = initial;
      } else if (this.head) {
        walker = this.head.next;
        acc = this.head.value;
      } else {
        throw new TypeError("Reduce of empty list with no initial value");
      }
      for (var i = 0; walker !== null; i++) {
        acc = fn(acc, walker.value, i);
        walker = walker.next;
      }
      return acc;
    };
    Yallist.prototype.reduceReverse = function(fn, initial) {
      var acc;
      var walker = this.tail;
      if (arguments.length > 1) {
        acc = initial;
      } else if (this.tail) {
        walker = this.tail.prev;
        acc = this.tail.value;
      } else {
        throw new TypeError("Reduce of empty list with no initial value");
      }
      for (var i = this.length - 1; walker !== null; i--) {
        acc = fn(acc, walker.value, i);
        walker = walker.prev;
      }
      return acc;
    };
    Yallist.prototype.toArray = function() {
      var arr = new Array(this.length);
      for (var i = 0, walker = this.head; walker !== null; i++) {
        arr[i] = walker.value;
        walker = walker.next;
      }
      return arr;
    };
    Yallist.prototype.toArrayReverse = function() {
      var arr = new Array(this.length);
      for (var i = 0, walker = this.tail; walker !== null; i++) {
        arr[i] = walker.value;
        walker = walker.prev;
      }
      return arr;
    };
    Yallist.prototype.slice = function(from, to) {
      to = to || this.length;
      if (to < 0) {
        to += this.length;
      }
      from = from || 0;
      if (from < 0) {
        from += this.length;
      }
      var ret = new Yallist();
      if (to < from || to < 0) {
        return ret;
      }
      if (from < 0) {
        from = 0;
      }
      if (to > this.length) {
        to = this.length;
      }
      for (var i = 0, walker = this.head; walker !== null && i < from; i++) {
        walker = walker.next;
      }
      for (; walker !== null && i < to; i++, walker = walker.next) {
        ret.push(walker.value);
      }
      return ret;
    };
    Yallist.prototype.sliceReverse = function(from, to) {
      to = to || this.length;
      if (to < 0) {
        to += this.length;
      }
      from = from || 0;
      if (from < 0) {
        from += this.length;
      }
      var ret = new Yallist();
      if (to < from || to < 0) {
        return ret;
      }
      if (from < 0) {
        from = 0;
      }
      if (to > this.length) {
        to = this.length;
      }
      for (var i = this.length, walker = this.tail; walker !== null && i > to; i--) {
        walker = walker.prev;
      }
      for (; walker !== null && i > from; i--, walker = walker.prev) {
        ret.push(walker.value);
      }
      return ret;
    };
    Yallist.prototype.splice = function(start, deleteCount, ...nodes) {
      if (start > this.length) {
        start = this.length - 1;
      }
      if (start < 0) {
        start = this.length + start;
      }
      for (var i = 0, walker = this.head; walker !== null && i < start; i++) {
        walker = walker.next;
      }
      var ret = [];
      for (var i = 0; walker && i < deleteCount; i++) {
        ret.push(walker.value);
        walker = this.removeNode(walker);
      }
      if (walker === null) {
        walker = this.tail;
      }
      if (walker !== this.head && walker !== this.tail) {
        walker = walker.prev;
      }
      for (var i = 0; i < nodes.length; i++) {
        walker = insert(this, walker, nodes[i]);
      }
      return ret;
    };
    Yallist.prototype.reverse = function() {
      var head = this.head;
      var tail = this.tail;
      for (var walker = head; walker !== null; walker = walker.prev) {
        var p = walker.prev;
        walker.prev = walker.next;
        walker.next = p;
      }
      this.head = tail;
      this.tail = head;
      return this;
    };
    function insert(self2, node, value) {
      var inserted = node === self2.head ? new Node(value, null, node, self2) : new Node(value, node, node.next, self2);
      if (inserted.next === null) {
        self2.tail = inserted;
      }
      if (inserted.prev === null) {
        self2.head = inserted;
      }
      self2.length++;
      return inserted;
    }
    function push(self2, item) {
      self2.tail = new Node(item, self2.tail, null, self2);
      if (!self2.head) {
        self2.head = self2.tail;
      }
      self2.length++;
    }
    function unshift(self2, item) {
      self2.head = new Node(item, null, self2.head, self2);
      if (!self2.tail) {
        self2.tail = self2.head;
      }
      self2.length++;
    }
    function Node(value, prev, next2, list) {
      if (!(this instanceof Node)) {
        return new Node(value, prev, next2, list);
      }
      this.list = list;
      this.value = value;
      if (prev) {
        prev.next = this;
        this.prev = prev;
      } else {
        this.prev = null;
      }
      if (next2) {
        next2.prev = this;
        this.next = next2;
      } else {
        this.next = null;
      }
    }
    try {
      require_iterator()(Yallist);
    } catch (er) {
    }
  }
});

// node_modules/lru-cache/index.js
var require_lru_cache = __commonJS({
  "node_modules/lru-cache/index.js"(exports, module) {
    "use strict";
    var Yallist = require_yallist();
    var MAX = Symbol("max");
    var LENGTH = Symbol("length");
    var LENGTH_CALCULATOR = Symbol("lengthCalculator");
    var ALLOW_STALE = Symbol("allowStale");
    var MAX_AGE = Symbol("maxAge");
    var DISPOSE = Symbol("dispose");
    var NO_DISPOSE_ON_SET = Symbol("noDisposeOnSet");
    var LRU_LIST = Symbol("lruList");
    var CACHE = Symbol("cache");
    var UPDATE_AGE_ON_GET = Symbol("updateAgeOnGet");
    var naiveLength = () => 1;
    var LRUCache2 = class {
      constructor(options) {
        if (typeof options === "number")
          options = { max: options };
        if (!options)
          options = {};
        if (options.max && (typeof options.max !== "number" || options.max < 0))
          throw new TypeError("max must be a non-negative number");
        const max = this[MAX] = options.max || Infinity;
        const lc = options.length || naiveLength;
        this[LENGTH_CALCULATOR] = typeof lc !== "function" ? naiveLength : lc;
        this[ALLOW_STALE] = options.stale || false;
        if (options.maxAge && typeof options.maxAge !== "number")
          throw new TypeError("maxAge must be a number");
        this[MAX_AGE] = options.maxAge || 0;
        this[DISPOSE] = options.dispose;
        this[NO_DISPOSE_ON_SET] = options.noDisposeOnSet || false;
        this[UPDATE_AGE_ON_GET] = options.updateAgeOnGet || false;
        this.reset();
      }
      set max(mL) {
        if (typeof mL !== "number" || mL < 0)
          throw new TypeError("max must be a non-negative number");
        this[MAX] = mL || Infinity;
        trim(this);
      }
      get max() {
        return this[MAX];
      }
      set allowStale(allowStale) {
        this[ALLOW_STALE] = !!allowStale;
      }
      get allowStale() {
        return this[ALLOW_STALE];
      }
      set maxAge(mA) {
        if (typeof mA !== "number")
          throw new TypeError("maxAge must be a non-negative number");
        this[MAX_AGE] = mA;
        trim(this);
      }
      get maxAge() {
        return this[MAX_AGE];
      }
      set lengthCalculator(lC) {
        if (typeof lC !== "function")
          lC = naiveLength;
        if (lC !== this[LENGTH_CALCULATOR]) {
          this[LENGTH_CALCULATOR] = lC;
          this[LENGTH] = 0;
          this[LRU_LIST].forEach((hit) => {
            hit.length = this[LENGTH_CALCULATOR](hit.value, hit.key);
            this[LENGTH] += hit.length;
          });
        }
        trim(this);
      }
      get lengthCalculator() {
        return this[LENGTH_CALCULATOR];
      }
      get length() {
        return this[LENGTH];
      }
      get itemCount() {
        return this[LRU_LIST].length;
      }
      rforEach(fn, thisp) {
        thisp = thisp || this;
        for (let walker = this[LRU_LIST].tail; walker !== null; ) {
          const prev = walker.prev;
          forEachStep(this, fn, walker, thisp);
          walker = prev;
        }
      }
      forEach(fn, thisp) {
        thisp = thisp || this;
        for (let walker = this[LRU_LIST].head; walker !== null; ) {
          const next2 = walker.next;
          forEachStep(this, fn, walker, thisp);
          walker = next2;
        }
      }
      keys() {
        return this[LRU_LIST].toArray().map((k) => k.key);
      }
      values() {
        return this[LRU_LIST].toArray().map((k) => k.value);
      }
      reset() {
        if (this[DISPOSE] && this[LRU_LIST] && this[LRU_LIST].length) {
          this[LRU_LIST].forEach((hit) => this[DISPOSE](hit.key, hit.value));
        }
        this[CACHE] = new Map();
        this[LRU_LIST] = new Yallist();
        this[LENGTH] = 0;
      }
      dump() {
        return this[LRU_LIST].map((hit) => isStale(this, hit) ? false : {
          k: hit.key,
          v: hit.value,
          e: hit.now + (hit.maxAge || 0)
        }).toArray().filter((h) => h);
      }
      dumpLru() {
        return this[LRU_LIST];
      }
      set(key, value, maxAge) {
        maxAge = maxAge || this[MAX_AGE];
        if (maxAge && typeof maxAge !== "number")
          throw new TypeError("maxAge must be a number");
        const now = maxAge ? Date.now() : 0;
        const len = this[LENGTH_CALCULATOR](value, key);
        if (this[CACHE].has(key)) {
          if (len > this[MAX]) {
            del(this, this[CACHE].get(key));
            return false;
          }
          const node = this[CACHE].get(key);
          const item = node.value;
          if (this[DISPOSE]) {
            if (!this[NO_DISPOSE_ON_SET])
              this[DISPOSE](key, item.value);
          }
          item.now = now;
          item.maxAge = maxAge;
          item.value = value;
          this[LENGTH] += len - item.length;
          item.length = len;
          this.get(key);
          trim(this);
          return true;
        }
        const hit = new Entry(key, value, len, now, maxAge);
        if (hit.length > this[MAX]) {
          if (this[DISPOSE])
            this[DISPOSE](key, value);
          return false;
        }
        this[LENGTH] += hit.length;
        this[LRU_LIST].unshift(hit);
        this[CACHE].set(key, this[LRU_LIST].head);
        trim(this);
        return true;
      }
      has(key) {
        if (!this[CACHE].has(key))
          return false;
        const hit = this[CACHE].get(key).value;
        return !isStale(this, hit);
      }
      get(key) {
        return get2(this, key, true);
      }
      peek(key) {
        return get2(this, key, false);
      }
      pop() {
        const node = this[LRU_LIST].tail;
        if (!node)
          return null;
        del(this, node);
        return node.value;
      }
      del(key) {
        del(this, this[CACHE].get(key));
      }
      load(arr) {
        this.reset();
        const now = Date.now();
        for (let l = arr.length - 1; l >= 0; l--) {
          const hit = arr[l];
          const expiresAt = hit.e || 0;
          if (expiresAt === 0)
            this.set(hit.k, hit.v);
          else {
            const maxAge = expiresAt - now;
            if (maxAge > 0) {
              this.set(hit.k, hit.v, maxAge);
            }
          }
        }
      }
      prune() {
        this[CACHE].forEach((value, key) => get2(this, key, false));
      }
    };
    var get2 = (self2, key, doUse) => {
      const node = self2[CACHE].get(key);
      if (node) {
        const hit = node.value;
        if (isStale(self2, hit)) {
          del(self2, node);
          if (!self2[ALLOW_STALE])
            return void 0;
        } else {
          if (doUse) {
            if (self2[UPDATE_AGE_ON_GET])
              node.value.now = Date.now();
            self2[LRU_LIST].unshiftNode(node);
          }
        }
        return hit.value;
      }
    };
    var isStale = (self2, hit) => {
      if (!hit || !hit.maxAge && !self2[MAX_AGE])
        return false;
      const diff = Date.now() - hit.now;
      return hit.maxAge ? diff > hit.maxAge : self2[MAX_AGE] && diff > self2[MAX_AGE];
    };
    var trim = (self2) => {
      if (self2[LENGTH] > self2[MAX]) {
        for (let walker = self2[LRU_LIST].tail; self2[LENGTH] > self2[MAX] && walker !== null; ) {
          const prev = walker.prev;
          del(self2, walker);
          walker = prev;
        }
      }
    };
    var del = (self2, node) => {
      if (node) {
        const hit = node.value;
        if (self2[DISPOSE])
          self2[DISPOSE](hit.key, hit.value);
        self2[LENGTH] -= hit.length;
        self2[CACHE].delete(hit.key);
        self2[LRU_LIST].removeNode(node);
      }
    };
    var Entry = class {
      constructor(key, value, length, now, maxAge) {
        this.key = key;
        this.value = value;
        this.length = length;
        this.now = now;
        this.maxAge = maxAge || 0;
      }
    };
    var forEachStep = (self2, fn, node, thisp) => {
      let hit = node.value;
      if (isStale(self2, hit)) {
        del(self2, node);
        if (!self2[ALLOW_STALE])
          hit = void 0;
      }
      if (hit)
        fn.call(thisp, hit.value, hit.key, self2);
    };
    module.exports = LRUCache2;
  }
});

// node_modules/ol/source/BingMaps.js
var __extends = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
function quadKey(tileCoord) {
  var z = tileCoord[0];
  var digits = new Array(z);
  var mask = 1 << z - 1;
  var i, charCode;
  for (i = 0; i < z; ++i) {
    charCode = 48;
    if (tileCoord[1] & mask) {
      charCode += 1;
    }
    if (tileCoord[2] & mask) {
      charCode += 2;
    }
    digits[i] = String.fromCharCode(charCode);
    mask >>= 1;
  }
  return digits.join("");
}
var TOS_ATTRIBUTION = '<a class="ol-attribution-bing-tos" href="https://www.microsoft.com/maps/product/terms.html" target="_blank">Terms of Use</a>';
var BingMaps = function(_super) {
  __extends(BingMaps2, _super);
  function BingMaps2(options) {
    var _this = this;
    var hidpi = options.hidpi !== void 0 ? options.hidpi : false;
    _this = _super.call(this, {
      cacheSize: options.cacheSize,
      crossOrigin: "anonymous",
      imageSmoothing: options.imageSmoothing,
      opaque: true,
      projection: get("EPSG:3857"),
      reprojectionErrorThreshold: options.reprojectionErrorThreshold,
      state: State_default.LOADING,
      tileLoadFunction: options.tileLoadFunction,
      tilePixelRatio: hidpi ? 2 : 1,
      wrapX: options.wrapX !== void 0 ? options.wrapX : true,
      transition: options.transition,
      zDirection: options.zDirection
    }) || this;
    _this.hidpi_ = hidpi;
    _this.culture_ = options.culture !== void 0 ? options.culture : "en-us";
    _this.maxZoom_ = options.maxZoom !== void 0 ? options.maxZoom : -1;
    _this.apiKey_ = options.key;
    _this.imagerySet_ = options.imagerySet;
    var url2 = "https://dev.virtualearth.net/REST/v1/Imagery/Metadata/" + _this.imagerySet_ + "?uriScheme=https&include=ImageryProviders&key=" + _this.apiKey_ + "&c=" + _this.culture_;
    jsonp(url2, _this.handleImageryMetadataResponse.bind(_this), void 0, "jsonp");
    return _this;
  }
  BingMaps2.prototype.getApiKey = function() {
    return this.apiKey_;
  };
  BingMaps2.prototype.getImagerySet = function() {
    return this.imagerySet_;
  };
  BingMaps2.prototype.handleImageryMetadataResponse = function(response) {
    if (response.statusCode != 200 || response.statusDescription != "OK" || response.authenticationResultCode != "ValidCredentials" || response.resourceSets.length != 1 || response.resourceSets[0].resources.length != 1) {
      this.setState(State_default.ERROR);
      return;
    }
    var resource = response.resourceSets[0].resources[0];
    var maxZoom = this.maxZoom_ == -1 ? resource.zoomMax : this.maxZoom_;
    var sourceProjection = this.getProjection();
    var extent = extentFromProjection(sourceProjection);
    var scale3 = this.hidpi_ ? 2 : 1;
    var tileSize = resource.imageWidth == resource.imageHeight ? resource.imageWidth / scale3 : [resource.imageWidth / scale3, resource.imageHeight / scale3];
    var tileGrid = createXYZ({
      extent,
      minZoom: resource.zoomMin,
      maxZoom,
      tileSize
    });
    this.tileGrid = tileGrid;
    var culture = this.culture_;
    var hidpi = this.hidpi_;
    this.tileUrlFunction = createFromTileUrlFunctions(resource.imageUrlSubdomains.map(function(subdomain) {
      var quadKeyTileCoord = [0, 0, 0];
      var imageUrl = resource.imageUrl.replace("{subdomain}", subdomain).replace("{culture}", culture);
      return function(tileCoord, pixelRatio, projection) {
        if (!tileCoord) {
          return void 0;
        } else {
          createOrUpdate(tileCoord[0], tileCoord[1], tileCoord[2], quadKeyTileCoord);
          var url2 = imageUrl;
          if (hidpi) {
            url2 += "&dpi=d1&device=mobile";
          }
          return url2.replace("{quadkey}", quadKey(quadKeyTileCoord));
        }
      };
    }));
    if (resource.imageryProviders) {
      var transform_1 = getTransformFromProjections(get("EPSG:4326"), this.getProjection());
      this.setAttributions(function(frameState) {
        var attributions = [];
        var viewState = frameState.viewState;
        var tileGrid2 = this.getTileGrid();
        var z = tileGrid2.getZForResolution(viewState.resolution, this.zDirection);
        var tileCoord = tileGrid2.getTileCoordForCoordAndZ(viewState.center, z);
        var zoom = tileCoord[0];
        resource.imageryProviders.map(function(imageryProvider) {
          var intersecting = false;
          var coverageAreas = imageryProvider.coverageAreas;
          for (var i = 0, ii = coverageAreas.length; i < ii; ++i) {
            var coverageArea = coverageAreas[i];
            if (zoom >= coverageArea.zoomMin && zoom <= coverageArea.zoomMax) {
              var bbox = coverageArea.bbox;
              var epsg4326Extent = [bbox[1], bbox[0], bbox[3], bbox[2]];
              var extent_1 = applyTransform(epsg4326Extent, transform_1);
              if (intersects(extent_1, frameState.extent)) {
                intersecting = true;
                break;
              }
            }
          }
          if (intersecting) {
            attributions.push(imageryProvider.attribution);
          }
        });
        attributions.push(TOS_ATTRIBUTION);
        return attributions;
      }.bind(this));
    }
    this.setState(State_default.READY);
  };
  return BingMaps2;
}(TileImage_default);
var BingMaps_default = BingMaps;

// node_modules/ol/source/CartoDB.js
var __extends2 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var CartoDB = function(_super) {
  __extends2(CartoDB2, _super);
  function CartoDB2(options) {
    var _this = _super.call(this, {
      attributions: options.attributions,
      cacheSize: options.cacheSize,
      crossOrigin: options.crossOrigin,
      maxZoom: options.maxZoom !== void 0 ? options.maxZoom : 18,
      minZoom: options.minZoom,
      projection: options.projection,
      transition: options.transition,
      wrapX: options.wrapX,
      zDirection: options.zDirection
    }) || this;
    _this.account_ = options.account;
    _this.mapId_ = options.map || "";
    _this.config_ = options.config || {};
    _this.templateCache_ = {};
    _this.initializeMap_();
    return _this;
  }
  CartoDB2.prototype.getConfig = function() {
    return this.config_;
  };
  CartoDB2.prototype.updateConfig = function(config) {
    assign(this.config_, config);
    this.initializeMap_();
  };
  CartoDB2.prototype.setConfig = function(config) {
    this.config_ = config || {};
    this.initializeMap_();
  };
  CartoDB2.prototype.initializeMap_ = function() {
    var paramHash = JSON.stringify(this.config_);
    if (this.templateCache_[paramHash]) {
      this.applyTemplate_(this.templateCache_[paramHash]);
      return;
    }
    var mapUrl = "https://" + this.account_ + ".carto.com/api/v1/map";
    if (this.mapId_) {
      mapUrl += "/named/" + this.mapId_;
    }
    var client = new XMLHttpRequest();
    client.addEventListener("load", this.handleInitResponse_.bind(this, paramHash));
    client.addEventListener("error", this.handleInitError_.bind(this));
    client.open("POST", mapUrl);
    client.setRequestHeader("Content-type", "application/json");
    client.send(JSON.stringify(this.config_));
  };
  CartoDB2.prototype.handleInitResponse_ = function(paramHash, event) {
    var client = event.target;
    if (!client.status || client.status >= 200 && client.status < 300) {
      var response = void 0;
      try {
        response = JSON.parse(client.responseText);
      } catch (err) {
        this.setState(State_default.ERROR);
        return;
      }
      this.applyTemplate_(response);
      this.templateCache_[paramHash] = response;
      this.setState(State_default.READY);
    } else {
      this.setState(State_default.ERROR);
    }
  };
  CartoDB2.prototype.handleInitError_ = function(event) {
    this.setState(State_default.ERROR);
  };
  CartoDB2.prototype.applyTemplate_ = function(data) {
    var tilesUrl = "https://" + data.cdn_url.https + "/" + this.account_ + "/api/v1/map/" + data.layergroupid + "/{z}/{x}/{y}.png";
    this.setUrl(tilesUrl);
  };
  return CartoDB2;
}(XYZ_default);
var CartoDB_default = CartoDB;

// node_modules/ol/source/Cluster.js
var __extends3 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var Cluster = function(_super) {
  __extends3(Cluster2, _super);
  function Cluster2(options) {
    var _this = _super.call(this, {
      attributions: options.attributions,
      wrapX: options.wrapX
    }) || this;
    _this.resolution = void 0;
    _this.distance = options.distance !== void 0 ? options.distance : 20;
    _this.minDistance = options.minDistance || 0;
    _this.interpolationRatio = 0;
    _this.features = [];
    _this.geometryFunction = options.geometryFunction || function(feature) {
      var geometry = feature.getGeometry();
      assert(geometry.getType() == GeometryType_default.POINT, 10);
      return geometry;
    };
    _this.createCustomCluster_ = options.createCluster;
    _this.source = null;
    _this.boundRefresh_ = _this.refresh.bind(_this);
    _this.updateDistance(_this.distance, _this.minDistance);
    _this.setSource(options.source || null);
    return _this;
  }
  Cluster2.prototype.clear = function(opt_fast) {
    this.features.length = 0;
    _super.prototype.clear.call(this, opt_fast);
  };
  Cluster2.prototype.getDistance = function() {
    return this.distance;
  };
  Cluster2.prototype.getSource = function() {
    return this.source;
  };
  Cluster2.prototype.loadFeatures = function(extent, resolution, projection) {
    this.source.loadFeatures(extent, resolution, projection);
    if (resolution !== this.resolution) {
      this.resolution = resolution;
      this.refresh();
    }
  };
  Cluster2.prototype.setDistance = function(distance) {
    this.updateDistance(distance, this.minDistance);
  };
  Cluster2.prototype.setMinDistance = function(minDistance) {
    this.updateDistance(this.distance, minDistance);
  };
  Cluster2.prototype.getMinDistance = function() {
    return this.minDistance;
  };
  Cluster2.prototype.setSource = function(source2) {
    if (this.source) {
      this.source.removeEventListener(EventType_default.CHANGE, this.boundRefresh_);
    }
    this.source = source2;
    if (source2) {
      source2.addEventListener(EventType_default.CHANGE, this.boundRefresh_);
    }
    this.refresh();
  };
  Cluster2.prototype.refresh = function() {
    this.clear();
    this.cluster();
    this.addFeatures(this.features);
  };
  Cluster2.prototype.updateDistance = function(distance, minDistance) {
    var ratio = distance === 0 ? 0 : Math.min(minDistance, distance) / distance;
    var changed = distance !== this.distance || this.interpolationRatio !== ratio;
    this.distance = distance;
    this.minDistance = minDistance;
    this.interpolationRatio = ratio;
    if (changed) {
      this.refresh();
    }
  };
  Cluster2.prototype.cluster = function() {
    if (this.resolution === void 0 || !this.source) {
      return;
    }
    var extent = createEmpty();
    var mapDistance = this.distance * this.resolution;
    var features = this.source.getFeatures();
    var clustered = {};
    for (var i = 0, ii = features.length; i < ii; i++) {
      var feature = features[i];
      if (!(getUid(feature) in clustered)) {
        var geometry = this.geometryFunction(feature);
        if (geometry) {
          var coordinates = geometry.getCoordinates();
          createOrUpdateFromCoordinate(coordinates, extent);
          buffer(extent, mapDistance, extent);
          var neighbors = this.source.getFeaturesInExtent(extent).filter(function(neighbor) {
            var uid = getUid(neighbor);
            if (uid in clustered) {
              return false;
            }
            clustered[uid] = true;
            return true;
          });
          this.features.push(this.createCluster(neighbors, extent));
        }
      }
    }
  };
  Cluster2.prototype.createCluster = function(features, extent) {
    var centroid = [0, 0];
    for (var i = features.length - 1; i >= 0; --i) {
      var geometry_1 = this.geometryFunction(features[i]);
      if (geometry_1) {
        add(centroid, geometry_1.getCoordinates());
      } else {
        features.splice(i, 1);
      }
    }
    scale(centroid, 1 / features.length);
    var searchCenter = getCenter(extent);
    var ratio = this.interpolationRatio;
    var geometry = new Point_default([
      centroid[0] * (1 - ratio) + searchCenter[0] * ratio,
      centroid[1] * (1 - ratio) + searchCenter[1] * ratio
    ]);
    if (this.createCustomCluster_) {
      return this.createCustomCluster_(geometry, features);
    } else {
      return new Feature_default({
        geometry,
        features
      });
    }
  };
  return Cluster2;
}(Vector_default);
var Cluster_default = Cluster;

// node_modules/ol/DataTile.js
var __extends4 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var DataTile = function(_super) {
  __extends4(DataTile2, _super);
  function DataTile2(options) {
    var _this = this;
    var state = TileState_default.IDLE;
    _this = _super.call(this, options.tileCoord, state, { transition: options.transition }) || this;
    _this.loader_ = options.loader;
    _this.data_ = null;
    _this.error_ = null;
    return _this;
  }
  DataTile2.prototype.getData = function() {
    return this.data_;
  };
  DataTile2.prototype.getError = function() {
    return this.error_;
  };
  DataTile2.prototype.load = function() {
    this.state = TileState_default.LOADING;
    this.changed();
    var self2 = this;
    this.loader_().then(function(data) {
      self2.data_ = data;
      self2.state = TileState_default.LOADED;
      self2.changed();
    }).catch(function(error) {
      self2.error_ = error;
      self2.state = TileState_default.ERROR;
      self2.changed();
    });
  };
  return DataTile2;
}(Tile_default);
var DataTile_default = DataTile;

// node_modules/ol/source/DataTile.js
var __extends5 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var DataTileSource = function(_super) {
  __extends5(DataTileSource2, _super);
  function DataTileSource2(options) {
    var _this = this;
    var projection = options.projection === void 0 ? "EPSG:3857" : options.projection;
    var tileGrid = options.tileGrid;
    if (tileGrid === void 0 && projection) {
      tileGrid = createXYZ({
        extent: extentFromProjection(projection),
        maxResolution: options.maxResolution,
        maxZoom: options.maxZoom,
        minZoom: options.minZoom,
        tileSize: options.tileSize
      });
    }
    _this = _super.call(this, {
      cacheSize: 0.1,
      projection,
      tileGrid,
      opaque: options.opaque,
      state: options.state,
      tilePixelRatio: options.tilePixelRatio,
      wrapX: options.wrapX,
      transition: options.transition
    }) || this;
    _this.tileLoadingKeys_ = {};
    _this.loader_ = options.loader;
    _this.handleTileChange_ = _this.handleTileChange_.bind(_this);
    _this.bandCount = options.bandCount === void 0 ? 4 : options.bandCount;
    return _this;
  }
  DataTileSource2.prototype.setLoader = function(loader) {
    this.loader_ = loader;
  };
  DataTileSource2.prototype.getTile = function(z, x, y, pixelRatio, projection) {
    var tileCoordKey = getKeyZXY(z, x, y);
    if (this.tileCache.containsKey(tileCoordKey)) {
      return this.tileCache.get(tileCoordKey);
    }
    var sourceLoader = this.loader_;
    function loader() {
      return sourceLoader(z, x, y);
    }
    var tile = new DataTile_default(assign({ tileCoord: [z, x, y], loader }, this.tileOptions));
    tile.key = this.getKey();
    tile.addEventListener(EventType_default.CHANGE, this.handleTileChange_);
    this.tileCache.set(tileCoordKey, tile);
    return tile;
  };
  DataTileSource2.prototype.handleTileChange_ = function(event) {
    var tile = event.target;
    var uid = getUid(tile);
    var tileState = tile.getState();
    var type;
    if (tileState == TileState_default.LOADING) {
      this.tileLoadingKeys_[uid] = true;
      type = TileEventType_default.TILELOADSTART;
    } else if (uid in this.tileLoadingKeys_) {
      delete this.tileLoadingKeys_[uid];
      type = tileState == TileState_default.ERROR ? TileEventType_default.TILELOADERROR : tileState == TileState_default.LOADED ? TileEventType_default.TILELOADEND : void 0;
    }
    if (type) {
      this.dispatchEvent(new TileSourceEvent(type, tile));
    }
  };
  return DataTileSource2;
}(Tile_default2);
var DataTile_default2 = DataTileSource;

// node_modules/@petamoriken/float16/src/_converter.mjs
var buffer3 = new ArrayBuffer(4);
var floatView = new Float32Array(buffer3);
var uint32View = new Uint32Array(buffer3);
var baseTable = new Uint32Array(512);
var shiftTable = new Uint32Array(512);
for (let i = 0; i < 256; ++i) {
  const e = i - 127;
  if (e < -27) {
    baseTable[i] = 0;
    baseTable[i | 256] = 32768;
    shiftTable[i] = 24;
    shiftTable[i | 256] = 24;
  } else if (e < -14) {
    baseTable[i] = 1024 >> -e - 14;
    baseTable[i | 256] = 1024 >> -e - 14 | 32768;
    shiftTable[i] = -e - 1;
    shiftTable[i | 256] = -e - 1;
  } else if (e <= 15) {
    baseTable[i] = e + 15 << 10;
    baseTable[i | 256] = e + 15 << 10 | 32768;
    shiftTable[i] = 13;
    shiftTable[i | 256] = 13;
  } else if (e < 128) {
    baseTable[i] = 31744;
    baseTable[i | 256] = 64512;
    shiftTable[i] = 24;
    shiftTable[i | 256] = 24;
  } else {
    baseTable[i] = 31744;
    baseTable[i | 256] = 64512;
    shiftTable[i] = 13;
    shiftTable[i | 256] = 13;
  }
}
function roundToFloat16Bits(num) {
  floatView[0] = num;
  const f = uint32View[0];
  const e = f >> 23 & 511;
  return baseTable[e] + ((f & 8388607) >> shiftTable[e]);
}
var mantissaTable = new Uint32Array(2048);
var exponentTable = new Uint32Array(64);
var offsetTable = new Uint32Array(64);
mantissaTable[0] = 0;
for (let i = 1; i < 1024; ++i) {
  let m = i << 13;
  let e = 0;
  while ((m & 8388608) === 0) {
    e -= 8388608;
    m <<= 1;
  }
  m &= ~8388608;
  e += 947912704;
  mantissaTable[i] = m | e;
}
for (let i = 1024; i < 2048; ++i) {
  mantissaTable[i] = 939524096 + (i - 1024 << 13);
}
exponentTable[0] = 0;
for (let i = 1; i < 31; ++i) {
  exponentTable[i] = i << 23;
}
exponentTable[31] = 1199570944;
exponentTable[32] = 2147483648;
for (let i = 33; i < 63; ++i) {
  exponentTable[i] = 2147483648 + (i - 32 << 23);
}
exponentTable[63] = 3347054592;
offsetTable[0] = 0;
for (let i = 1; i < 64; ++i) {
  if (i === 32) {
    offsetTable[i] = 0;
  } else {
    offsetTable[i] = 1024;
  }
}
function convertToNumber(float16bits) {
  const m = float16bits >> 10;
  uint32View[0] = mantissaTable[offsetTable[m] + (float16bits & 1023)] + exponentTable[m];
  return floatView[0];
}

// node_modules/@petamoriken/float16/src/_util/private.mjs
function createPrivateStorage() {
  const wm = new WeakMap();
  return (self2) => {
    const storage = wm.get(self2);
    if (storage !== void 0) {
      return storage;
    }
    const obj = Object.create(null);
    wm.set(self2, obj);
    return obj;
  };
}

// node_modules/@petamoriken/float16/src/_arrayIterator.mjs
var _ = createPrivateStorage();
var IteratorPrototype = Reflect.getPrototypeOf(Reflect.getPrototypeOf([][Symbol.iterator]()));
var ArrayIteratorPrototype = Object.create(IteratorPrototype, {
  next: {
    value: function next() {
      return _(this).iterator.next();
    },
    writable: true,
    configurable: true
  },
  [Symbol.toStringTag]: {
    value: "Array Iterator",
    configurable: true
  }
});
function wrapInArrayIterator(iterator) {
  const arrayIterator = Object.create(ArrayIteratorPrototype);
  _(arrayIterator).iterator = iterator;
  return arrayIterator;
}

// node_modules/@petamoriken/float16/src/_util/is.mjs
function isObject(value) {
  return value !== null && typeof value === "object" || typeof value === "function";
}
function isObjectLike(value) {
  return value !== null && typeof value === "object";
}
var getTypedArrayPrototypeSymbolToStringTag = Reflect.getOwnPropertyDescriptor(Reflect.getPrototypeOf(Uint8Array).prototype, Symbol.toStringTag).get;
function isTypedArray(value) {
  return getTypedArrayPrototypeSymbolToStringTag.call(value) !== void 0;
}
function isUint16Array(value) {
  return getTypedArrayPrototypeSymbolToStringTag.call(value) === "Uint16Array";
}
function isDataView(value) {
  if (!ArrayBuffer.isView(value)) {
    return false;
  }
  if (isTypedArray(value)) {
    return false;
  }
  return true;
}
function isArrayBuffer(value) {
  return isObjectLike(value) && value[Symbol.toStringTag] === "ArrayBuffer";
}
function isSharedArrayBuffer(value) {
  return isObjectLike(value) && value[Symbol.toStringTag] === "SharedArrayBuffer";
}
function isIterable(value) {
  return isObject(value) && typeof value[Symbol.iterator] === "function";
}
function isOrdinaryArray(value) {
  if (!Array.isArray(value)) {
    return false;
  }
  const iterator = value[Symbol.iterator]();
  if (iterator[Symbol.toStringTag] !== "Array Iterator") {
    return false;
  }
  return true;
}
function isOrdinaryTypedArray(value) {
  if (!isTypedArray(value)) {
    return false;
  }
  const iterator = value[Symbol.iterator]();
  if (iterator[Symbol.toStringTag] !== "Array Iterator") {
    return false;
  }
  return true;
}
function isCanonicalIntegerIndexString(value) {
  if (typeof value !== "string") {
    return false;
  }
  const number = Number(value);
  if (value !== number + "") {
    return false;
  }
  if (!Number.isFinite(number)) {
    return false;
  }
  if (number !== Math.trunc(number)) {
    return false;
  }
  return true;
}

// node_modules/@petamoriken/float16/src/_spec.mjs
function ToIntegerOrInfinity(target) {
  if (typeof target === "bigint") {
    throw TypeError("Cannot convert a BigInt value to a number");
  }
  const number = Number(target);
  if (Number.isNaN(number) || number === 0) {
    return 0;
  }
  return Math.trunc(number);
}
function ToLength(target) {
  const length = ToIntegerOrInfinity(target);
  if (length < 0) {
    return 0;
  }
  return length < Number.MAX_SAFE_INTEGER ? length : Number.MAX_SAFE_INTEGER;
}
function LengthOfArrayLike(arrayLike) {
  if (!isObject(arrayLike)) {
    throw TypeError("this is not a object");
  }
  return ToLength(arrayLike.length);
}
function SpeciesConstructor(target, defaultConstructor) {
  if (!isObject(target)) {
    throw TypeError("this is not a object");
  }
  const constructor = target.constructor;
  if (constructor === void 0) {
    return defaultConstructor;
  }
  if (!isObject(constructor)) {
    throw TypeError("constructor is not a object");
  }
  const species = constructor[Symbol.species];
  if (species == null) {
    return defaultConstructor;
  }
  return species;
}
function defaultCompare(x, y) {
  const isNaN_x = Number.isNaN(x);
  const isNaN_y = Number.isNaN(y);
  if (isNaN_x && isNaN_y) {
    return 0;
  }
  if (isNaN_x) {
    return 1;
  }
  if (isNaN_y) {
    return -1;
  }
  if (x < y) {
    return -1;
  }
  if (x > y) {
    return 1;
  }
  if (x === 0 && y === 0) {
    const isPlusZero_x = Object.is(x, 0);
    const isPlusZero_y = Object.is(y, 0);
    if (!isPlusZero_x && isPlusZero_y) {
      return -1;
    }
    if (isPlusZero_x && !isPlusZero_y) {
      return 1;
    }
  }
  return 0;
}

// node_modules/@petamoriken/float16/src/_util/hasOwn.mjs
var hasOwnProperty = Object.prototype.hasOwnProperty;
var hasOwn = Object.hasOwn || function hasOwn2(object, key) {
  return hasOwnProperty.call(object, key);
};

// node_modules/@petamoriken/float16/src/Float16Array.mjs
var brand = Symbol.for("__Float16Array__");
var _2 = createPrivateStorage();
function hasFloat16ArrayBrand(target) {
  if (!isObjectLike(target)) {
    return false;
  }
  const prototype = Reflect.getPrototypeOf(target);
  if (!isObjectLike(prototype)) {
    return false;
  }
  const constructor = prototype.constructor;
  if (constructor === void 0) {
    return false;
  }
  if (!isObject(constructor)) {
    throw TypeError("constructor is not a object");
  }
  return Reflect.has(constructor, brand);
}
function isFloat16Array(target) {
  return hasFloat16ArrayBrand(target) && !isTypedArray(target);
}
function isFloat16BitsArray(target) {
  return hasFloat16ArrayBrand(target) && isUint16Array(target);
}
function assertFloat16BitsArray(target) {
  if (!isFloat16BitsArray(target)) {
    throw new TypeError("This is not a Float16Array");
  }
}
function getFloat16BitsArrayFromFloat16Array(float16) {
  let target = _2(float16).target;
  if (target === void 0) {
    const clone = new Float16Array(float16.buffer, float16.byteOffset, float16.length);
    target = _2(clone).target;
  }
  return target;
}
function copyToArray(float16bitsArray) {
  const length = float16bitsArray.length;
  const array = [];
  for (let i = 0; i < length; ++i) {
    array[i] = convertToNumber(float16bitsArray[i]);
  }
  return array;
}
var defaultFloat16ArrayMethods = new WeakSet();
function isDefaultFloat16ArrayMethods(target) {
  return typeof target === "function" && defaultFloat16ArrayMethods.has(target);
}
var applyHandler = Object.freeze({
  apply(func, thisArg, args) {
    if (isFloat16Array(thisArg)) {
      const target = getFloat16BitsArrayFromFloat16Array(thisArg);
      return Reflect.apply(func, target, args);
    }
    return Reflect.apply(func, thisArg, args);
  }
});
var handler = Object.freeze({
  get(target, key) {
    if (isCanonicalIntegerIndexString(key) && hasOwn(target, key)) {
      return convertToNumber(Reflect.get(target, key));
    }
    const ret = Reflect.get(target, key);
    if (!isDefaultFloat16ArrayMethods(ret)) {
      return ret;
    }
    let proxy = _2(ret).proxy;
    if (proxy === void 0) {
      proxy = _2(ret).proxy = new Proxy(ret, applyHandler);
    }
    return proxy;
  },
  set(target, key, value) {
    if (isCanonicalIntegerIndexString(key) && hasOwn(target, key)) {
      return Reflect.set(target, key, roundToFloat16Bits(value));
    }
    return Reflect.set(target, key, value);
  }
});
var Float16Array = class extends Uint16Array {
  constructor(input, byteOffset, length) {
    if (isFloat16Array(input)) {
      const float16bitsArray = getFloat16BitsArrayFromFloat16Array(input);
      super(float16bitsArray);
    } else if (isObject(input) && !isArrayBuffer(input)) {
      let list;
      let length2;
      if (isTypedArray(input)) {
        list = input;
        length2 = input.length;
        const buffer4 = input.buffer;
        const BufferConstructor = !isSharedArrayBuffer(buffer4) ? SpeciesConstructor(buffer4, ArrayBuffer) : ArrayBuffer;
        const data = new BufferConstructor(length2 * Float16Array.BYTES_PER_ELEMENT);
        super(data);
      } else if (isIterable(input)) {
        if (isOrdinaryArray(input)) {
          list = input;
          length2 = input.length;
          super(length2);
        } else {
          list = [...input];
          length2 = list.length;
          super(length2);
        }
      } else {
        list = input;
        length2 = LengthOfArrayLike(input);
        super(length2);
      }
      for (let i = 0; i < length2; ++i) {
        this[i] = roundToFloat16Bits(list[i]);
      }
    } else {
      switch (arguments.length) {
        case 0:
          super();
          break;
        case 1:
          super(input);
          break;
        case 2:
          super(input, byteOffset);
          break;
        case 3:
          super(input, byteOffset, length);
          break;
        default:
          super(...arguments);
      }
    }
    const proxy = new Proxy(this, handler);
    _2(proxy).target = this;
    _2(this).proxy = proxy;
    return proxy;
  }
  static from(src, ...opts) {
    const Constructor = this;
    if (!Reflect.has(Constructor, brand)) {
      throw TypeError("This constructor is not a subclass of Float16Array");
    }
    if (Constructor === Float16Array) {
      if (isFloat16Array(src) && opts.length === 0) {
        const uint16 = new Uint16Array(src.buffer, src.byteOffset, src.length);
        return new Float16Array(uint16.slice().buffer);
      }
      if (opts.length === 0) {
        return new Float16Array(Uint16Array.from(src, roundToFloat16Bits).buffer);
      }
      const mapFunc = opts[0];
      const thisArg = opts[1];
      return new Float16Array(Uint16Array.from(src, function(val, ...args) {
        return roundToFloat16Bits(mapFunc.call(this, val, ...args));
      }, thisArg).buffer);
    }
    let list;
    let length;
    if (isIterable(src)) {
      if (isOrdinaryArray(src) || isOrdinaryTypedArray(src)) {
        list = src;
        length = src.length;
      } else {
        list = [...src];
        length = list.length;
      }
    } else {
      list = src;
      length = LengthOfArrayLike(src);
    }
    const array = new Constructor(length);
    if (opts.length === 0) {
      for (let i = 0; i < length; ++i) {
        array[i] = list[i];
      }
    } else {
      const mapFunc = opts[0];
      const thisArg = opts[1];
      for (let i = 0; i < length; ++i) {
        array[i] = mapFunc.call(thisArg, list[i], i);
      }
    }
    return array;
  }
  static of(...items) {
    const Constructor = this;
    if (!Reflect.has(Constructor, brand)) {
      throw TypeError("This constructor is not a subclass of Float16Array");
    }
    const length = items.length;
    if (Constructor === Float16Array) {
      const proxy = new Float16Array(length);
      const float16bitsArray = getFloat16BitsArrayFromFloat16Array(proxy);
      for (let i = 0; i < length; ++i) {
        float16bitsArray[i] = roundToFloat16Bits(items[i]);
      }
      return proxy;
    }
    const array = new Constructor(length);
    for (let i = 0; i < length; ++i) {
      array[i] = items[i];
    }
    return array;
  }
  keys() {
    assertFloat16BitsArray(this);
    return super.keys();
  }
  values() {
    assertFloat16BitsArray(this);
    const arrayIterator = super.values();
    return wrapInArrayIterator(function* () {
      for (const val of arrayIterator) {
        yield convertToNumber(val);
      }
    }());
  }
  entries() {
    assertFloat16BitsArray(this);
    const arrayIterator = super.entries();
    return wrapInArrayIterator(function* () {
      for (const [i, val] of arrayIterator) {
        yield [i, convertToNumber(val)];
      }
    }());
  }
  at(index) {
    assertFloat16BitsArray(this);
    const length = this.length;
    const relativeIndex = ToIntegerOrInfinity(index);
    const k = relativeIndex >= 0 ? relativeIndex : length + relativeIndex;
    if (k < 0 || k >= length) {
      return;
    }
    return convertToNumber(this[k]);
  }
  map(callback, ...opts) {
    assertFloat16BitsArray(this);
    const length = this.length;
    const thisArg = opts[0];
    const Constructor = SpeciesConstructor(this, Float16Array);
    if (Constructor === Float16Array) {
      const proxy = new Float16Array(length);
      const float16bitsArray = getFloat16BitsArrayFromFloat16Array(proxy);
      for (let i = 0; i < length; ++i) {
        const val = convertToNumber(this[i]);
        float16bitsArray[i] = roundToFloat16Bits(callback.call(thisArg, val, i, _2(this).proxy));
      }
      return proxy;
    }
    const array = new Constructor(length);
    for (let i = 0; i < length; ++i) {
      const val = convertToNumber(this[i]);
      array[i] = callback.call(thisArg, val, i, _2(this).proxy);
    }
    return array;
  }
  filter(callback, ...opts) {
    assertFloat16BitsArray(this);
    const length = this.length;
    const thisArg = opts[0];
    const kept = [];
    for (let i = 0; i < length; ++i) {
      const val = convertToNumber(this[i]);
      if (callback.call(thisArg, val, i, _2(this).proxy)) {
        kept.push(val);
      }
    }
    const Constructor = SpeciesConstructor(this, Float16Array);
    const array = new Constructor(kept);
    return array;
  }
  reduce(callback, ...opts) {
    assertFloat16BitsArray(this);
    const length = this.length;
    if (length === 0 && opts.length === 0) {
      throw TypeError("Reduce of empty array with no initial value");
    }
    let accumulator, start;
    if (opts.length === 0) {
      accumulator = convertToNumber(this[0]);
      start = 1;
    } else {
      accumulator = opts[0];
      start = 0;
    }
    for (let i = start; i < length; ++i) {
      accumulator = callback(accumulator, convertToNumber(this[i]), i, _2(this).proxy);
    }
    return accumulator;
  }
  reduceRight(callback, ...opts) {
    assertFloat16BitsArray(this);
    const length = this.length;
    if (length === 0 && opts.length === 0) {
      throw TypeError("Reduce of empty array with no initial value");
    }
    let accumulator, start;
    if (opts.length === 0) {
      accumulator = convertToNumber(this[length - 1]);
      start = length - 2;
    } else {
      accumulator = opts[0];
      start = length - 1;
    }
    for (let i = start; i >= 0; --i) {
      accumulator = callback(accumulator, convertToNumber(this[i]), i, _2(this).proxy);
    }
    return accumulator;
  }
  forEach(callback, ...opts) {
    assertFloat16BitsArray(this);
    const length = this.length;
    const thisArg = opts[0];
    for (let i = 0; i < length; ++i) {
      callback.call(thisArg, convertToNumber(this[i]), i, _2(this).proxy);
    }
  }
  find(callback, ...opts) {
    assertFloat16BitsArray(this);
    const length = this.length;
    const thisArg = opts[0];
    for (let i = 0; i < length; ++i) {
      const value = convertToNumber(this[i]);
      if (callback.call(thisArg, value, i, _2(this).proxy)) {
        return value;
      }
    }
  }
  findIndex(callback, ...opts) {
    assertFloat16BitsArray(this);
    const length = this.length;
    const thisArg = opts[0];
    for (let i = 0; i < length; ++i) {
      const value = convertToNumber(this[i]);
      if (callback.call(thisArg, value, i, _2(this).proxy)) {
        return i;
      }
    }
    return -1;
  }
  findLast(callback, ...opts) {
    assertFloat16BitsArray(this);
    const length = this.length;
    const thisArg = opts[0];
    for (let i = length - 1; i >= 0; --i) {
      const value = convertToNumber(this[i]);
      if (callback.call(thisArg, value, i, _2(this).proxy)) {
        return value;
      }
    }
  }
  findLastIndex(callback, ...opts) {
    assertFloat16BitsArray(this);
    const length = this.length;
    const thisArg = opts[0];
    for (let i = length - 1; i >= 0; --i) {
      const value = convertToNumber(this[i]);
      if (callback.call(thisArg, value, i, _2(this).proxy)) {
        return i;
      }
    }
    return -1;
  }
  every(callback, ...opts) {
    assertFloat16BitsArray(this);
    const length = this.length;
    const thisArg = opts[0];
    for (let i = 0; i < length; ++i) {
      if (!callback.call(thisArg, convertToNumber(this[i]), i, _2(this).proxy)) {
        return false;
      }
    }
    return true;
  }
  some(callback, ...opts) {
    assertFloat16BitsArray(this);
    const length = this.length;
    const thisArg = opts[0];
    for (let i = 0; i < length; ++i) {
      if (callback.call(thisArg, convertToNumber(this[i]), i, _2(this).proxy)) {
        return true;
      }
    }
    return false;
  }
  set(input, ...opts) {
    assertFloat16BitsArray(this);
    const targetOffset = ToIntegerOrInfinity(opts[0]);
    if (targetOffset < 0) {
      throw RangeError("offset is out of bounds");
    }
    if (isFloat16Array(input)) {
      const float16bitsArray = getFloat16BitsArrayFromFloat16Array(input);
      super.set(float16bitsArray, targetOffset);
      return;
    }
    const targetLength = this.length;
    const src = Object(input);
    const srcLength = LengthOfArrayLike(src);
    if (targetOffset === Infinity || srcLength + targetOffset > targetLength) {
      throw RangeError("offset is out of bounds");
    }
    for (let i = 0; i < srcLength; ++i) {
      this[i + targetOffset] = roundToFloat16Bits(src[i]);
    }
  }
  reverse() {
    assertFloat16BitsArray(this);
    super.reverse();
    return _2(this).proxy;
  }
  fill(value, ...opts) {
    assertFloat16BitsArray(this);
    super.fill(roundToFloat16Bits(value), ...opts);
    return _2(this).proxy;
  }
  copyWithin(target, start, ...opts) {
    assertFloat16BitsArray(this);
    super.copyWithin(target, start, ...opts);
    return _2(this).proxy;
  }
  sort(...opts) {
    assertFloat16BitsArray(this);
    const compare = opts[0] !== void 0 ? opts[0] : defaultCompare;
    super.sort((x, y) => {
      return compare(convertToNumber(x), convertToNumber(y));
    });
    return _2(this).proxy;
  }
  slice(...opts) {
    assertFloat16BitsArray(this);
    const Constructor = SpeciesConstructor(this, Float16Array);
    if (Constructor === Float16Array) {
      const uint16 = new Uint16Array(this.buffer, this.byteOffset, this.length);
      const float16bitsArray = uint16.slice(...opts);
      return new Float16Array(float16bitsArray.buffer);
    }
    const length = this.length;
    const start = ToIntegerOrInfinity(opts[0]);
    const end = opts[1] === void 0 ? length : ToIntegerOrInfinity(opts[1]);
    let k;
    if (start === -Infinity) {
      k = 0;
    } else if (start < 0) {
      k = length + start > 0 ? length + start : 0;
    } else {
      k = length < start ? length : start;
    }
    let final;
    if (end === -Infinity) {
      final = 0;
    } else if (end < 0) {
      final = length + end > 0 ? length + end : 0;
    } else {
      final = length < end ? length : end;
    }
    const count = final - k > 0 ? final - k : 0;
    const array = new Constructor(count);
    if (count === 0) {
      return array;
    }
    let n = 0;
    while (k < final) {
      array[n] = convertToNumber(this[k]);
      ++k;
      ++n;
    }
    return array;
  }
  subarray(...opts) {
    assertFloat16BitsArray(this);
    const uint16 = new Uint16Array(this.buffer, this.byteOffset, this.length);
    const float16bitsArray = uint16.subarray(...opts);
    const Constructor = SpeciesConstructor(this, Float16Array);
    const array = new Constructor(float16bitsArray.buffer, float16bitsArray.byteOffset, float16bitsArray.length);
    return array;
  }
  indexOf(element, ...opts) {
    assertFloat16BitsArray(this);
    const length = this.length;
    let from = ToIntegerOrInfinity(opts[0]);
    if (from === Infinity) {
      return -1;
    }
    if (from < 0) {
      from += length;
      if (from < 0) {
        from = 0;
      }
    }
    for (let i = from; i < length; ++i) {
      if (hasOwn(this, i) && convertToNumber(this[i]) === element) {
        return i;
      }
    }
    return -1;
  }
  lastIndexOf(element, ...opts) {
    assertFloat16BitsArray(this);
    const length = this.length;
    let from = opts.length >= 1 ? ToIntegerOrInfinity(opts[0]) : length - 1;
    if (from === -Infinity) {
      return -1;
    }
    if (from >= 0) {
      from = from < length - 1 ? from : length - 1;
    } else {
      from += length;
    }
    for (let i = from; i >= 0; --i) {
      if (hasOwn(this, i) && convertToNumber(this[i]) === element) {
        return i;
      }
    }
    return -1;
  }
  includes(element, ...opts) {
    assertFloat16BitsArray(this);
    const length = this.length;
    let from = ToIntegerOrInfinity(opts[0]);
    if (from === Infinity) {
      return false;
    }
    if (from < 0) {
      from += length;
      if (from < 0) {
        from = 0;
      }
    }
    const isNaN2 = Number.isNaN(element);
    for (let i = from; i < length; ++i) {
      const value = convertToNumber(this[i]);
      if (isNaN2 && Number.isNaN(value)) {
        return true;
      }
      if (value === element) {
        return true;
      }
    }
    return false;
  }
  join(...opts) {
    assertFloat16BitsArray(this);
    const array = copyToArray(this);
    return array.join(...opts);
  }
  toLocaleString(...opts) {
    assertFloat16BitsArray(this);
    const array = copyToArray(this);
    return array.toLocaleString(...opts);
  }
  get [Symbol.toStringTag]() {
    if (isFloat16BitsArray(this)) {
      return "Float16Array";
    }
  }
};
Object.defineProperty(Float16Array, "BYTES_PER_ELEMENT", { value: Uint16Array.BYTES_PER_ELEMENT });
Object.defineProperty(Float16Array, brand, {});
var Float16ArrayPrototype = Float16Array.prototype;
Object.defineProperty(Float16ArrayPrototype, Symbol.iterator, {
  value: Float16ArrayPrototype.values,
  writable: true,
  configurable: true
});
for (const key of Reflect.ownKeys(Float16ArrayPrototype)) {
  if (key === "constructor") {
    continue;
  }
  const val = Float16ArrayPrototype[key];
  if (typeof val === "function") {
    defaultFloat16ArrayMethods.add(val);
  }
}

// node_modules/@petamoriken/float16/src/DataView.mjs
function getFloat16(dataView, byteOffset, ...opts) {
  if (!isDataView(dataView)) {
    throw new TypeError("First argument to getFloat16 function must be a DataView");
  }
  return convertToNumber(dataView.getUint16(byteOffset, ...opts));
}

// node_modules/geotiff/src/geotiffimage.js
var import_get_attribute = __toModule(require_get_attribute());
var import_find_tags_by_name = __toModule(require_find_tags_by_name());

// node_modules/geotiff/src/rgb.js
function fromWhiteIsZero(raster, max) {
  const { width, height } = raster;
  const rgbRaster = new Uint8Array(width * height * 3);
  let value;
  for (let i = 0, j = 0; i < raster.length; ++i, j += 3) {
    value = 256 - raster[i] / max * 256;
    rgbRaster[j] = value;
    rgbRaster[j + 1] = value;
    rgbRaster[j + 2] = value;
  }
  return rgbRaster;
}
function fromBlackIsZero(raster, max) {
  const { width, height } = raster;
  const rgbRaster = new Uint8Array(width * height * 3);
  let value;
  for (let i = 0, j = 0; i < raster.length; ++i, j += 3) {
    value = raster[i] / max * 256;
    rgbRaster[j] = value;
    rgbRaster[j + 1] = value;
    rgbRaster[j + 2] = value;
  }
  return rgbRaster;
}
function fromPalette(raster, colorMap) {
  const { width, height } = raster;
  const rgbRaster = new Uint8Array(width * height * 3);
  const greenOffset = colorMap.length / 3;
  const blueOffset = colorMap.length / 3 * 2;
  for (let i = 0, j = 0; i < raster.length; ++i, j += 3) {
    const mapIndex = raster[i];
    rgbRaster[j] = colorMap[mapIndex] / 65536 * 256;
    rgbRaster[j + 1] = colorMap[mapIndex + greenOffset] / 65536 * 256;
    rgbRaster[j + 2] = colorMap[mapIndex + blueOffset] / 65536 * 256;
  }
  return rgbRaster;
}
function fromCMYK(cmykRaster) {
  const { width, height } = cmykRaster;
  const rgbRaster = new Uint8Array(width * height * 3);
  for (let i = 0, j = 0; i < cmykRaster.length; i += 4, j += 3) {
    const c = cmykRaster[i];
    const m = cmykRaster[i + 1];
    const y = cmykRaster[i + 2];
    const k = cmykRaster[i + 3];
    rgbRaster[j] = 255 * ((255 - c) / 256) * ((255 - k) / 256);
    rgbRaster[j + 1] = 255 * ((255 - m) / 256) * ((255 - k) / 256);
    rgbRaster[j + 2] = 255 * ((255 - y) / 256) * ((255 - k) / 256);
  }
  return rgbRaster;
}
function fromYCbCr(yCbCrRaster) {
  const { width, height } = yCbCrRaster;
  const rgbRaster = new Uint8ClampedArray(width * height * 3);
  for (let i = 0, j = 0; i < yCbCrRaster.length; i += 3, j += 3) {
    const y = yCbCrRaster[i];
    const cb = yCbCrRaster[i + 1];
    const cr = yCbCrRaster[i + 2];
    rgbRaster[j] = y + 1.402 * (cr - 128);
    rgbRaster[j + 1] = y - 0.34414 * (cb - 128) - 0.71414 * (cr - 128);
    rgbRaster[j + 2] = y + 1.772 * (cb - 128);
  }
  return rgbRaster;
}
var Xn = 0.95047;
var Yn = 1;
var Zn = 1.08883;
function fromCIELab(cieLabRaster) {
  const { width, height } = cieLabRaster;
  const rgbRaster = new Uint8Array(width * height * 3);
  for (let i = 0, j = 0; i < cieLabRaster.length; i += 3, j += 3) {
    const L = cieLabRaster[i + 0];
    const a_ = cieLabRaster[i + 1] << 24 >> 24;
    const b_ = cieLabRaster[i + 2] << 24 >> 24;
    let y = (L + 16) / 116;
    let x = a_ / 500 + y;
    let z = y - b_ / 200;
    let r;
    let g;
    let b;
    x = Xn * (x * x * x > 8856e-6 ? x * x * x : (x - 16 / 116) / 7.787);
    y = Yn * (y * y * y > 8856e-6 ? y * y * y : (y - 16 / 116) / 7.787);
    z = Zn * (z * z * z > 8856e-6 ? z * z * z : (z - 16 / 116) / 7.787);
    r = x * 3.2406 + y * -1.5372 + z * -0.4986;
    g = x * -0.9689 + y * 1.8758 + z * 0.0415;
    b = x * 0.0557 + y * -0.204 + z * 1.057;
    r = r > 31308e-7 ? 1.055 * r ** (1 / 2.4) - 0.055 : 12.92 * r;
    g = g > 31308e-7 ? 1.055 * g ** (1 / 2.4) - 0.055 : 12.92 * g;
    b = b > 31308e-7 ? 1.055 * b ** (1 / 2.4) - 0.055 : 12.92 * b;
    rgbRaster[j] = Math.max(0, Math.min(1, r)) * 255;
    rgbRaster[j + 1] = Math.max(0, Math.min(1, g)) * 255;
    rgbRaster[j + 2] = Math.max(0, Math.min(1, b)) * 255;
  }
  return rgbRaster;
}

// node_modules/geotiff/src/compression/index.js
var registry = new Map();
function addDecoder(cases, importFn) {
  if (!Array.isArray(cases)) {
    cases = [cases];
  }
  cases.forEach((c) => registry.set(c, importFn));
}
async function getDecoder(fileDirectory) {
  const importFn = registry.get(fileDirectory.Compression);
  if (!importFn) {
    throw new Error(`Unknown compression method identifier: ${fileDirectory.Compression}`);
  }
  const Decoder = await importFn();
  return new Decoder(fileDirectory);
}
addDecoder([void 0, 1], () => import("./raw-O62N53SE.js").then((m) => m.default));
addDecoder(5, () => import("./lzw-NFUAVRNZ.js").then((m) => m.default));
addDecoder(6, () => {
  throw new Error("old style JPEG compression is not supported.");
});
addDecoder(7, () => import("./jpeg-4A3YBYHQ.js").then((m) => m.default));
addDecoder([8, 32946], () => import("./deflate-I52DFMIE.js").then((m) => m.default));
addDecoder(32773, () => import("./packbits-G3KMKSSP.js").then((m) => m.default));
addDecoder(34887, () => import("./lerc-3FPMU3ME.js").then((m) => m.default));

// node_modules/geotiff/src/resample.js
function copyNewSize(array, width, height, samplesPerPixel = 1) {
  return new (Object.getPrototypeOf(array)).constructor(width * height * samplesPerPixel);
}
function resampleNearest(valueArrays, inWidth, inHeight, outWidth, outHeight) {
  const relX = inWidth / outWidth;
  const relY = inHeight / outHeight;
  return valueArrays.map((array) => {
    const newArray = copyNewSize(array, outWidth, outHeight);
    for (let y = 0; y < outHeight; ++y) {
      const cy = Math.min(Math.round(relY * y), inHeight - 1);
      for (let x = 0; x < outWidth; ++x) {
        const cx = Math.min(Math.round(relX * x), inWidth - 1);
        const value = array[cy * inWidth + cx];
        newArray[y * outWidth + x] = value;
      }
    }
    return newArray;
  });
}
function lerp(v0, v1, t) {
  return (1 - t) * v0 + t * v1;
}
function resampleBilinear(valueArrays, inWidth, inHeight, outWidth, outHeight) {
  const relX = inWidth / outWidth;
  const relY = inHeight / outHeight;
  return valueArrays.map((array) => {
    const newArray = copyNewSize(array, outWidth, outHeight);
    for (let y = 0; y < outHeight; ++y) {
      const rawY = relY * y;
      const yl = Math.floor(rawY);
      const yh = Math.min(Math.ceil(rawY), inHeight - 1);
      for (let x = 0; x < outWidth; ++x) {
        const rawX = relX * x;
        const tx = rawX % 1;
        const xl = Math.floor(rawX);
        const xh = Math.min(Math.ceil(rawX), inWidth - 1);
        const ll = array[yl * inWidth + xl];
        const hl = array[yl * inWidth + xh];
        const lh = array[yh * inWidth + xl];
        const hh = array[yh * inWidth + xh];
        const value = lerp(lerp(ll, hl, tx), lerp(lh, hh, tx), rawY % 1);
        newArray[y * outWidth + x] = value;
      }
    }
    return newArray;
  });
}
function resample(valueArrays, inWidth, inHeight, outWidth, outHeight, method = "nearest") {
  switch (method.toLowerCase()) {
    case "nearest":
      return resampleNearest(valueArrays, inWidth, inHeight, outWidth, outHeight);
    case "bilinear":
    case "linear":
      return resampleBilinear(valueArrays, inWidth, inHeight, outWidth, outHeight);
    default:
      throw new Error(`Unsupported resampling method: '${method}'`);
  }
}
function resampleNearestInterleaved(valueArray, inWidth, inHeight, outWidth, outHeight, samples) {
  const relX = inWidth / outWidth;
  const relY = inHeight / outHeight;
  const newArray = copyNewSize(valueArray, outWidth, outHeight, samples);
  for (let y = 0; y < outHeight; ++y) {
    const cy = Math.min(Math.round(relY * y), inHeight - 1);
    for (let x = 0; x < outWidth; ++x) {
      const cx = Math.min(Math.round(relX * x), inWidth - 1);
      for (let i = 0; i < samples; ++i) {
        const value = valueArray[cy * inWidth * samples + cx * samples + i];
        newArray[y * outWidth * samples + x * samples + i] = value;
      }
    }
  }
  return newArray;
}
function resampleBilinearInterleaved(valueArray, inWidth, inHeight, outWidth, outHeight, samples) {
  const relX = inWidth / outWidth;
  const relY = inHeight / outHeight;
  const newArray = copyNewSize(valueArray, outWidth, outHeight, samples);
  for (let y = 0; y < outHeight; ++y) {
    const rawY = relY * y;
    const yl = Math.floor(rawY);
    const yh = Math.min(Math.ceil(rawY), inHeight - 1);
    for (let x = 0; x < outWidth; ++x) {
      const rawX = relX * x;
      const tx = rawX % 1;
      const xl = Math.floor(rawX);
      const xh = Math.min(Math.ceil(rawX), inWidth - 1);
      for (let i = 0; i < samples; ++i) {
        const ll = valueArray[yl * inWidth * samples + xl * samples + i];
        const hl = valueArray[yl * inWidth * samples + xh * samples + i];
        const lh = valueArray[yh * inWidth * samples + xl * samples + i];
        const hh = valueArray[yh * inWidth * samples + xh * samples + i];
        const value = lerp(lerp(ll, hl, tx), lerp(lh, hh, tx), rawY % 1);
        newArray[y * outWidth * samples + x * samples + i] = value;
      }
    }
  }
  return newArray;
}
function resampleInterleaved(valueArray, inWidth, inHeight, outWidth, outHeight, samples, method = "nearest") {
  switch (method.toLowerCase()) {
    case "nearest":
      return resampleNearestInterleaved(valueArray, inWidth, inHeight, outWidth, outHeight, samples);
    case "bilinear":
    case "linear":
      return resampleBilinearInterleaved(valueArray, inWidth, inHeight, outWidth, outHeight, samples);
    default:
      throw new Error(`Unsupported resampling method: '${method}'`);
  }
}

// node_modules/geotiff/src/geotiffimage.js
function sum(array, start, end) {
  let s = 0;
  for (let i = start; i < end; ++i) {
    s += array[i];
  }
  return s;
}
function arrayForType(format, bitsPerSample, size) {
  switch (format) {
    case 1:
      if (bitsPerSample <= 8) {
        return new Uint8Array(size);
      } else if (bitsPerSample <= 16) {
        return new Uint16Array(size);
      } else if (bitsPerSample <= 32) {
        return new Uint32Array(size);
      }
      break;
    case 2:
      if (bitsPerSample === 8) {
        return new Int8Array(size);
      } else if (bitsPerSample === 16) {
        return new Int16Array(size);
      } else if (bitsPerSample === 32) {
        return new Int32Array(size);
      }
      break;
    case 3:
      switch (bitsPerSample) {
        case 16:
        case 32:
          return new Float32Array(size);
        case 64:
          return new Float64Array(size);
        default:
          break;
      }
      break;
    default:
      break;
  }
  throw Error("Unsupported data format/bitsPerSample");
}
function needsNormalization(format, bitsPerSample) {
  if ((format === 1 || format === 2) && bitsPerSample <= 32 && bitsPerSample % 8 === 0) {
    return false;
  } else if (format === 3 && (bitsPerSample === 16 || bitsPerSample === 32 || bitsPerSample === 64)) {
    return false;
  }
  return true;
}
function normalizeArray(inBuffer, format, planarConfiguration, samplesPerPixel, bitsPerSample, tileWidth, tileHeight) {
  const view = new DataView(inBuffer);
  const outSize = planarConfiguration === 2 ? tileHeight * tileWidth : tileHeight * tileWidth * samplesPerPixel;
  const samplesToTransfer = planarConfiguration === 2 ? 1 : samplesPerPixel;
  const outArray = arrayForType(format, bitsPerSample, outSize);
  const bitMask = parseInt("1".repeat(bitsPerSample), 2);
  if (format === 1) {
    let pixelBitSkip;
    if (planarConfiguration === 1) {
      pixelBitSkip = samplesPerPixel * bitsPerSample;
    } else {
      pixelBitSkip = bitsPerSample;
    }
    let bitsPerLine = tileWidth * pixelBitSkip;
    if ((bitsPerLine & 7) !== 0) {
      bitsPerLine = bitsPerLine + 7 & ~7;
    }
    for (let y = 0; y < tileHeight; ++y) {
      const lineBitOffset = y * bitsPerLine;
      for (let x = 0; x < tileWidth; ++x) {
        const pixelBitOffset = lineBitOffset + x * samplesToTransfer * bitsPerSample;
        for (let i = 0; i < samplesToTransfer; ++i) {
          const bitOffset = pixelBitOffset + i * bitsPerSample;
          const outIndex = (y * tileWidth + x) * samplesToTransfer + i;
          const byteOffset = Math.floor(bitOffset / 8);
          const innerBitOffset = bitOffset % 8;
          if (innerBitOffset + bitsPerSample <= 8) {
            outArray[outIndex] = view.getUint8(byteOffset) >> 8 - bitsPerSample - innerBitOffset & bitMask;
          } else if (innerBitOffset + bitsPerSample <= 16) {
            outArray[outIndex] = view.getUint16(byteOffset) >> 16 - bitsPerSample - innerBitOffset & bitMask;
          } else if (innerBitOffset + bitsPerSample <= 24) {
            const raw = view.getUint16(byteOffset) << 8 | view.getUint8(byteOffset + 2);
            outArray[outIndex] = raw >> 24 - bitsPerSample - innerBitOffset & bitMask;
          } else {
            outArray[outIndex] = view.getUint32(byteOffset) >> 32 - bitsPerSample - innerBitOffset & bitMask;
          }
        }
      }
    }
  } else if (format === 3) {
  }
  return outArray.buffer;
}
var GeoTIFFImage = class {
  constructor(fileDirectory, geoKeys, dataView, littleEndian, cache, source2) {
    this.fileDirectory = fileDirectory;
    this.geoKeys = geoKeys;
    this.dataView = dataView;
    this.littleEndian = littleEndian;
    this.tiles = cache ? {} : null;
    this.isTiled = !fileDirectory.StripOffsets;
    const planarConfiguration = fileDirectory.PlanarConfiguration;
    this.planarConfiguration = typeof planarConfiguration === "undefined" ? 1 : planarConfiguration;
    if (this.planarConfiguration !== 1 && this.planarConfiguration !== 2) {
      throw new Error("Invalid planar configuration.");
    }
    this.source = source2;
  }
  getFileDirectory() {
    return this.fileDirectory;
  }
  getGeoKeys() {
    return this.geoKeys;
  }
  getWidth() {
    return this.fileDirectory.ImageWidth;
  }
  getHeight() {
    return this.fileDirectory.ImageLength;
  }
  getSamplesPerPixel() {
    return typeof this.fileDirectory.SamplesPerPixel !== "undefined" ? this.fileDirectory.SamplesPerPixel : 1;
  }
  getTileWidth() {
    return this.isTiled ? this.fileDirectory.TileWidth : this.getWidth();
  }
  getTileHeight() {
    if (this.isTiled) {
      return this.fileDirectory.TileLength;
    }
    if (typeof this.fileDirectory.RowsPerStrip !== "undefined") {
      return Math.min(this.fileDirectory.RowsPerStrip, this.getHeight());
    }
    return this.getHeight();
  }
  getBlockWidth() {
    return this.getTileWidth();
  }
  getBlockHeight(y) {
    if (this.isTiled || (y + 1) * this.getTileHeight() <= this.getHeight()) {
      return this.getTileHeight();
    } else {
      return this.getHeight() - y * this.getTileHeight();
    }
  }
  getBytesPerPixel() {
    let bytes = 0;
    for (let i = 0; i < this.fileDirectory.BitsPerSample.length; ++i) {
      bytes += this.getSampleByteSize(i);
    }
    return bytes;
  }
  getSampleByteSize(i) {
    if (i >= this.fileDirectory.BitsPerSample.length) {
      throw new RangeError(`Sample index ${i} is out of range.`);
    }
    return Math.ceil(this.fileDirectory.BitsPerSample[i] / 8);
  }
  getReaderForSample(sampleIndex) {
    const format = this.fileDirectory.SampleFormat ? this.fileDirectory.SampleFormat[sampleIndex] : 1;
    const bitsPerSample = this.fileDirectory.BitsPerSample[sampleIndex];
    switch (format) {
      case 1:
        if (bitsPerSample <= 8) {
          return DataView.prototype.getUint8;
        } else if (bitsPerSample <= 16) {
          return DataView.prototype.getUint16;
        } else if (bitsPerSample <= 32) {
          return DataView.prototype.getUint32;
        }
        break;
      case 2:
        if (bitsPerSample <= 8) {
          return DataView.prototype.getInt8;
        } else if (bitsPerSample <= 16) {
          return DataView.prototype.getInt16;
        } else if (bitsPerSample <= 32) {
          return DataView.prototype.getInt32;
        }
        break;
      case 3:
        switch (bitsPerSample) {
          case 16:
            return function(offset, littleEndian) {
              return getFloat16(this, offset, littleEndian);
            };
          case 32:
            return DataView.prototype.getFloat32;
          case 64:
            return DataView.prototype.getFloat64;
          default:
            break;
        }
        break;
      default:
        break;
    }
    throw Error("Unsupported data format/bitsPerSample");
  }
  getSampleFormat(sampleIndex = 0) {
    return this.fileDirectory.SampleFormat ? this.fileDirectory.SampleFormat[sampleIndex] : 1;
  }
  getBitsPerSample(sampleIndex = 0) {
    return this.fileDirectory.BitsPerSample[sampleIndex];
  }
  getArrayForSample(sampleIndex, size) {
    const format = this.getSampleFormat(sampleIndex);
    const bitsPerSample = this.getBitsPerSample(sampleIndex);
    return arrayForType(format, bitsPerSample, size);
  }
  async getTileOrStrip(x, y, sample, poolOrDecoder, signal) {
    const numTilesPerRow = Math.ceil(this.getWidth() / this.getTileWidth());
    const numTilesPerCol = Math.ceil(this.getHeight() / this.getTileHeight());
    let index;
    const { tiles } = this;
    if (this.planarConfiguration === 1) {
      index = y * numTilesPerRow + x;
    } else if (this.planarConfiguration === 2) {
      index = sample * numTilesPerRow * numTilesPerCol + y * numTilesPerRow + x;
    }
    let offset;
    let byteCount;
    if (this.isTiled) {
      offset = this.fileDirectory.TileOffsets[index];
      byteCount = this.fileDirectory.TileByteCounts[index];
    } else {
      offset = this.fileDirectory.StripOffsets[index];
      byteCount = this.fileDirectory.StripByteCounts[index];
    }
    const slice = (await this.source.fetch([{ offset, length: byteCount }], signal))[0];
    let request;
    if (tiles === null || !tiles[index]) {
      request = (async () => {
        let data = await poolOrDecoder.decode(this.fileDirectory, slice);
        const sampleFormat = this.getSampleFormat();
        const bitsPerSample = this.getBitsPerSample();
        if (needsNormalization(sampleFormat, bitsPerSample)) {
          data = normalizeArray(data, sampleFormat, this.planarConfiguration, this.getSamplesPerPixel(), bitsPerSample, this.getTileWidth(), this.getBlockHeight(y));
        }
        return data;
      })();
      if (tiles !== null) {
        tiles[index] = request;
      }
    } else {
      request = tiles[index];
    }
    return { x, y, sample, data: await request };
  }
  async _readRaster(imageWindow, samples, valueArrays, interleave, poolOrDecoder, width, height, resampleMethod, signal) {
    const tileWidth = this.getTileWidth();
    const tileHeight = this.getTileHeight();
    const imageWidth = this.getWidth();
    const imageHeight = this.getHeight();
    const minXTile = Math.max(Math.floor(imageWindow[0] / tileWidth), 0);
    const maxXTile = Math.min(Math.ceil(imageWindow[2] / tileWidth), Math.ceil(imageWidth / tileWidth));
    const minYTile = Math.max(Math.floor(imageWindow[1] / tileHeight), 0);
    const maxYTile = Math.min(Math.ceil(imageWindow[3] / tileHeight), Math.ceil(imageHeight / tileHeight));
    const windowWidth = imageWindow[2] - imageWindow[0];
    let bytesPerPixel = this.getBytesPerPixel();
    const srcSampleOffsets = [];
    const sampleReaders = [];
    for (let i = 0; i < samples.length; ++i) {
      if (this.planarConfiguration === 1) {
        srcSampleOffsets.push(sum(this.fileDirectory.BitsPerSample, 0, samples[i]) / 8);
      } else {
        srcSampleOffsets.push(0);
      }
      sampleReaders.push(this.getReaderForSample(samples[i]));
    }
    const promises = [];
    const { littleEndian } = this;
    for (let yTile = minYTile; yTile < maxYTile; ++yTile) {
      for (let xTile = minXTile; xTile < maxXTile; ++xTile) {
        for (let sampleIndex = 0; sampleIndex < samples.length; ++sampleIndex) {
          const si = sampleIndex;
          const sample = samples[sampleIndex];
          if (this.planarConfiguration === 2) {
            bytesPerPixel = this.getSampleByteSize(sampleIndex);
          }
          const promise = this.getTileOrStrip(xTile, yTile, sample, poolOrDecoder, signal);
          promises.push(promise);
          promise.then((tile) => {
            const buffer4 = tile.data;
            const dataView = new DataView(buffer4);
            const blockHeight = this.getBlockHeight(tile.y);
            const firstLine = tile.y * tileHeight;
            const firstCol = tile.x * tileWidth;
            const lastLine = firstLine + blockHeight;
            const lastCol = (tile.x + 1) * tileWidth;
            const reader = sampleReaders[si];
            const ymax = Math.min(blockHeight, blockHeight - (lastLine - imageWindow[3]), imageHeight - firstLine);
            const xmax = Math.min(tileWidth, tileWidth - (lastCol - imageWindow[2]), imageWidth - firstCol);
            for (let y = Math.max(0, imageWindow[1] - firstLine); y < ymax; ++y) {
              for (let x = Math.max(0, imageWindow[0] - firstCol); x < xmax; ++x) {
                const pixelOffset = (y * tileWidth + x) * bytesPerPixel;
                const value = reader.call(dataView, pixelOffset + srcSampleOffsets[si], littleEndian);
                let windowCoordinate;
                if (interleave) {
                  windowCoordinate = (y + firstLine - imageWindow[1]) * windowWidth * samples.length + (x + firstCol - imageWindow[0]) * samples.length + si;
                  valueArrays[windowCoordinate] = value;
                } else {
                  windowCoordinate = (y + firstLine - imageWindow[1]) * windowWidth + x + firstCol - imageWindow[0];
                  valueArrays[si][windowCoordinate] = value;
                }
              }
            }
          });
        }
      }
    }
    await Promise.all(promises);
    if (width && imageWindow[2] - imageWindow[0] !== width || height && imageWindow[3] - imageWindow[1] !== height) {
      let resampled;
      if (interleave) {
        resampled = resampleInterleaved(valueArrays, imageWindow[2] - imageWindow[0], imageWindow[3] - imageWindow[1], width, height, samples.length, resampleMethod);
      } else {
        resampled = resample(valueArrays, imageWindow[2] - imageWindow[0], imageWindow[3] - imageWindow[1], width, height, resampleMethod);
      }
      resampled.width = width;
      resampled.height = height;
      return resampled;
    }
    valueArrays.width = width || imageWindow[2] - imageWindow[0];
    valueArrays.height = height || imageWindow[3] - imageWindow[1];
    return valueArrays;
  }
  async readRasters({
    window: wnd,
    samples = [],
    interleave,
    pool = null,
    width,
    height,
    resampleMethod,
    fillValue,
    signal
  } = {}) {
    const imageWindow = wnd || [0, 0, this.getWidth(), this.getHeight()];
    if (imageWindow[0] > imageWindow[2] || imageWindow[1] > imageWindow[3]) {
      throw new Error("Invalid subsets");
    }
    const imageWindowWidth = imageWindow[2] - imageWindow[0];
    const imageWindowHeight = imageWindow[3] - imageWindow[1];
    const numPixels = imageWindowWidth * imageWindowHeight;
    const samplesPerPixel = this.getSamplesPerPixel();
    if (!samples || !samples.length) {
      for (let i = 0; i < samplesPerPixel; ++i) {
        samples.push(i);
      }
    } else {
      for (let i = 0; i < samples.length; ++i) {
        if (samples[i] >= samplesPerPixel) {
          return Promise.reject(new RangeError(`Invalid sample index '${samples[i]}'.`));
        }
      }
    }
    let valueArrays;
    if (interleave) {
      const format = this.fileDirectory.SampleFormat ? Math.max.apply(null, this.fileDirectory.SampleFormat) : 1;
      const bitsPerSample = Math.max.apply(null, this.fileDirectory.BitsPerSample);
      valueArrays = arrayForType(format, bitsPerSample, numPixels * samples.length);
      if (fillValue) {
        valueArrays.fill(fillValue);
      }
    } else {
      valueArrays = [];
      for (let i = 0; i < samples.length; ++i) {
        const valueArray = this.getArrayForSample(samples[i], numPixels);
        if (Array.isArray(fillValue) && i < fillValue.length) {
          valueArray.fill(fillValue[i]);
        } else if (fillValue && !Array.isArray(fillValue)) {
          valueArray.fill(fillValue);
        }
        valueArrays.push(valueArray);
      }
    }
    const poolOrDecoder = pool || await getDecoder(this.fileDirectory);
    const result = await this._readRaster(imageWindow, samples, valueArrays, interleave, poolOrDecoder, width, height, resampleMethod, signal);
    return result;
  }
  async readRGB({
    window: window2,
    interleave = true,
    pool = null,
    width,
    height,
    resampleMethod,
    enableAlpha = false,
    signal
  } = {}) {
    const imageWindow = window2 || [0, 0, this.getWidth(), this.getHeight()];
    if (imageWindow[0] > imageWindow[2] || imageWindow[1] > imageWindow[3]) {
      throw new Error("Invalid subsets");
    }
    const pi = this.fileDirectory.PhotometricInterpretation;
    if (pi === photometricInterpretations.RGB) {
      let s = [0, 1, 2];
      if (!(this.fileDirectory.ExtraSamples === ExtraSamplesValues.Unspecified) && enableAlpha) {
        s = [];
        for (let i = 0; i < this.fileDirectory.BitsPerSample.length; i += 1) {
          s.push(i);
        }
      }
      return this.readRasters({
        window: window2,
        interleave,
        samples: s,
        pool,
        width,
        height,
        resampleMethod,
        signal
      });
    }
    let samples;
    switch (pi) {
      case photometricInterpretations.WhiteIsZero:
      case photometricInterpretations.BlackIsZero:
      case photometricInterpretations.Palette:
        samples = [0];
        break;
      case photometricInterpretations.CMYK:
        samples = [0, 1, 2, 3];
        break;
      case photometricInterpretations.YCbCr:
      case photometricInterpretations.CIELab:
        samples = [0, 1, 2];
        break;
      default:
        throw new Error("Invalid or unsupported photometric interpretation.");
    }
    const subOptions = {
      window: imageWindow,
      interleave: true,
      samples,
      pool,
      width,
      height,
      resampleMethod,
      signal
    };
    const { fileDirectory } = this;
    const raster = await this.readRasters(subOptions);
    const max = 2 ** this.fileDirectory.BitsPerSample[0];
    let data;
    switch (pi) {
      case photometricInterpretations.WhiteIsZero:
        data = fromWhiteIsZero(raster, max);
        break;
      case photometricInterpretations.BlackIsZero:
        data = fromBlackIsZero(raster, max);
        break;
      case photometricInterpretations.Palette:
        data = fromPalette(raster, fileDirectory.ColorMap);
        break;
      case photometricInterpretations.CMYK:
        data = fromCMYK(raster);
        break;
      case photometricInterpretations.YCbCr:
        data = fromYCbCr(raster);
        break;
      case photometricInterpretations.CIELab:
        data = fromCIELab(raster);
        break;
      default:
        throw new Error("Unsupported photometric interpretation.");
    }
    if (!interleave) {
      const red = new Uint8Array(data.length / 3);
      const green = new Uint8Array(data.length / 3);
      const blue = new Uint8Array(data.length / 3);
      for (let i = 0, j = 0; i < data.length; i += 3, ++j) {
        red[j] = data[i];
        green[j] = data[i + 1];
        blue[j] = data[i + 2];
      }
      data = [red, green, blue];
    }
    data.width = raster.width;
    data.height = raster.height;
    return data;
  }
  getTiePoints() {
    if (!this.fileDirectory.ModelTiepoint) {
      return [];
    }
    const tiePoints = [];
    for (let i = 0; i < this.fileDirectory.ModelTiepoint.length; i += 6) {
      tiePoints.push({
        i: this.fileDirectory.ModelTiepoint[i],
        j: this.fileDirectory.ModelTiepoint[i + 1],
        k: this.fileDirectory.ModelTiepoint[i + 2],
        x: this.fileDirectory.ModelTiepoint[i + 3],
        y: this.fileDirectory.ModelTiepoint[i + 4],
        z: this.fileDirectory.ModelTiepoint[i + 5]
      });
    }
    return tiePoints;
  }
  getGDALMetadata(sample = null) {
    const metadata = {};
    if (!this.fileDirectory.GDAL_METADATA) {
      return null;
    }
    const string = this.fileDirectory.GDAL_METADATA;
    let items = (0, import_find_tags_by_name.default)(string, "Item");
    if (sample !== null) {
      items = items.filter((item) => Number((0, import_get_attribute.default)(item, "sample")) === sample);
    }
    for (let i = 0; i < items.length; ++i) {
      const item = items[i];
      metadata[(0, import_get_attribute.default)(item, "name")] = item.inner;
    }
    return metadata;
  }
  getGDALNoData() {
    if (!this.fileDirectory.GDAL_NODATA) {
      return null;
    }
    const string = this.fileDirectory.GDAL_NODATA;
    return Number(string.substring(0, string.length - 1));
  }
  getOrigin() {
    const tiePoints = this.fileDirectory.ModelTiepoint;
    const modelTransformation = this.fileDirectory.ModelTransformation;
    if (tiePoints && tiePoints.length === 6) {
      return [
        tiePoints[3],
        tiePoints[4],
        tiePoints[5]
      ];
    }
    if (modelTransformation) {
      return [
        modelTransformation[3],
        modelTransformation[7],
        modelTransformation[11]
      ];
    }
    throw new Error("The image does not have an affine transformation.");
  }
  getResolution(referenceImage = null) {
    const modelPixelScale = this.fileDirectory.ModelPixelScale;
    const modelTransformation = this.fileDirectory.ModelTransformation;
    if (modelPixelScale) {
      return [
        modelPixelScale[0],
        -modelPixelScale[1],
        modelPixelScale[2]
      ];
    }
    if (modelTransformation) {
      return [
        modelTransformation[0],
        modelTransformation[5],
        modelTransformation[10]
      ];
    }
    if (referenceImage) {
      const [refResX, refResY, refResZ] = referenceImage.getResolution();
      return [
        refResX * referenceImage.getWidth() / this.getWidth(),
        refResY * referenceImage.getHeight() / this.getHeight(),
        refResZ * referenceImage.getWidth() / this.getWidth()
      ];
    }
    throw new Error("The image does not have an affine transformation.");
  }
  pixelIsArea() {
    return this.geoKeys.GTRasterTypeGeoKey === 1;
  }
  getBoundingBox() {
    const origin = this.getOrigin();
    const resolution = this.getResolution();
    const x1 = origin[0];
    const y1 = origin[1];
    const x2 = x1 + resolution[0] * this.getWidth();
    const y2 = y1 + resolution[1] * this.getHeight();
    return [
      Math.min(x1, x2),
      Math.min(y1, y2),
      Math.max(x1, x2),
      Math.max(y1, y2)
    ];
  }
};
var geotiffimage_default = GeoTIFFImage;

// node_modules/geotiff/src/dataview64.js
var DataView64 = class {
  constructor(arrayBuffer) {
    this._dataView = new DataView(arrayBuffer);
  }
  get buffer() {
    return this._dataView.buffer;
  }
  getUint64(offset, littleEndian) {
    const left = this.getUint32(offset, littleEndian);
    const right = this.getUint32(offset + 4, littleEndian);
    let combined;
    if (littleEndian) {
      combined = left + 2 ** 32 * right;
      if (!Number.isSafeInteger(combined)) {
        throw new Error(`${combined} exceeds MAX_SAFE_INTEGER. Precision may be lost. Please report if you get this message to https://github.com/geotiffjs/geotiff.js/issues`);
      }
      return combined;
    }
    combined = 2 ** 32 * left + right;
    if (!Number.isSafeInteger(combined)) {
      throw new Error(`${combined} exceeds MAX_SAFE_INTEGER. Precision may be lost. Please report if you get this message to https://github.com/geotiffjs/geotiff.js/issues`);
    }
    return combined;
  }
  getInt64(offset, littleEndian) {
    let value = 0;
    const isNegative = (this._dataView.getUint8(offset + (littleEndian ? 7 : 0)) & 128) > 0;
    let carrying = true;
    for (let i = 0; i < 8; i++) {
      let byte = this._dataView.getUint8(offset + (littleEndian ? i : 7 - i));
      if (isNegative) {
        if (carrying) {
          if (byte !== 0) {
            byte = ~(byte - 1) & 255;
            carrying = false;
          }
        } else {
          byte = ~byte & 255;
        }
      }
      value += byte * 256 ** i;
    }
    if (isNegative) {
      value = -value;
    }
    return value;
  }
  getUint8(offset, littleEndian) {
    return this._dataView.getUint8(offset, littleEndian);
  }
  getInt8(offset, littleEndian) {
    return this._dataView.getInt8(offset, littleEndian);
  }
  getUint16(offset, littleEndian) {
    return this._dataView.getUint16(offset, littleEndian);
  }
  getInt16(offset, littleEndian) {
    return this._dataView.getInt16(offset, littleEndian);
  }
  getUint32(offset, littleEndian) {
    return this._dataView.getUint32(offset, littleEndian);
  }
  getInt32(offset, littleEndian) {
    return this._dataView.getInt32(offset, littleEndian);
  }
  getFloat16(offset, littleEndian) {
    return getFloat16(this._dataView, offset, littleEndian);
  }
  getFloat32(offset, littleEndian) {
    return this._dataView.getFloat32(offset, littleEndian);
  }
  getFloat64(offset, littleEndian) {
    return this._dataView.getFloat64(offset, littleEndian);
  }
};

// node_modules/geotiff/src/dataslice.js
var DataSlice = class {
  constructor(arrayBuffer, sliceOffset, littleEndian, bigTiff) {
    this._dataView = new DataView(arrayBuffer);
    this._sliceOffset = sliceOffset;
    this._littleEndian = littleEndian;
    this._bigTiff = bigTiff;
  }
  get sliceOffset() {
    return this._sliceOffset;
  }
  get sliceTop() {
    return this._sliceOffset + this.buffer.byteLength;
  }
  get littleEndian() {
    return this._littleEndian;
  }
  get bigTiff() {
    return this._bigTiff;
  }
  get buffer() {
    return this._dataView.buffer;
  }
  covers(offset, length) {
    return this.sliceOffset <= offset && this.sliceTop >= offset + length;
  }
  readUint8(offset) {
    return this._dataView.getUint8(offset - this._sliceOffset, this._littleEndian);
  }
  readInt8(offset) {
    return this._dataView.getInt8(offset - this._sliceOffset, this._littleEndian);
  }
  readUint16(offset) {
    return this._dataView.getUint16(offset - this._sliceOffset, this._littleEndian);
  }
  readInt16(offset) {
    return this._dataView.getInt16(offset - this._sliceOffset, this._littleEndian);
  }
  readUint32(offset) {
    return this._dataView.getUint32(offset - this._sliceOffset, this._littleEndian);
  }
  readInt32(offset) {
    return this._dataView.getInt32(offset - this._sliceOffset, this._littleEndian);
  }
  readFloat32(offset) {
    return this._dataView.getFloat32(offset - this._sliceOffset, this._littleEndian);
  }
  readFloat64(offset) {
    return this._dataView.getFloat64(offset - this._sliceOffset, this._littleEndian);
  }
  readUint64(offset) {
    const left = this.readUint32(offset);
    const right = this.readUint32(offset + 4);
    let combined;
    if (this._littleEndian) {
      combined = left + 2 ** 32 * right;
      if (!Number.isSafeInteger(combined)) {
        throw new Error(`${combined} exceeds MAX_SAFE_INTEGER. Precision may be lost. Please report if you get this message to https://github.com/geotiffjs/geotiff.js/issues`);
      }
      return combined;
    }
    combined = 2 ** 32 * left + right;
    if (!Number.isSafeInteger(combined)) {
      throw new Error(`${combined} exceeds MAX_SAFE_INTEGER. Precision may be lost. Please report if you get this message to https://github.com/geotiffjs/geotiff.js/issues`);
    }
    return combined;
  }
  readInt64(offset) {
    let value = 0;
    const isNegative = (this._dataView.getUint8(offset + (this._littleEndian ? 7 : 0)) & 128) > 0;
    let carrying = true;
    for (let i = 0; i < 8; i++) {
      let byte = this._dataView.getUint8(offset + (this._littleEndian ? i : 7 - i));
      if (isNegative) {
        if (carrying) {
          if (byte !== 0) {
            byte = ~(byte - 1) & 255;
            carrying = false;
          }
        } else {
          byte = ~byte & 255;
        }
      }
      value += byte * 256 ** i;
    }
    if (isNegative) {
      value = -value;
    }
    return value;
  }
  readOffset(offset) {
    if (this._bigTiff) {
      return this.readUint64(offset);
    }
    return this.readUint32(offset);
  }
};

// node_modules/threads/dist-esm/serializers.js
var DefaultErrorSerializer = {
  deserialize(message) {
    return Object.assign(Error(message.message), {
      name: message.name,
      stack: message.stack
    });
  },
  serialize(error) {
    return {
      __error_marker: "$$error",
      message: error.message,
      name: error.name,
      stack: error.stack
    };
  }
};
var isSerializedError = (thing) => thing && typeof thing === "object" && "__error_marker" in thing && thing.__error_marker === "$$error";
var DefaultSerializer = {
  deserialize(message) {
    if (isSerializedError(message)) {
      return DefaultErrorSerializer.deserialize(message);
    } else {
      return message;
    }
  },
  serialize(input) {
    if (input instanceof Error) {
      return DefaultErrorSerializer.serialize(input);
    } else {
      return input;
    }
  }
};

// node_modules/threads/dist-esm/common.js
var registeredSerializer = DefaultSerializer;
function deserialize(message) {
  return registeredSerializer.deserialize(message);
}
function serialize(input) {
  return registeredSerializer.serialize(input);
}

// node_modules/threads/dist-esm/master/get-bundle-url.browser.js
var bundleURL;
function getBundleURLCached() {
  if (!bundleURL) {
    bundleURL = getBundleURL();
  }
  return bundleURL;
}
function getBundleURL() {
  try {
    throw new Error();
  } catch (err) {
    const matches = ("" + err.stack).match(/(https?|file|ftp|chrome-extension|moz-extension):\/\/[^)\n]+/g);
    if (matches) {
      return getBaseURL(matches[0]);
    }
  }
  return "/";
}
function getBaseURL(url2) {
  return ("" + url2).replace(/^((?:https?|file|ftp|chrome-extension|moz-extension):\/\/.+)?\/[^/]+(?:\?.*)?$/, "$1") + "/";
}

// node_modules/threads/dist-esm/master/implementation.browser.js
var defaultPoolSize = typeof navigator !== "undefined" && navigator.hardwareConcurrency ? navigator.hardwareConcurrency : 4;
var isAbsoluteURL = (value) => /^[a-zA-Z][a-zA-Z\d+\-.]*:/.test(value);
function createSourceBlobURL(code) {
  const blob2 = new Blob([code], { type: "application/javascript" });
  return URL.createObjectURL(blob2);
}
function selectWorkerImplementation() {
  if (typeof Worker === "undefined") {
    return class NoWebWorker {
      constructor() {
        throw Error("No web worker implementation available. You might have tried to spawn a worker within a worker in a browser that doesn't support workers in workers.");
      }
    };
  }
  class WebWorker extends Worker {
    constructor(url2, options) {
      var _a, _b;
      if (typeof url2 === "string" && options && options._baseURL) {
        url2 = new URL(url2, options._baseURL);
      } else if (typeof url2 === "string" && !isAbsoluteURL(url2) && getBundleURLCached().match(/^file:\/\//i)) {
        url2 = new URL(url2, getBundleURLCached().replace(/\/[^\/]+$/, "/"));
        if ((_a = options === null || options === void 0 ? void 0 : options.CORSWorkaround) !== null && _a !== void 0 ? _a : true) {
          url2 = createSourceBlobURL(`importScripts(${JSON.stringify(url2)});`);
        }
      }
      if (typeof url2 === "string" && isAbsoluteURL(url2)) {
        if ((_b = options === null || options === void 0 ? void 0 : options.CORSWorkaround) !== null && _b !== void 0 ? _b : true) {
          url2 = createSourceBlobURL(`importScripts(${JSON.stringify(url2)});`);
        }
      }
      super(url2, options);
    }
  }
  class BlobWorker2 extends WebWorker {
    constructor(blob2, options) {
      const url2 = window.URL.createObjectURL(blob2);
      super(url2, options);
    }
    static fromText(source2, options) {
      const blob2 = new window.Blob([source2], { type: "text/javascript" });
      return new BlobWorker2(blob2, options);
    }
  }
  return {
    blob: BlobWorker2,
    default: WebWorker
  };
}
var implementation;
function getWorkerImplementation() {
  if (!implementation) {
    implementation = selectWorkerImplementation();
  }
  return implementation;
}

// node_modules/threads/dist-esm/master/pool.js
var import_debug = __toModule(require_browser());

// node_modules/observable-fns/dist.esm/_symbols.js
var hasSymbols = () => typeof Symbol === "function";
var hasSymbol = (name) => hasSymbols() && Boolean(Symbol[name]);
var getSymbol = (name) => hasSymbol(name) ? Symbol[name] : "@@" + name;
if (!hasSymbol("asyncIterator")) {
  Symbol.asyncIterator = Symbol.asyncIterator || Symbol.for("Symbol.asyncIterator");
}

// node_modules/observable-fns/dist.esm/observable.js
var SymbolIterator = getSymbol("iterator");
var SymbolObservable = getSymbol("observable");
var SymbolSpecies = getSymbol("species");
function getMethod(obj, key) {
  const value = obj[key];
  if (value == null) {
    return void 0;
  }
  if (typeof value !== "function") {
    throw new TypeError(value + " is not a function");
  }
  return value;
}
function getSpecies(obj) {
  let ctor = obj.constructor;
  if (ctor !== void 0) {
    ctor = ctor[SymbolSpecies];
    if (ctor === null) {
      ctor = void 0;
    }
  }
  return ctor !== void 0 ? ctor : Observable;
}
function isObservable(x) {
  return x instanceof Observable;
}
function hostReportError(error) {
  if (hostReportError.log) {
    hostReportError.log(error);
  } else {
    setTimeout(() => {
      throw error;
    }, 0);
  }
}
function enqueue(fn) {
  Promise.resolve().then(() => {
    try {
      fn();
    } catch (e) {
      hostReportError(e);
    }
  });
}
function cleanupSubscription(subscription) {
  const cleanup = subscription._cleanup;
  if (cleanup === void 0) {
    return;
  }
  subscription._cleanup = void 0;
  if (!cleanup) {
    return;
  }
  try {
    if (typeof cleanup === "function") {
      cleanup();
    } else {
      const unsubscribe2 = getMethod(cleanup, "unsubscribe");
      if (unsubscribe2) {
        unsubscribe2.call(cleanup);
      }
    }
  } catch (e) {
    hostReportError(e);
  }
}
function closeSubscription(subscription) {
  subscription._observer = void 0;
  subscription._queue = void 0;
  subscription._state = "closed";
}
function flushSubscription(subscription) {
  const queue = subscription._queue;
  if (!queue) {
    return;
  }
  subscription._queue = void 0;
  subscription._state = "ready";
  for (const item of queue) {
    notifySubscription(subscription, item.type, item.value);
    if (subscription._state === "closed") {
      break;
    }
  }
}
function notifySubscription(subscription, type, value) {
  subscription._state = "running";
  const observer = subscription._observer;
  try {
    const m = observer ? getMethod(observer, type) : void 0;
    switch (type) {
      case "next":
        if (m)
          m.call(observer, value);
        break;
      case "error":
        closeSubscription(subscription);
        if (m)
          m.call(observer, value);
        else
          throw value;
        break;
      case "complete":
        closeSubscription(subscription);
        if (m)
          m.call(observer);
        break;
    }
  } catch (e) {
    hostReportError(e);
  }
  if (subscription._state === "closed") {
    cleanupSubscription(subscription);
  } else if (subscription._state === "running") {
    subscription._state = "ready";
  }
}
function onNotify(subscription, type, value) {
  if (subscription._state === "closed") {
    return;
  }
  if (subscription._state === "buffering") {
    subscription._queue = subscription._queue || [];
    subscription._queue.push({ type, value });
    return;
  }
  if (subscription._state !== "ready") {
    subscription._state = "buffering";
    subscription._queue = [{ type, value }];
    enqueue(() => flushSubscription(subscription));
    return;
  }
  notifySubscription(subscription, type, value);
}
var Subscription = class {
  constructor(observer, subscriber) {
    this._cleanup = void 0;
    this._observer = observer;
    this._queue = void 0;
    this._state = "initializing";
    const subscriptionObserver = new SubscriptionObserver(this);
    try {
      this._cleanup = subscriber.call(void 0, subscriptionObserver);
    } catch (e) {
      subscriptionObserver.error(e);
    }
    if (this._state === "initializing") {
      this._state = "ready";
    }
  }
  get closed() {
    return this._state === "closed";
  }
  unsubscribe() {
    if (this._state !== "closed") {
      closeSubscription(this);
      cleanupSubscription(this);
    }
  }
};
var SubscriptionObserver = class {
  constructor(subscription) {
    this._subscription = subscription;
  }
  get closed() {
    return this._subscription._state === "closed";
  }
  next(value) {
    onNotify(this._subscription, "next", value);
  }
  error(value) {
    onNotify(this._subscription, "error", value);
  }
  complete() {
    onNotify(this._subscription, "complete");
  }
};
var Observable = class {
  constructor(subscriber) {
    if (!(this instanceof Observable)) {
      throw new TypeError("Observable cannot be called as a function");
    }
    if (typeof subscriber !== "function") {
      throw new TypeError("Observable initializer must be a function");
    }
    this._subscriber = subscriber;
  }
  subscribe(nextOrObserver, onError, onComplete) {
    if (typeof nextOrObserver !== "object" || nextOrObserver === null) {
      nextOrObserver = {
        next: nextOrObserver,
        error: onError,
        complete: onComplete
      };
    }
    return new Subscription(nextOrObserver, this._subscriber);
  }
  pipe(first, ...mappers) {
    let intermediate = this;
    for (const mapper of [first, ...mappers]) {
      intermediate = mapper(intermediate);
    }
    return intermediate;
  }
  tap(nextOrObserver, onError, onComplete) {
    const tapObserver = typeof nextOrObserver !== "object" || nextOrObserver === null ? {
      next: nextOrObserver,
      error: onError,
      complete: onComplete
    } : nextOrObserver;
    return new Observable((observer) => {
      return this.subscribe({
        next(value) {
          tapObserver.next && tapObserver.next(value);
          observer.next(value);
        },
        error(error) {
          tapObserver.error && tapObserver.error(error);
          observer.error(error);
        },
        complete() {
          tapObserver.complete && tapObserver.complete();
          observer.complete();
        },
        start(subscription) {
          tapObserver.start && tapObserver.start(subscription);
        }
      });
    });
  }
  forEach(fn) {
    return new Promise((resolve, reject) => {
      if (typeof fn !== "function") {
        reject(new TypeError(fn + " is not a function"));
        return;
      }
      function done() {
        subscription.unsubscribe();
        resolve(void 0);
      }
      const subscription = this.subscribe({
        next(value) {
          try {
            fn(value, done);
          } catch (e) {
            reject(e);
            subscription.unsubscribe();
          }
        },
        error(error) {
          reject(error);
        },
        complete() {
          resolve(void 0);
        }
      });
    });
  }
  map(fn) {
    if (typeof fn !== "function") {
      throw new TypeError(fn + " is not a function");
    }
    const C = getSpecies(this);
    return new C((observer) => this.subscribe({
      next(value) {
        let propagatedValue = value;
        try {
          propagatedValue = fn(value);
        } catch (e) {
          return observer.error(e);
        }
        observer.next(propagatedValue);
      },
      error(e) {
        observer.error(e);
      },
      complete() {
        observer.complete();
      }
    }));
  }
  filter(fn) {
    if (typeof fn !== "function") {
      throw new TypeError(fn + " is not a function");
    }
    const C = getSpecies(this);
    return new C((observer) => this.subscribe({
      next(value) {
        try {
          if (!fn(value))
            return;
        } catch (e) {
          return observer.error(e);
        }
        observer.next(value);
      },
      error(e) {
        observer.error(e);
      },
      complete() {
        observer.complete();
      }
    }));
  }
  reduce(fn, seed) {
    if (typeof fn !== "function") {
      throw new TypeError(fn + " is not a function");
    }
    const C = getSpecies(this);
    const hasSeed = arguments.length > 1;
    let hasValue = false;
    let acc = seed;
    return new C((observer) => this.subscribe({
      next(value) {
        const first = !hasValue;
        hasValue = true;
        if (!first || hasSeed) {
          try {
            acc = fn(acc, value);
          } catch (e) {
            return observer.error(e);
          }
        } else {
          acc = value;
        }
      },
      error(e) {
        observer.error(e);
      },
      complete() {
        if (!hasValue && !hasSeed) {
          return observer.error(new TypeError("Cannot reduce an empty sequence"));
        }
        observer.next(acc);
        observer.complete();
      }
    }));
  }
  concat(...sources) {
    const C = getSpecies(this);
    return new C((observer) => {
      let subscription;
      let index = 0;
      function startNext(next2) {
        subscription = next2.subscribe({
          next(v) {
            observer.next(v);
          },
          error(e) {
            observer.error(e);
          },
          complete() {
            if (index === sources.length) {
              subscription = void 0;
              observer.complete();
            } else {
              startNext(C.from(sources[index++]));
            }
          }
        });
      }
      startNext(this);
      return () => {
        if (subscription) {
          subscription.unsubscribe();
          subscription = void 0;
        }
      };
    });
  }
  flatMap(fn) {
    if (typeof fn !== "function") {
      throw new TypeError(fn + " is not a function");
    }
    const C = getSpecies(this);
    return new C((observer) => {
      const subscriptions = [];
      const outer = this.subscribe({
        next(value) {
          let normalizedValue;
          if (fn) {
            try {
              normalizedValue = fn(value);
            } catch (e) {
              return observer.error(e);
            }
          } else {
            normalizedValue = value;
          }
          const inner = C.from(normalizedValue).subscribe({
            next(innerValue) {
              observer.next(innerValue);
            },
            error(e) {
              observer.error(e);
            },
            complete() {
              const i = subscriptions.indexOf(inner);
              if (i >= 0)
                subscriptions.splice(i, 1);
              completeIfDone();
            }
          });
          subscriptions.push(inner);
        },
        error(e) {
          observer.error(e);
        },
        complete() {
          completeIfDone();
        }
      });
      function completeIfDone() {
        if (outer.closed && subscriptions.length === 0) {
          observer.complete();
        }
      }
      return () => {
        subscriptions.forEach((s) => s.unsubscribe());
        outer.unsubscribe();
      };
    });
  }
  [(Symbol.observable, SymbolObservable)]() {
    return this;
  }
  static from(x) {
    const C = typeof this === "function" ? this : Observable;
    if (x == null) {
      throw new TypeError(x + " is not an object");
    }
    const observableMethod = getMethod(x, SymbolObservable);
    if (observableMethod) {
      const observable = observableMethod.call(x);
      if (Object(observable) !== observable) {
        throw new TypeError(observable + " is not an object");
      }
      if (isObservable(observable) && observable.constructor === C) {
        return observable;
      }
      return new C((observer) => observable.subscribe(observer));
    }
    if (hasSymbol("iterator")) {
      const iteratorMethod = getMethod(x, SymbolIterator);
      if (iteratorMethod) {
        return new C((observer) => {
          enqueue(() => {
            if (observer.closed)
              return;
            for (const item of iteratorMethod.call(x)) {
              observer.next(item);
              if (observer.closed)
                return;
            }
            observer.complete();
          });
        });
      }
    }
    if (Array.isArray(x)) {
      return new C((observer) => {
        enqueue(() => {
          if (observer.closed)
            return;
          for (const item of x) {
            observer.next(item);
            if (observer.closed)
              return;
          }
          observer.complete();
        });
      });
    }
    throw new TypeError(x + " is not observable");
  }
  static of(...items) {
    const C = typeof this === "function" ? this : Observable;
    return new C((observer) => {
      enqueue(() => {
        if (observer.closed)
          return;
        for (const item of items) {
          observer.next(item);
          if (observer.closed)
            return;
        }
        observer.complete();
      });
    });
  }
  static get [SymbolSpecies]() {
    return this;
  }
};
if (hasSymbols()) {
  Object.defineProperty(Observable, Symbol("extensions"), {
    value: {
      symbol: SymbolObservable,
      hostReportError
    },
    configurable: true
  });
}
var observable_default = Observable;

// node_modules/observable-fns/dist.esm/unsubscribe.js
function unsubscribe(subscription) {
  if (typeof subscription === "function") {
    subscription();
  } else if (subscription && typeof subscription.unsubscribe === "function") {
    subscription.unsubscribe();
  }
}
var unsubscribe_default = unsubscribe;

// node_modules/observable-fns/dist.esm/subject.js
var MulticastSubject = class extends observable_default {
  constructor() {
    super((observer) => {
      this._observers.add(observer);
      return () => this._observers.delete(observer);
    });
    this._observers = new Set();
  }
  next(value) {
    for (const observer of this._observers) {
      observer.next(value);
    }
  }
  error(error) {
    for (const observer of this._observers) {
      observer.error(error);
    }
  }
  complete() {
    for (const observer of this._observers) {
      observer.complete();
    }
  }
};
var subject_default = MulticastSubject;

// node_modules/observable-fns/dist.esm/multicast.js
function multicast(coldObservable) {
  const subject = new subject_default();
  let sourceSubscription;
  let subscriberCount = 0;
  return new observable_default((observer) => {
    if (!sourceSubscription) {
      sourceSubscription = coldObservable.subscribe(subject);
    }
    const subscription = subject.subscribe(observer);
    subscriberCount++;
    return () => {
      subscriberCount--;
      subscription.unsubscribe();
      if (subscriberCount === 0) {
        unsubscribe_default(sourceSubscription);
        sourceSubscription = void 0;
      }
    };
  });
}
var multicast_default = multicast;

// node_modules/threads/dist-esm/ponyfills.js
function allSettled(values) {
  return Promise.all(values.map((item) => {
    const onFulfill = (value) => {
      return { status: "fulfilled", value };
    };
    const onReject = (reason) => {
      return { status: "rejected", reason };
    };
    const itemPromise = Promise.resolve(item);
    try {
      return itemPromise.then(onFulfill, onReject);
    } catch (error) {
      return Promise.reject(error);
    }
  }));
}

// node_modules/threads/dist-esm/master/pool-types.js
var PoolEventType;
(function(PoolEventType2) {
  PoolEventType2["initialized"] = "initialized";
  PoolEventType2["taskCanceled"] = "taskCanceled";
  PoolEventType2["taskCompleted"] = "taskCompleted";
  PoolEventType2["taskFailed"] = "taskFailed";
  PoolEventType2["taskQueued"] = "taskQueued";
  PoolEventType2["taskQueueDrained"] = "taskQueueDrained";
  PoolEventType2["taskStart"] = "taskStart";
  PoolEventType2["terminated"] = "terminated";
})(PoolEventType || (PoolEventType = {}));

// node_modules/threads/dist-esm/symbols.js
var $errors = Symbol("thread.errors");
var $events = Symbol("thread.events");
var $terminate = Symbol("thread.terminate");
var $transferable = Symbol("thread.transferable");
var $worker = Symbol("thread.worker");

// node_modules/threads/dist-esm/master/thread.js
function fail(message) {
  throw Error(message);
}
var Thread = {
  errors(thread) {
    return thread[$errors] || fail("Error observable not found. Make sure to pass a thread instance as returned by the spawn() promise.");
  },
  events(thread) {
    return thread[$events] || fail("Events observable not found. Make sure to pass a thread instance as returned by the spawn() promise.");
  },
  terminate(thread) {
    return thread[$terminate]();
  }
};

// node_modules/threads/dist-esm/master/pool.js
var __awaiter = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var nextPoolID = 1;
function createArray(size) {
  const array = [];
  for (let index = 0; index < size; index++) {
    array.push(index);
  }
  return array;
}
function delay(ms) {
  return new Promise((resolve) => setTimeout(resolve, ms));
}
function flatMap(array, mapper) {
  return array.reduce((flattened, element) => [...flattened, ...mapper(element)], []);
}
function slugify(text) {
  return text.replace(/\W/g, " ").trim().replace(/\s+/g, "-");
}
function spawnWorkers(spawnWorker, count) {
  return createArray(count).map(() => ({
    init: spawnWorker(),
    runningTasks: []
  }));
}
var WorkerPool = class {
  constructor(spawnWorker, optionsOrSize) {
    this.eventSubject = new subject_default();
    this.initErrors = [];
    this.isClosing = false;
    this.nextTaskID = 1;
    this.taskQueue = [];
    const options = typeof optionsOrSize === "number" ? { size: optionsOrSize } : optionsOrSize || {};
    const { size = defaultPoolSize } = options;
    this.debug = (0, import_debug.default)(`threads:pool:${slugify(options.name || String(nextPoolID++))}`);
    this.options = options;
    this.workers = spawnWorkers(spawnWorker, size);
    this.eventObservable = multicast_default(observable_default.from(this.eventSubject));
    Promise.all(this.workers.map((worker) => worker.init)).then(() => this.eventSubject.next({
      type: PoolEventType.initialized,
      size: this.workers.length
    }), (error) => {
      this.debug("Error while initializing pool worker:", error);
      this.eventSubject.error(error);
      this.initErrors.push(error);
    });
  }
  findIdlingWorker() {
    const { concurrency = 1 } = this.options;
    return this.workers.find((worker) => worker.runningTasks.length < concurrency);
  }
  runPoolTask(worker, task) {
    return __awaiter(this, void 0, void 0, function* () {
      const workerID = this.workers.indexOf(worker) + 1;
      this.debug(`Running task #${task.id} on worker #${workerID}...`);
      this.eventSubject.next({
        type: PoolEventType.taskStart,
        taskID: task.id,
        workerID
      });
      try {
        const returnValue = yield task.run(yield worker.init);
        this.debug(`Task #${task.id} completed successfully`);
        this.eventSubject.next({
          type: PoolEventType.taskCompleted,
          returnValue,
          taskID: task.id,
          workerID
        });
      } catch (error) {
        this.debug(`Task #${task.id} failed`);
        this.eventSubject.next({
          type: PoolEventType.taskFailed,
          taskID: task.id,
          error,
          workerID
        });
      }
    });
  }
  run(worker, task) {
    return __awaiter(this, void 0, void 0, function* () {
      const runPromise = (() => __awaiter(this, void 0, void 0, function* () {
        const removeTaskFromWorkersRunningTasks = () => {
          worker.runningTasks = worker.runningTasks.filter((someRunPromise) => someRunPromise !== runPromise);
        };
        yield delay(0);
        try {
          yield this.runPoolTask(worker, task);
        } finally {
          removeTaskFromWorkersRunningTasks();
          if (!this.isClosing) {
            this.scheduleWork();
          }
        }
      }))();
      worker.runningTasks.push(runPromise);
    });
  }
  scheduleWork() {
    this.debug(`Attempt de-queueing a task in order to run it...`);
    const availableWorker = this.findIdlingWorker();
    if (!availableWorker)
      return;
    const nextTask = this.taskQueue.shift();
    if (!nextTask) {
      this.debug(`Task queue is empty`);
      this.eventSubject.next({ type: PoolEventType.taskQueueDrained });
      return;
    }
    this.run(availableWorker, nextTask);
  }
  taskCompletion(taskID) {
    return new Promise((resolve, reject) => {
      const eventSubscription = this.events().subscribe((event) => {
        if (event.type === PoolEventType.taskCompleted && event.taskID === taskID) {
          eventSubscription.unsubscribe();
          resolve(event.returnValue);
        } else if (event.type === PoolEventType.taskFailed && event.taskID === taskID) {
          eventSubscription.unsubscribe();
          reject(event.error);
        } else if (event.type === PoolEventType.terminated) {
          eventSubscription.unsubscribe();
          reject(Error("Pool has been terminated before task was run."));
        }
      });
    });
  }
  settled(allowResolvingImmediately = false) {
    return __awaiter(this, void 0, void 0, function* () {
      const getCurrentlyRunningTasks = () => flatMap(this.workers, (worker) => worker.runningTasks);
      const taskFailures = [];
      const failureSubscription = this.eventObservable.subscribe((event) => {
        if (event.type === PoolEventType.taskFailed) {
          taskFailures.push(event.error);
        }
      });
      if (this.initErrors.length > 0) {
        return Promise.reject(this.initErrors[0]);
      }
      if (allowResolvingImmediately && this.taskQueue.length === 0) {
        yield allSettled(getCurrentlyRunningTasks());
        return taskFailures;
      }
      yield new Promise((resolve, reject) => {
        const subscription = this.eventObservable.subscribe({
          next(event) {
            if (event.type === PoolEventType.taskQueueDrained) {
              subscription.unsubscribe();
              resolve(void 0);
            }
          },
          error: reject
        });
      });
      yield allSettled(getCurrentlyRunningTasks());
      failureSubscription.unsubscribe();
      return taskFailures;
    });
  }
  completed(allowResolvingImmediately = false) {
    return __awaiter(this, void 0, void 0, function* () {
      const settlementPromise = this.settled(allowResolvingImmediately);
      const earlyExitPromise = new Promise((resolve, reject) => {
        const subscription = this.eventObservable.subscribe({
          next(event) {
            if (event.type === PoolEventType.taskQueueDrained) {
              subscription.unsubscribe();
              resolve(settlementPromise);
            } else if (event.type === PoolEventType.taskFailed) {
              subscription.unsubscribe();
              reject(event.error);
            }
          },
          error: reject
        });
      });
      const errors = yield Promise.race([
        settlementPromise,
        earlyExitPromise
      ]);
      if (errors.length > 0) {
        throw errors[0];
      }
    });
  }
  events() {
    return this.eventObservable;
  }
  queue(taskFunction) {
    const { maxQueuedJobs = Infinity } = this.options;
    if (this.isClosing) {
      throw Error(`Cannot schedule pool tasks after terminate() has been called.`);
    }
    if (this.initErrors.length > 0) {
      throw this.initErrors[0];
    }
    const taskID = this.nextTaskID++;
    const taskCompletion = this.taskCompletion(taskID);
    taskCompletion.catch((error) => {
      this.debug(`Task #${taskID} errored:`, error);
    });
    const task = {
      id: taskID,
      run: taskFunction,
      cancel: () => {
        if (this.taskQueue.indexOf(task) === -1)
          return;
        this.taskQueue = this.taskQueue.filter((someTask) => someTask !== task);
        this.eventSubject.next({
          type: PoolEventType.taskCanceled,
          taskID: task.id
        });
      },
      then: taskCompletion.then.bind(taskCompletion)
    };
    if (this.taskQueue.length >= maxQueuedJobs) {
      throw Error("Maximum number of pool tasks queued. Refusing to queue another one.\nThis usually happens for one of two reasons: We are either at peak workload right now or some tasks just won't finish, thus blocking the pool.");
    }
    this.debug(`Queueing task #${task.id}...`);
    this.taskQueue.push(task);
    this.eventSubject.next({
      type: PoolEventType.taskQueued,
      taskID: task.id
    });
    this.scheduleWork();
    return task;
  }
  terminate(force) {
    return __awaiter(this, void 0, void 0, function* () {
      this.isClosing = true;
      if (!force) {
        yield this.completed(true);
      }
      this.eventSubject.next({
        type: PoolEventType.terminated,
        remainingQueue: [...this.taskQueue]
      });
      this.eventSubject.complete();
      yield Promise.all(this.workers.map((worker) => __awaiter(this, void 0, void 0, function* () {
        return Thread.terminate(yield worker.init);
      })));
    });
  }
};
WorkerPool.EventType = PoolEventType;
function PoolConstructor(spawnWorker, optionsOrSize) {
  return new WorkerPool(spawnWorker, optionsOrSize);
}
PoolConstructor.EventType = PoolEventType;
var Pool = PoolConstructor;

// node_modules/threads/dist-esm/master/spawn.js
var import_debug3 = __toModule(require_browser());

// node_modules/threads/dist-esm/promise.js
var doNothing = () => void 0;
function createPromiseWithResolver() {
  let alreadyResolved = false;
  let resolvedTo;
  let resolver = doNothing;
  const promise = new Promise((resolve) => {
    if (alreadyResolved) {
      resolve(resolvedTo);
    } else {
      resolver = resolve;
    }
  });
  const exposedResolver = (value) => {
    alreadyResolved = true;
    resolvedTo = value;
    resolver(resolvedTo);
  };
  return [promise, exposedResolver];
}

// node_modules/threads/dist-esm/types/master.js
var WorkerEventType;
(function(WorkerEventType2) {
  WorkerEventType2["internalError"] = "internalError";
  WorkerEventType2["message"] = "message";
  WorkerEventType2["termination"] = "termination";
})(WorkerEventType || (WorkerEventType = {}));

// node_modules/threads/dist-esm/master/invocation-proxy.js
var import_debug2 = __toModule(require_browser());

// node_modules/threads/dist-esm/observable-promise.js
var doNothing2 = () => void 0;
var returnInput = (input) => input;
var runDeferred = (fn) => Promise.resolve().then(fn);
function fail2(error) {
  throw error;
}
function isThenable(thing) {
  return thing && typeof thing.then === "function";
}
var ObservablePromise = class extends observable_default {
  constructor(init) {
    super((originalObserver) => {
      const self2 = this;
      const observer = Object.assign(Object.assign({}, originalObserver), {
        complete() {
          originalObserver.complete();
          self2.onCompletion();
        },
        error(error) {
          originalObserver.error(error);
          self2.onError(error);
        },
        next(value) {
          originalObserver.next(value);
          self2.onNext(value);
        }
      });
      try {
        this.initHasRun = true;
        return init(observer);
      } catch (error) {
        observer.error(error);
      }
    });
    this.initHasRun = false;
    this.fulfillmentCallbacks = [];
    this.rejectionCallbacks = [];
    this.firstValueSet = false;
    this.state = "pending";
  }
  onNext(value) {
    if (!this.firstValueSet) {
      this.firstValue = value;
      this.firstValueSet = true;
    }
  }
  onError(error) {
    this.state = "rejected";
    this.rejection = error;
    for (const onRejected of this.rejectionCallbacks) {
      runDeferred(() => onRejected(error));
    }
  }
  onCompletion() {
    this.state = "fulfilled";
    for (const onFulfilled of this.fulfillmentCallbacks) {
      runDeferred(() => onFulfilled(this.firstValue));
    }
  }
  then(onFulfilledRaw, onRejectedRaw) {
    const onFulfilled = onFulfilledRaw || returnInput;
    const onRejected = onRejectedRaw || fail2;
    let onRejectedCalled = false;
    return new Promise((resolve, reject) => {
      const rejectionCallback = (error) => {
        if (onRejectedCalled)
          return;
        onRejectedCalled = true;
        try {
          resolve(onRejected(error));
        } catch (anotherError) {
          reject(anotherError);
        }
      };
      const fulfillmentCallback = (value) => {
        try {
          resolve(onFulfilled(value));
        } catch (error) {
          rejectionCallback(error);
        }
      };
      if (!this.initHasRun) {
        this.subscribe({ error: rejectionCallback });
      }
      if (this.state === "fulfilled") {
        return resolve(onFulfilled(this.firstValue));
      }
      if (this.state === "rejected") {
        onRejectedCalled = true;
        return resolve(onRejected(this.rejection));
      }
      this.fulfillmentCallbacks.push(fulfillmentCallback);
      this.rejectionCallbacks.push(rejectionCallback);
    });
  }
  catch(onRejected) {
    return this.then(void 0, onRejected);
  }
  finally(onCompleted) {
    const handler2 = onCompleted || doNothing2;
    return this.then((value) => {
      handler2();
      return value;
    }, () => handler2());
  }
  static from(thing) {
    if (isThenable(thing)) {
      return new ObservablePromise((observer) => {
        const onFulfilled = (value) => {
          observer.next(value);
          observer.complete();
        };
        const onRejected = (error) => {
          observer.error(error);
        };
        thing.then(onFulfilled, onRejected);
      });
    } else {
      return super.from(thing);
    }
  }
};

// node_modules/threads/dist-esm/transferable.js
function isTransferable(thing) {
  if (!thing || typeof thing !== "object")
    return false;
  return true;
}
function isTransferDescriptor(thing) {
  return thing && typeof thing === "object" && thing[$transferable];
}
function Transfer(payload, transferables) {
  if (!transferables) {
    if (!isTransferable(payload))
      throw Error();
    transferables = [payload];
  }
  return {
    [$transferable]: true,
    send: payload,
    transferables
  };
}

// node_modules/threads/dist-esm/types/messages.js
var MasterMessageType;
(function(MasterMessageType2) {
  MasterMessageType2["cancel"] = "cancel";
  MasterMessageType2["run"] = "run";
})(MasterMessageType || (MasterMessageType = {}));
var WorkerMessageType;
(function(WorkerMessageType2) {
  WorkerMessageType2["error"] = "error";
  WorkerMessageType2["init"] = "init";
  WorkerMessageType2["result"] = "result";
  WorkerMessageType2["running"] = "running";
  WorkerMessageType2["uncaughtError"] = "uncaughtError";
})(WorkerMessageType || (WorkerMessageType = {}));

// node_modules/threads/dist-esm/master/invocation-proxy.js
var debugMessages = (0, import_debug2.default)("threads:master:messages");
var nextJobUID = 1;
var dedupe = (array) => Array.from(new Set(array));
var isJobErrorMessage = (data) => data && data.type === WorkerMessageType.error;
var isJobResultMessage = (data) => data && data.type === WorkerMessageType.result;
var isJobStartMessage = (data) => data && data.type === WorkerMessageType.running;
function createObservableForJob(worker, jobUID) {
  return new observable_default((observer) => {
    let asyncType;
    const messageHandler = (event) => {
      debugMessages("Message from worker:", event.data);
      if (!event.data || event.data.uid !== jobUID)
        return;
      if (isJobStartMessage(event.data)) {
        asyncType = event.data.resultType;
      } else if (isJobResultMessage(event.data)) {
        if (asyncType === "promise") {
          if (typeof event.data.payload !== "undefined") {
            observer.next(deserialize(event.data.payload));
          }
          observer.complete();
          worker.removeEventListener("message", messageHandler);
        } else {
          if (event.data.payload) {
            observer.next(deserialize(event.data.payload));
          }
          if (event.data.complete) {
            observer.complete();
            worker.removeEventListener("message", messageHandler);
          }
        }
      } else if (isJobErrorMessage(event.data)) {
        const error = deserialize(event.data.error);
        if (asyncType === "promise" || !asyncType) {
          observer.error(error);
        } else {
          observer.error(error);
        }
        worker.removeEventListener("message", messageHandler);
      }
    };
    worker.addEventListener("message", messageHandler);
    return () => {
      if (asyncType === "observable" || !asyncType) {
        const cancelMessage = {
          type: MasterMessageType.cancel,
          uid: jobUID
        };
        worker.postMessage(cancelMessage);
      }
      worker.removeEventListener("message", messageHandler);
    };
  });
}
function prepareArguments(rawArgs) {
  if (rawArgs.length === 0) {
    return {
      args: [],
      transferables: []
    };
  }
  const args = [];
  const transferables = [];
  for (const arg of rawArgs) {
    if (isTransferDescriptor(arg)) {
      args.push(serialize(arg.send));
      transferables.push(...arg.transferables);
    } else {
      args.push(serialize(arg));
    }
  }
  return {
    args,
    transferables: transferables.length === 0 ? transferables : dedupe(transferables)
  };
}
function createProxyFunction(worker, method) {
  return (...rawArgs) => {
    const uid = nextJobUID++;
    const { args, transferables } = prepareArguments(rawArgs);
    const runMessage = {
      type: MasterMessageType.run,
      uid,
      method,
      args
    };
    debugMessages("Sending command to run function to worker:", runMessage);
    try {
      worker.postMessage(runMessage, transferables);
    } catch (error) {
      return ObservablePromise.from(Promise.reject(error));
    }
    return ObservablePromise.from(multicast_default(createObservableForJob(worker, uid)));
  };
}
function createProxyModule(worker, methodNames) {
  const proxy = {};
  for (const methodName of methodNames) {
    proxy[methodName] = createProxyFunction(worker, methodName);
  }
  return proxy;
}

// node_modules/threads/dist-esm/master/spawn.js
var __awaiter2 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var debugMessages2 = (0, import_debug3.default)("threads:master:messages");
var debugSpawn = (0, import_debug3.default)("threads:master:spawn");
var debugThreadUtils = (0, import_debug3.default)("threads:master:thread-utils");
var isInitMessage = (data) => data && data.type === "init";
var isUncaughtErrorMessage = (data) => data && data.type === "uncaughtError";
var initMessageTimeout = typeof process !== "undefined" && process.env.THREADS_WORKER_INIT_TIMEOUT ? Number.parseInt(process.env.THREADS_WORKER_INIT_TIMEOUT, 10) : 1e4;
function withTimeout(promise, timeoutInMs, errorMessage) {
  return __awaiter2(this, void 0, void 0, function* () {
    let timeoutHandle;
    const timeout = new Promise((resolve, reject) => {
      timeoutHandle = setTimeout(() => reject(Error(errorMessage)), timeoutInMs);
    });
    const result = yield Promise.race([
      promise,
      timeout
    ]);
    clearTimeout(timeoutHandle);
    return result;
  });
}
function receiveInitMessage(worker) {
  return new Promise((resolve, reject) => {
    const messageHandler = (event) => {
      debugMessages2("Message from worker before finishing initialization:", event.data);
      if (isInitMessage(event.data)) {
        worker.removeEventListener("message", messageHandler);
        resolve(event.data);
      } else if (isUncaughtErrorMessage(event.data)) {
        worker.removeEventListener("message", messageHandler);
        reject(deserialize(event.data.error));
      }
    };
    worker.addEventListener("message", messageHandler);
  });
}
function createEventObservable(worker, workerTermination) {
  return new observable_default((observer) => {
    const messageHandler = (messageEvent) => {
      const workerEvent = {
        type: WorkerEventType.message,
        data: messageEvent.data
      };
      observer.next(workerEvent);
    };
    const rejectionHandler = (errorEvent) => {
      debugThreadUtils("Unhandled promise rejection event in thread:", errorEvent);
      const workerEvent = {
        type: WorkerEventType.internalError,
        error: Error(errorEvent.reason)
      };
      observer.next(workerEvent);
    };
    worker.addEventListener("message", messageHandler);
    worker.addEventListener("unhandledrejection", rejectionHandler);
    workerTermination.then(() => {
      const terminationEvent = {
        type: WorkerEventType.termination
      };
      worker.removeEventListener("message", messageHandler);
      worker.removeEventListener("unhandledrejection", rejectionHandler);
      observer.next(terminationEvent);
      observer.complete();
    });
  });
}
function createTerminator(worker) {
  const [termination, resolver] = createPromiseWithResolver();
  const terminate = () => __awaiter2(this, void 0, void 0, function* () {
    debugThreadUtils("Terminating worker");
    yield worker.terminate();
    resolver();
  });
  return { terminate, termination };
}
function setPrivateThreadProps(raw, worker, workerEvents, terminate) {
  const workerErrors = workerEvents.filter((event) => event.type === WorkerEventType.internalError).map((errorEvent) => errorEvent.error);
  return Object.assign(raw, {
    [$errors]: workerErrors,
    [$events]: workerEvents,
    [$terminate]: terminate,
    [$worker]: worker
  });
}
function spawn(worker, options) {
  return __awaiter2(this, void 0, void 0, function* () {
    debugSpawn("Initializing new thread");
    const timeout = options && options.timeout ? options.timeout : initMessageTimeout;
    const initMessage = yield withTimeout(receiveInitMessage(worker), timeout, `Timeout: Did not receive an init message from worker after ${timeout}ms. Make sure the worker calls expose().`);
    const exposed = initMessage.exposed;
    const { termination, terminate } = createTerminator(worker);
    const events = createEventObservable(worker, termination);
    if (exposed.type === "function") {
      const proxy = createProxyFunction(worker);
      return setPrivateThreadProps(proxy, worker, events, terminate);
    } else if (exposed.type === "module") {
      const proxy = createProxyModule(worker, exposed.methods);
      return setPrivateThreadProps(proxy, worker, events, terminate);
    } else {
      const type = exposed.type;
      throw Error(`Worker init message states unexpected type of expose(): ${type}`);
    }
  });
}

// node_modules/threads/dist-esm/master/index.js
var BlobWorker = getWorkerImplementation().blob;
var Worker2 = getWorkerImplementation().default;

// node_modules/threads/dist-esm/worker/index.js
var import_is_observable = __toModule(require_is_observable());

// node_modules/threads/dist-esm/worker/implementation.browser.js
var isWorkerRuntime2 = function isWorkerRuntime3() {
  const isWindowContext = typeof self !== "undefined" && typeof Window !== "undefined" && self instanceof Window;
  return typeof self !== "undefined" && self.postMessage && !isWindowContext ? true : false;
};
var postMessageToMaster = function postMessageToMaster2(data, transferList) {
  self.postMessage(data, transferList);
};
var subscribeToMasterMessages = function subscribeToMasterMessages2(onMessage) {
  const messageHandler = (messageEvent) => {
    onMessage(messageEvent.data);
  };
  const unsubscribe2 = () => {
    self.removeEventListener("message", messageHandler);
  };
  self.addEventListener("message", messageHandler);
  return unsubscribe2;
};
var implementation_browser_default = {
  isWorkerRuntime: isWorkerRuntime2,
  postMessageToMaster,
  subscribeToMasterMessages
};

// node_modules/threads/dist-esm/worker/index.js
var isWorkerRuntime4 = implementation_browser_default.isWorkerRuntime;
var activeSubscriptions = new Map();
function postUncaughtErrorMessage(error) {
  try {
    const errorMessage = {
      type: WorkerMessageType.uncaughtError,
      error: serialize(error)
    };
    implementation_browser_default.postMessageToMaster(errorMessage);
  } catch (subError) {
    console.error("Not reporting uncaught error back to master thread as it occured while reporting an uncaught error already.\nLatest error:", subError, "\nOriginal error:", error);
  }
}
if (typeof self !== "undefined" && typeof self.addEventListener === "function" && implementation_browser_default.isWorkerRuntime()) {
  self.addEventListener("error", (event) => {
    setTimeout(() => postUncaughtErrorMessage(event.error || event), 250);
  });
  self.addEventListener("unhandledrejection", (event) => {
    const error = event.reason;
    if (error && typeof error.message === "string") {
      setTimeout(() => postUncaughtErrorMessage(error), 250);
    }
  });
}
if (typeof process !== "undefined" && typeof process.on === "function" && implementation_browser_default.isWorkerRuntime()) {
  process.on("uncaughtException", (error) => {
    setTimeout(() => postUncaughtErrorMessage(error), 250);
  });
  process.on("unhandledRejection", (error) => {
    if (error && typeof error.message === "string") {
      setTimeout(() => postUncaughtErrorMessage(error), 250);
    }
  });
}

// node_modules/geotiff/src/pool.js
var defaultPoolSize2 = typeof navigator !== "undefined" ? navigator.hardwareConcurrency : null;
var Pool2 = class {
  constructor(size = defaultPoolSize2, worker = new Worker2("./decoder.worker.js")) {
    this.pool = Pool(() => spawn(worker), size);
  }
  async decode(fileDirectory, buffer4) {
    return new Promise((resolve, reject) => {
      this.pool.queue(async (decode) => {
        try {
          const data = await decode(fileDirectory, Transfer(buffer4));
          resolve(data);
        } catch (err) {
          reject(err);
        }
      });
    });
  }
  destroy() {
    this.pool.terminate(true);
  }
};
var pool_default = Pool2;

// node_modules/geotiff/src/source/httputils.js
var CRLFCRLF = "\r\n\r\n";
function itemsToObject(items) {
  if (typeof Object.fromEntries !== "undefined") {
    return Object.fromEntries(items);
  }
  const obj = {};
  for (const [key, value] of items) {
    obj[key.toLowerCase()] = value;
  }
  return obj;
}
function parseHeaders(text) {
  const items = text.split("\r\n").map((line) => {
    const kv = line.split(":").map((str) => str.trim());
    kv[0] = kv[0].toLowerCase();
    return kv;
  });
  return itemsToObject(items);
}
function parseContentType(rawContentType) {
  const [type, ...rawParams] = rawContentType.split(";").map((s) => s.trim());
  const paramsItems = rawParams.map((param) => param.split("="));
  return { type, params: itemsToObject(paramsItems) };
}
function parseContentRange(rawContentRange) {
  let start;
  let end;
  let total;
  if (rawContentRange) {
    [, start, end, total] = rawContentRange.match(/bytes (\d+)-(\d+)\/(\d+)/);
    start = parseInt(start, 10);
    end = parseInt(end, 10);
    total = parseInt(total, 10);
  }
  return { start, end, total };
}
function parseByteRanges(responseArrayBuffer, boundary) {
  let offset = null;
  const decoder = new TextDecoder("ascii");
  const out = [];
  const startBoundary = `--${boundary}`;
  const endBoundary = `${startBoundary}--`;
  for (let i = 0; i < 10; ++i) {
    const text = decoder.decode(new Uint8Array(responseArrayBuffer, i, startBoundary.length));
    if (text === startBoundary) {
      offset = i;
    }
  }
  if (offset === null) {
    throw new Error("Could not find initial boundary");
  }
  while (offset < responseArrayBuffer.byteLength) {
    const text = decoder.decode(new Uint8Array(responseArrayBuffer, offset, Math.min(startBoundary.length + 1024, responseArrayBuffer.byteLength - offset)));
    if (text.length === 0 || text.startsWith(endBoundary)) {
      break;
    }
    if (!text.startsWith(startBoundary)) {
      throw new Error("Part does not start with boundary");
    }
    const innerText = text.substr(startBoundary.length + 2);
    if (innerText.length === 0) {
      break;
    }
    const endOfHeaders = innerText.indexOf(CRLFCRLF);
    const headers = parseHeaders(innerText.substr(0, endOfHeaders));
    const { start, end, total } = parseContentRange(headers["content-range"]);
    const startOfData = offset + startBoundary.length + endOfHeaders + CRLFCRLF.length;
    const length = parseInt(end, 10) + 1 - parseInt(start, 10);
    out.push({
      headers,
      data: responseArrayBuffer.slice(startOfData, startOfData + length),
      offset: start,
      length,
      fileSize: total
    });
    offset = startOfData + length + 4;
  }
  return out;
}

// node_modules/geotiff/src/source/basesource.js
var BaseSource = class {
  async fetch(slices, signal = void 0) {
    return Promise.all(slices.map((slice) => this.fetchSlice(slice, signal)));
  }
  async fetchSlice(slice) {
    throw new Error(`fetching of slice ${slice} not possible, not implemented`);
  }
  get fileSize() {
    return null;
  }
  async close() {
  }
};

// node_modules/geotiff/src/source/blockedsource.js
var import_lru_cache = __toModule(require_lru_cache());

// node_modules/geotiff/src/utils.js
function assign2(target, source2) {
  for (const key in source2) {
    if (source2.hasOwnProperty(key)) {
      target[key] = source2[key];
    }
  }
}
function invert(oldObj) {
  const newObj = {};
  for (const key in oldObj) {
    if (oldObj.hasOwnProperty(key)) {
      const value = oldObj[key];
      newObj[value] = key;
    }
  }
  return newObj;
}
function times(numTimes, func) {
  const results = [];
  for (let i = 0; i < numTimes; i++) {
    results.push(func(i));
  }
  return results;
}
async function wait(milliseconds) {
  return new Promise((resolve) => setTimeout(resolve, milliseconds));
}
function zip(a, b) {
  const A = Array.isArray(a) ? a : Array.from(a);
  const B = Array.isArray(b) ? b : Array.from(b);
  return A.map((k, i) => [k, B[i]]);
}
var AbortError = class extends Error {
  constructor(params) {
    super(params);
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, AbortError);
    }
    this.name = "AbortError";
  }
};
var CustomAggregateError = class extends Error {
  constructor(errors, message) {
    super(message);
    this.errors = errors;
    this.message = message;
    this.name = "AggregateError";
  }
};
var AggregateError = CustomAggregateError;

// node_modules/geotiff/src/source/blockedsource.js
var Block = class {
  constructor(offset, length, data = null) {
    this.offset = offset;
    this.length = length;
    this.data = data;
  }
  get top() {
    return this.offset + this.length;
  }
};
var BlockGroup = class {
  constructor(offset, length, blockIds) {
    this.offset = offset;
    this.length = length;
    this.blockIds = blockIds;
  }
};
var BlockedSource = class extends BaseSource {
  constructor(source2, { blockSize = 65536, cacheSize = 100 } = {}) {
    super();
    this.source = source2;
    this.blockSize = blockSize;
    this.blockCache = new import_lru_cache.default({ max: cacheSize });
    this.blockRequests = new Map();
    this.blockIdsToFetch = new Set();
  }
  get fileSize() {
    return this.source.fileSize;
  }
  async fetch(slices, signal) {
    const cachedBlocks = new Map();
    const blockRequests = new Map();
    const missingBlockIds = new Set();
    for (const { offset, length } of slices) {
      let top = offset + length;
      const { fileSize } = this;
      if (fileSize !== null) {
        top = Math.min(top, fileSize);
      }
      const firstBlockOffset = Math.floor(offset / this.blockSize) * this.blockSize;
      for (let current = firstBlockOffset; current < top; current += this.blockSize) {
        const blockId = Math.floor(current / this.blockSize);
        if (this.blockCache.has(blockId)) {
          cachedBlocks.set(blockId, this.blockCache.get(blockId));
        } else if (this.blockRequests.has(blockId)) {
          blockRequests.set(blockId, this.blockRequests.get(blockId));
        } else if (this.blockIdsToFetch.has(blockId)) {
          missingBlockIds.add(blockId);
        } else {
          this.blockIdsToFetch.add(blockId);
          missingBlockIds.add(blockId);
        }
      }
    }
    await wait();
    this.fetchBlocks(signal);
    for (const blockId of missingBlockIds) {
      const block = this.blockRequests.get(blockId);
      const cachedBlock = this.blockCache.get(blockId);
      if (block) {
        blockRequests.set(blockId, block);
      } else if (cachedBlock) {
        cachedBlocks.set(blockId, cachedBlock);
      } else {
        throw new Error(`Block ${blockId} is not in the block requests`);
      }
    }
    let results = await Promise.allSettled(blockRequests.values());
    if (results.some((result) => result.status === "rejected")) {
      const retriedBlockRequests = new Set();
      for (const [blockId, result] of zip(blockRequests.keys(), results)) {
        const { rejected, reason } = result;
        if (rejected) {
          if (reason.name === "AbortError" && reason.signal !== signal) {
            this.blockIdsToFetch.add(blockId);
            retriedBlockRequests.add(blockId);
          }
        }
      }
      if (this.blockIdsToFetch.length > 0) {
        this.fetchBlocks(signal);
        for (const blockId of retriedBlockRequests) {
          const block = this.blockRequests.get(blockId);
          if (!block) {
            throw new Error(`Block ${blockId} is not in the block requests`);
          }
          blockRequests.set(blockId, block);
        }
        results = await Promise.allSettled(Array.from(blockRequests.values()));
      }
    }
    if (results.some((result) => result.status === "rejected")) {
      if (signal && signal.aborted) {
        throw new AbortError("Request was aborted");
      }
      throw new AggregateError(results.filter((result) => result.status === "rejected").map((result) => result.reason), "Request failed");
    }
    const values = results.map((result) => result.value);
    const requiredBlocks = new Map(zip(Array.from(blockRequests.keys()), values));
    for (const [blockId, block] of cachedBlocks) {
      requiredBlocks.set(blockId, block);
    }
    return this.readSliceData(slices, requiredBlocks);
  }
  fetchBlocks(signal) {
    if (this.blockIdsToFetch.size > 0) {
      const groups = this.groupBlocks(this.blockIdsToFetch);
      const groupRequests = this.source.fetch(groups, signal);
      for (let groupIndex = 0; groupIndex < groups.length; ++groupIndex) {
        const group = groups[groupIndex];
        for (const blockId of group.blockIds) {
          const blockRequest = (async () => {
            try {
              const response = (await groupRequests)[groupIndex];
              const blockOffset = blockId * this.blockSize;
              const o = blockOffset - response.offset;
              const t = Math.min(o + this.blockSize, response.data.byteLength);
              const data = response.data.slice(o, t);
              const block = new Block(blockOffset, data.byteLength, data);
              this.blockCache.set(blockId, block);
              return block;
            } catch (err) {
              if (err.name === "AbortError") {
                err.signal = signal;
              }
              throw err;
            } finally {
              this.blockRequests.delete(blockId);
            }
          })();
          this.blockRequests.set(blockId, blockRequest);
        }
      }
      this.blockIdsToFetch.clear();
    }
  }
  groupBlocks(blockIds) {
    const sortedBlockIds = Array.from(blockIds).sort((a, b) => a - b);
    if (sortedBlockIds.length === 0) {
      return [];
    }
    let current = [];
    let lastBlockId = null;
    const groups = [];
    for (const blockId of sortedBlockIds) {
      if (lastBlockId === null || lastBlockId + 1 === blockId) {
        current.push(blockId);
        lastBlockId = blockId;
      } else {
        groups.push(new BlockGroup(current[0] * this.blockSize, current.length * this.blockSize, current));
        current = [blockId];
        lastBlockId = blockId;
      }
    }
    groups.push(new BlockGroup(current[0] * this.blockSize, current.length * this.blockSize, current));
    return groups;
  }
  readSliceData(slices, blocks) {
    return slices.map((slice) => {
      const top = slice.offset + slice.length;
      const blockIdLow = Math.floor(slice.offset / this.blockSize);
      const blockIdHigh = Math.floor((slice.offset + slice.length) / this.blockSize);
      const sliceData = new ArrayBuffer(slice.length);
      const sliceView = new Uint8Array(sliceData);
      for (let blockId = blockIdLow; blockId <= blockIdHigh; ++blockId) {
        const block = blocks.get(blockId);
        const delta = block.offset - slice.offset;
        const topDelta = block.top - top;
        let blockInnerOffset = 0;
        let rangeInnerOffset = 0;
        let usedBlockLength;
        if (delta < 0) {
          blockInnerOffset = -delta;
        } else if (delta > 0) {
          rangeInnerOffset = delta;
        }
        if (topDelta < 0) {
          usedBlockLength = block.length - blockInnerOffset;
        } else {
          usedBlockLength = top - block.offset - blockInnerOffset;
        }
        const blockView = new Uint8Array(block.data, blockInnerOffset, usedBlockLength);
        sliceView.set(blockView, rangeInnerOffset);
      }
      return sliceData;
    });
  }
};

// node_modules/geotiff/src/source/client/base.js
var BaseResponse = class {
  get ok() {
    return this.status >= 200 && this.status <= 299;
  }
  get status() {
    throw new Error("not implemented");
  }
  getHeader(headerName) {
    throw new Error("not implemented");
  }
  async getData() {
    throw new Error("not implemented");
  }
};
var BaseClient = class {
  constructor(url2) {
    this.url = url2;
  }
  async request({ headers, credentials, signal } = {}) {
    throw new Error("request is not implemented");
  }
};

// node_modules/geotiff/src/source/client/fetch.js
var FetchResponse = class extends BaseResponse {
  constructor(response) {
    super();
    this.response = response;
  }
  get status() {
    return this.response.status;
  }
  getHeader(name) {
    return this.response.headers.get(name);
  }
  async getData() {
    const data = this.response.arrayBuffer ? await this.response.arrayBuffer() : (await this.response.buffer()).buffer;
    return data;
  }
};
var FetchClient = class extends BaseClient {
  constructor(url2, credentials) {
    super(url2);
    this.credentials = credentials;
  }
  async request({ headers, credentials, signal } = {}) {
    const response = await fetch(this.url, {
      headers,
      credentials,
      signal
    });
    return new FetchResponse(response);
  }
};

// node_modules/geotiff/src/source/client/xhr.js
var XHRResponse = class extends BaseResponse {
  constructor(xhr, data) {
    super();
    this.xhr = xhr;
    this.data = data;
  }
  get status() {
    return this.xhr.status;
  }
  getHeader(name) {
    return this.xhr.getResponseHeader(name);
  }
  async getData() {
    return this.data;
  }
};
var XHRClient = class extends BaseClient {
  constructRequest(headers, signal) {
    return new Promise((resolve, reject) => {
      const xhr = new XMLHttpRequest();
      xhr.open("GET", this.url);
      xhr.responseType = "arraybuffer";
      for (const [key, value] of Object.entries(headers)) {
        xhr.setRequestHeader(key, value);
      }
      xhr.onload = () => {
        const data = xhr.response;
        resolve(new XHRResponse(xhr, data));
      };
      xhr.onerror = reject;
      xhr.onabort = () => reject(new AbortError("Request aborted"));
      xhr.send();
      if (signal) {
        if (signal.aborted) {
          xhr.abort();
        }
        signal.addEventListener("abort", () => xhr.abort());
      }
    });
  }
  async request({ headers, signal } = {}) {
    const response = await this.constructRequest(headers, signal);
    return response;
  }
};

// browser-external:http
var http_default = new Proxy({}, {
  get() {
    throw new Error('Module "http" has been externalized for browser compatibility and cannot be accessed in client code.');
  }
});

// browser-external:https
var https_default = new Proxy({}, {
  get() {
    throw new Error('Module "https" has been externalized for browser compatibility and cannot be accessed in client code.');
  }
});

// browser-external:url
var url_default = new Proxy({}, {
  get() {
    throw new Error('Module "url" has been externalized for browser compatibility and cannot be accessed in client code.');
  }
});

// node_modules/geotiff/src/source/client/http.js
var HttpResponse = class extends BaseResponse {
  constructor(response, dataPromise) {
    super();
    this.response = response;
    this.dataPromise = dataPromise;
  }
  get status() {
    return this.response.statusCode;
  }
  getHeader(name) {
    return this.response.headers[name];
  }
  async getData() {
    const data = await this.dataPromise;
    return data;
  }
};
var HttpClient = class extends BaseClient {
  constructor(url2) {
    super(url2);
    this.parsedUrl = url_default.parse(this.url);
    this.httpApi = this.parsedUrl.protocol === "http:" ? http_default : https_default;
  }
  constructRequest(headers, signal) {
    return new Promise((resolve, reject) => {
      const request = this.httpApi.get(__spreadProps(__spreadValues({}, this.parsedUrl), {
        headers
      }), (response) => {
        const dataPromise = new Promise((resolveData) => {
          const chunks = [];
          response.on("data", (chunk) => {
            chunks.push(chunk);
          });
          response.on("end", () => {
            const data = Buffer.concat(chunks).buffer;
            resolveData(data);
          });
          response.on("error", reject);
        });
        resolve(new HttpResponse(response, dataPromise));
      });
      request.on("error", reject);
      if (signal) {
        if (signal.aborted) {
          request.destroy(new AbortError("Request aborted"));
        }
        signal.addEventListener("abort", () => request.destroy(new AbortError("Request aborted")));
      }
    });
  }
  async request({ headers, signal } = {}) {
    const response = await this.constructRequest(headers, signal);
    return response;
  }
};

// node_modules/geotiff/src/source/remote.js
var RemoteSource = class extends BaseSource {
  constructor(client, headers, maxRanges, allowFullFile) {
    super();
    this.client = client;
    this.headers = headers;
    this.maxRanges = maxRanges;
    this.allowFullFile = allowFullFile;
    this._fileSize = null;
  }
  async fetch(slices, signal) {
    if (this.maxRanges >= slices.length) {
      return this.fetchSlices(slices, signal);
    } else if (this.maxRanges > 0 && slices.length > 1) {
    }
    return Promise.all(slices.map((slice) => this.fetchSlice(slice, signal)));
  }
  async fetchSlices(slices, signal) {
    const response = await this.client.request({
      headers: __spreadProps(__spreadValues({}, this.headers), {
        Range: `bytes=${slices.map(({ offset, length }) => `${offset}-${offset + length}`).join(",")}`
      }),
      signal
    });
    if (!response.ok) {
      throw new Error("Error fetching data.");
    } else if (response.status === 206) {
      const { type, params } = parseContentType(response.getHeader("content-type"));
      if (type === "multipart/byteranges") {
        const byteRanges = parseByteRanges(await response.getData(), params.boundary);
        this._fileSize = byteRanges[0].fileSize || null;
        return byteRanges;
      }
      const data = await response.getData();
      const { start, end, total } = parseContentRange(response.getHeader("content-range"));
      this._fileSize = total || null;
      const first = [{
        data,
        offset: start,
        length: end - start
      }];
      if (slices.length > 1) {
        const others = await Promise.all(slices.slice(1).map((slice) => this.fetchSlice(slice, signal)));
        return first.concat(others);
      }
      return first;
    } else {
      if (!this.allowFullFile) {
        throw new Error("Server responded with full file");
      }
      const data = await response.getData();
      this._fileSize = data.byteLength;
      return [{
        data,
        offset: 0,
        length: data.byteLength
      }];
    }
  }
  async fetchSlice(slice, signal) {
    const { offset, length } = slice;
    const response = await this.client.request({
      headers: __spreadProps(__spreadValues({}, this.headers), {
        Range: `bytes=${offset}-${offset + length}`
      }),
      signal
    });
    if (!response.ok) {
      throw new Error("Error fetching data.");
    } else if (response.status === 206) {
      const data = await response.getData();
      const { total } = parseContentRange(response.getHeader("content-range"));
      this._fileSize = total || null;
      return {
        data,
        offset,
        length
      };
    } else {
      if (!this.allowFullFile) {
        throw new Error("Server responded with full file");
      }
      const data = await response.getData();
      this._fileSize = data.byteLength;
      return {
        data,
        offset: 0,
        length: data.byteLength
      };
    }
  }
  get fileSize() {
    return this._fileSize;
  }
};
function maybeWrapInBlockedSource(source2, { blockSize, cacheSize }) {
  if (blockSize === null) {
    return source2;
  }
  return new BlockedSource(source2, blockSize, cacheSize);
}
function makeFetchSource(url2, _a = {}) {
  var _b = _a, { headers = {}, credentials, maxRanges = 0, allowFullFile = false } = _b, blockOptions = __objRest(_b, ["headers", "credentials", "maxRanges", "allowFullFile"]);
  const client = new FetchClient(url2, credentials);
  const source2 = new RemoteSource(client, headers, maxRanges, allowFullFile);
  return maybeWrapInBlockedSource(source2, blockOptions);
}
function makeXHRSource(url2, _a = {}) {
  var _b = _a, { headers = {}, maxRanges = 0, allowFullFile = false } = _b, blockOptions = __objRest(_b, ["headers", "maxRanges", "allowFullFile"]);
  const client = new XHRClient(url2);
  const source2 = new RemoteSource(client, headers, maxRanges, allowFullFile);
  return maybeWrapInBlockedSource(source2, blockOptions);
}
function makeHttpSource(url2, _a = {}) {
  var _b = _a, { headers = {}, maxRanges = 0, allowFullFile = false } = _b, blockOptions = __objRest(_b, ["headers", "maxRanges", "allowFullFile"]);
  const client = new HttpClient(url2);
  const source2 = new RemoteSource(client, headers, maxRanges, allowFullFile);
  return maybeWrapInBlockedSource(source2, blockOptions);
}
function makeRemoteSource(url2, _a = {}) {
  var _b = _a, { forceXHR = false } = _b, clientOptions = __objRest(_b, ["forceXHR"]);
  if (typeof fetch === "function" && !forceXHR) {
    return makeFetchSource(url2, clientOptions);
  }
  if (typeof XMLHttpRequest !== "undefined") {
    return makeXHRSource(url2, clientOptions);
  }
  return makeHttpSource(url2, clientOptions);
}

// browser-external:fs
var fs_default = new Proxy({}, {
  get() {
    throw new Error('Module "fs" has been externalized for browser compatibility and cannot be accessed in client code.');
  }
});

// node_modules/geotiff/src/geotiffwriter.js
var tagName2Code = invert(fieldTagNames);
var geoKeyName2Code = invert(geoKeyNames);
var name2code = {};
assign2(name2code, tagName2Code);
assign2(name2code, geoKeyName2Code);
var typeName2byte = invert(fieldTypeNames);
var _binBE = {
  nextZero: (data, o) => {
    let oincr = o;
    while (data[oincr] !== 0) {
      oincr++;
    }
    return oincr;
  },
  readUshort: (buff, p) => {
    return buff[p] << 8 | buff[p + 1];
  },
  readShort: (buff, p) => {
    const a = _binBE.ui8;
    a[0] = buff[p + 1];
    a[1] = buff[p + 0];
    return _binBE.i16[0];
  },
  readInt: (buff, p) => {
    const a = _binBE.ui8;
    a[0] = buff[p + 3];
    a[1] = buff[p + 2];
    a[2] = buff[p + 1];
    a[3] = buff[p + 0];
    return _binBE.i32[0];
  },
  readUint: (buff, p) => {
    const a = _binBE.ui8;
    a[0] = buff[p + 3];
    a[1] = buff[p + 2];
    a[2] = buff[p + 1];
    a[3] = buff[p + 0];
    return _binBE.ui32[0];
  },
  readASCII: (buff, p, l) => {
    return l.map((i) => String.fromCharCode(buff[p + i])).join("");
  },
  readFloat: (buff, p) => {
    const a = _binBE.ui8;
    times(4, (i) => {
      a[i] = buff[p + 3 - i];
    });
    return _binBE.fl32[0];
  },
  readDouble: (buff, p) => {
    const a = _binBE.ui8;
    times(8, (i) => {
      a[i] = buff[p + 7 - i];
    });
    return _binBE.fl64[0];
  },
  writeUshort: (buff, p, n) => {
    buff[p] = n >> 8 & 255;
    buff[p + 1] = n & 255;
  },
  writeUint: (buff, p, n) => {
    buff[p] = n >> 24 & 255;
    buff[p + 1] = n >> 16 & 255;
    buff[p + 2] = n >> 8 & 255;
    buff[p + 3] = n >> 0 & 255;
  },
  writeASCII: (buff, p, s) => {
    times(s.length, (i) => {
      buff[p + i] = s.charCodeAt(i);
    });
  },
  ui8: new Uint8Array(8)
};
_binBE.fl64 = new Float64Array(_binBE.ui8.buffer);
_binBE.writeDouble = (buff, p, n) => {
  _binBE.fl64[0] = n;
  times(8, (i) => {
    buff[p + i] = _binBE.ui8[7 - i];
  });
};

// node_modules/geotiff/src/logging.js
var DummyLogger = class {
  log() {
  }
  debug() {
  }
  info() {
  }
  warn() {
  }
  error() {
  }
  time() {
  }
  timeEnd() {
  }
};
var LOGGER = new DummyLogger();

// node_modules/geotiff/src/geotiff.js
function getFieldTypeLength(fieldType) {
  switch (fieldType) {
    case fieldTypes.BYTE:
    case fieldTypes.ASCII:
    case fieldTypes.SBYTE:
    case fieldTypes.UNDEFINED:
      return 1;
    case fieldTypes.SHORT:
    case fieldTypes.SSHORT:
      return 2;
    case fieldTypes.LONG:
    case fieldTypes.SLONG:
    case fieldTypes.FLOAT:
    case fieldTypes.IFD:
      return 4;
    case fieldTypes.RATIONAL:
    case fieldTypes.SRATIONAL:
    case fieldTypes.DOUBLE:
    case fieldTypes.LONG8:
    case fieldTypes.SLONG8:
    case fieldTypes.IFD8:
      return 8;
    default:
      throw new RangeError(`Invalid field type: ${fieldType}`);
  }
}
function parseGeoKeyDirectory(fileDirectory) {
  const rawGeoKeyDirectory = fileDirectory.GeoKeyDirectory;
  if (!rawGeoKeyDirectory) {
    return null;
  }
  const geoKeyDirectory = {};
  for (let i = 4; i <= rawGeoKeyDirectory[3] * 4; i += 4) {
    const key = geoKeyNames[rawGeoKeyDirectory[i]];
    const location = rawGeoKeyDirectory[i + 1] ? fieldTagNames[rawGeoKeyDirectory[i + 1]] : null;
    const count = rawGeoKeyDirectory[i + 2];
    const offset = rawGeoKeyDirectory[i + 3];
    let value = null;
    if (!location) {
      value = offset;
    } else {
      value = fileDirectory[location];
      if (typeof value === "undefined" || value === null) {
        throw new Error(`Could not get value of geoKey '${key}'.`);
      } else if (typeof value === "string") {
        value = value.substring(offset, offset + count - 1);
      } else if (value.subarray) {
        value = value.subarray(offset, offset + count);
        if (count === 1) {
          value = value[0];
        }
      }
    }
    geoKeyDirectory[key] = value;
  }
  return geoKeyDirectory;
}
function getValues(dataSlice, fieldType, count, offset) {
  let values = null;
  let readMethod = null;
  const fieldTypeLength = getFieldTypeLength(fieldType);
  switch (fieldType) {
    case fieldTypes.BYTE:
    case fieldTypes.ASCII:
    case fieldTypes.UNDEFINED:
      values = new Uint8Array(count);
      readMethod = dataSlice.readUint8;
      break;
    case fieldTypes.SBYTE:
      values = new Int8Array(count);
      readMethod = dataSlice.readInt8;
      break;
    case fieldTypes.SHORT:
      values = new Uint16Array(count);
      readMethod = dataSlice.readUint16;
      break;
    case fieldTypes.SSHORT:
      values = new Int16Array(count);
      readMethod = dataSlice.readInt16;
      break;
    case fieldTypes.LONG:
    case fieldTypes.IFD:
      values = new Uint32Array(count);
      readMethod = dataSlice.readUint32;
      break;
    case fieldTypes.SLONG:
      values = new Int32Array(count);
      readMethod = dataSlice.readInt32;
      break;
    case fieldTypes.LONG8:
    case fieldTypes.IFD8:
      values = new Array(count);
      readMethod = dataSlice.readUint64;
      break;
    case fieldTypes.SLONG8:
      values = new Array(count);
      readMethod = dataSlice.readInt64;
      break;
    case fieldTypes.RATIONAL:
      values = new Uint32Array(count * 2);
      readMethod = dataSlice.readUint32;
      break;
    case fieldTypes.SRATIONAL:
      values = new Int32Array(count * 2);
      readMethod = dataSlice.readInt32;
      break;
    case fieldTypes.FLOAT:
      values = new Float32Array(count);
      readMethod = dataSlice.readFloat32;
      break;
    case fieldTypes.DOUBLE:
      values = new Float64Array(count);
      readMethod = dataSlice.readFloat64;
      break;
    default:
      throw new RangeError(`Invalid field type: ${fieldType}`);
  }
  if (!(fieldType === fieldTypes.RATIONAL || fieldType === fieldTypes.SRATIONAL)) {
    for (let i = 0; i < count; ++i) {
      values[i] = readMethod.call(dataSlice, offset + i * fieldTypeLength);
    }
  } else {
    for (let i = 0; i < count; i += 2) {
      values[i] = readMethod.call(dataSlice, offset + i * fieldTypeLength);
      values[i + 1] = readMethod.call(dataSlice, offset + (i * fieldTypeLength + 4));
    }
  }
  if (fieldType === fieldTypes.ASCII) {
    return new TextDecoder("utf-8").decode(values);
  }
  return values;
}
var ImageFileDirectory = class {
  constructor(fileDirectory, geoKeyDirectory, nextIFDByteOffset) {
    this.fileDirectory = fileDirectory;
    this.geoKeyDirectory = geoKeyDirectory;
    this.nextIFDByteOffset = nextIFDByteOffset;
  }
};
var GeoTIFFImageIndexError = class extends Error {
  constructor(index) {
    super(`No image at index ${index}`);
    this.index = index;
  }
};
var GeoTIFFBase = class {
  async readRasters(options = {}) {
    const { window: imageWindow, width, height } = options;
    let { resX, resY, bbox } = options;
    const firstImage = await this.getImage();
    let usedImage = firstImage;
    const imageCount = await this.getImageCount();
    const imgBBox = firstImage.getBoundingBox();
    if (imageWindow && bbox) {
      throw new Error('Both "bbox" and "window" passed.');
    }
    if (width || height) {
      if (imageWindow) {
        const [oX, oY] = firstImage.getOrigin();
        const [rX, rY] = firstImage.getResolution();
        bbox = [
          oX + imageWindow[0] * rX,
          oY + imageWindow[1] * rY,
          oX + imageWindow[2] * rX,
          oY + imageWindow[3] * rY
        ];
      }
      const usedBBox = bbox || imgBBox;
      if (width) {
        if (resX) {
          throw new Error("Both width and resX passed");
        }
        resX = (usedBBox[2] - usedBBox[0]) / width;
      }
      if (height) {
        if (resY) {
          throw new Error("Both width and resY passed");
        }
        resY = (usedBBox[3] - usedBBox[1]) / height;
      }
    }
    if (resX || resY) {
      const allImages = [];
      for (let i = 0; i < imageCount; ++i) {
        const image = await this.getImage(i);
        const { SubfileType: subfileType, NewSubfileType: newSubfileType } = image.fileDirectory;
        if (i === 0 || subfileType === 2 || newSubfileType & 1) {
          allImages.push(image);
        }
      }
      allImages.sort((a, b) => a.getWidth() - b.getWidth());
      for (let i = 0; i < allImages.length; ++i) {
        const image = allImages[i];
        const imgResX = (imgBBox[2] - imgBBox[0]) / image.getWidth();
        const imgResY = (imgBBox[3] - imgBBox[1]) / image.getHeight();
        usedImage = image;
        if (resX && resX > imgResX || resY && resY > imgResY) {
          break;
        }
      }
    }
    let wnd = imageWindow;
    if (bbox) {
      const [oX, oY] = firstImage.getOrigin();
      const [imageResX, imageResY] = usedImage.getResolution(firstImage);
      wnd = [
        Math.round((bbox[0] - oX) / imageResX),
        Math.round((bbox[1] - oY) / imageResY),
        Math.round((bbox[2] - oX) / imageResX),
        Math.round((bbox[3] - oY) / imageResY)
      ];
      wnd = [
        Math.min(wnd[0], wnd[2]),
        Math.min(wnd[1], wnd[3]),
        Math.max(wnd[0], wnd[2]),
        Math.max(wnd[1], wnd[3])
      ];
    }
    return usedImage.readRasters(__spreadProps(__spreadValues({}, options), { window: wnd }));
  }
};
var GeoTIFF = class extends GeoTIFFBase {
  constructor(source2, littleEndian, bigTiff, firstIFDOffset, options = {}) {
    super();
    this.source = source2;
    this.littleEndian = littleEndian;
    this.bigTiff = bigTiff;
    this.firstIFDOffset = firstIFDOffset;
    this.cache = options.cache || false;
    this.ifdRequests = [];
    this.ghostValues = null;
  }
  async getSlice(offset, size) {
    const fallbackSize = this.bigTiff ? 4048 : 1024;
    return new DataSlice((await this.source.fetch([{
      offset,
      length: typeof size !== "undefined" ? size : fallbackSize
    }]))[0], offset, this.littleEndian, this.bigTiff);
  }
  async parseFileDirectoryAt(offset) {
    const entrySize = this.bigTiff ? 20 : 12;
    const offsetSize = this.bigTiff ? 8 : 2;
    let dataSlice = await this.getSlice(offset);
    const numDirEntries = this.bigTiff ? dataSlice.readUint64(offset) : dataSlice.readUint16(offset);
    const byteSize = numDirEntries * entrySize + (this.bigTiff ? 16 : 6);
    if (!dataSlice.covers(offset, byteSize)) {
      dataSlice = await this.getSlice(offset, byteSize);
    }
    const fileDirectory = {};
    let i = offset + (this.bigTiff ? 8 : 2);
    for (let entryCount = 0; entryCount < numDirEntries; i += entrySize, ++entryCount) {
      const fieldTag = dataSlice.readUint16(i);
      const fieldType = dataSlice.readUint16(i + 2);
      const typeCount = this.bigTiff ? dataSlice.readUint64(i + 4) : dataSlice.readUint32(i + 4);
      let fieldValues;
      let value;
      const fieldTypeLength = getFieldTypeLength(fieldType);
      const valueOffset = i + (this.bigTiff ? 12 : 8);
      if (fieldTypeLength * typeCount <= (this.bigTiff ? 8 : 4)) {
        fieldValues = getValues(dataSlice, fieldType, typeCount, valueOffset);
      } else {
        const actualOffset = dataSlice.readOffset(valueOffset);
        const length = getFieldTypeLength(fieldType) * typeCount;
        if (dataSlice.covers(actualOffset, length)) {
          fieldValues = getValues(dataSlice, fieldType, typeCount, actualOffset);
        } else {
          const fieldDataSlice = await this.getSlice(actualOffset, length);
          fieldValues = getValues(fieldDataSlice, fieldType, typeCount, actualOffset);
        }
      }
      if (typeCount === 1 && arrayFields.indexOf(fieldTag) === -1 && !(fieldType === fieldTypes.RATIONAL || fieldType === fieldTypes.SRATIONAL)) {
        value = fieldValues[0];
      } else {
        value = fieldValues;
      }
      fileDirectory[fieldTagNames[fieldTag]] = value;
    }
    const geoKeyDirectory = parseGeoKeyDirectory(fileDirectory);
    const nextIFDByteOffset = dataSlice.readOffset(offset + offsetSize + entrySize * numDirEntries);
    return new ImageFileDirectory(fileDirectory, geoKeyDirectory, nextIFDByteOffset);
  }
  async requestIFD(index) {
    if (this.ifdRequests[index]) {
      return this.ifdRequests[index];
    } else if (index === 0) {
      this.ifdRequests[index] = this.parseFileDirectoryAt(this.firstIFDOffset);
      return this.ifdRequests[index];
    } else if (!this.ifdRequests[index - 1]) {
      try {
        this.ifdRequests[index - 1] = this.requestIFD(index - 1);
      } catch (e) {
        if (e instanceof GeoTIFFImageIndexError) {
          throw new GeoTIFFImageIndexError(index);
        }
        throw e;
      }
    }
    this.ifdRequests[index] = (async () => {
      const previousIfd = await this.ifdRequests[index - 1];
      if (previousIfd.nextIFDByteOffset === 0) {
        throw new GeoTIFFImageIndexError(index);
      }
      return this.parseFileDirectoryAt(previousIfd.nextIFDByteOffset);
    })();
    return this.ifdRequests[index];
  }
  async getImage(index = 0) {
    const ifd = await this.requestIFD(index);
    return new geotiffimage_default(ifd.fileDirectory, ifd.geoKeyDirectory, this.dataView, this.littleEndian, this.cache, this.source);
  }
  async getImageCount() {
    let index = 0;
    let hasNext = true;
    while (hasNext) {
      try {
        await this.requestIFD(index);
        ++index;
      } catch (e) {
        if (e instanceof GeoTIFFImageIndexError) {
          hasNext = false;
        } else {
          throw e;
        }
      }
    }
    return index;
  }
  async getGhostValues() {
    const offset = this.bigTiff ? 16 : 8;
    if (this.ghostValues) {
      return this.ghostValues;
    }
    const detectionString = "GDAL_STRUCTURAL_METADATA_SIZE=";
    const heuristicAreaSize = detectionString.length + 100;
    let slice = await this.getSlice(offset, heuristicAreaSize);
    if (detectionString === getValues(slice, fieldTypes.ASCII, detectionString.length, offset)) {
      const valuesString = getValues(slice, fieldTypes.ASCII, heuristicAreaSize, offset);
      const firstLine = valuesString.split("\n")[0];
      const metadataSize = Number(firstLine.split("=")[1].split(" ")[0]) + firstLine.length;
      if (metadataSize > heuristicAreaSize) {
        slice = await this.getSlice(offset, metadataSize);
      }
      const fullString = getValues(slice, fieldTypes.ASCII, metadataSize, offset);
      this.ghostValues = {};
      fullString.split("\n").filter((line) => line.length > 0).map((line) => line.split("=")).forEach(([key, value]) => {
        this.ghostValues[key] = value;
      });
    }
    return this.ghostValues;
  }
  static async fromSource(source2, options, signal) {
    const headerData = (await source2.fetch([{ offset: 0, length: 1024 }], signal))[0];
    const dataView = new DataView64(headerData);
    const BOM = dataView.getUint16(0, 0);
    let littleEndian;
    if (BOM === 18761) {
      littleEndian = true;
    } else if (BOM === 19789) {
      littleEndian = false;
    } else {
      throw new TypeError("Invalid byte order value.");
    }
    const magicNumber = dataView.getUint16(2, littleEndian);
    let bigTiff;
    if (magicNumber === 42) {
      bigTiff = false;
    } else if (magicNumber === 43) {
      bigTiff = true;
      const offsetByteSize = dataView.getUint16(4, littleEndian);
      if (offsetByteSize !== 8) {
        throw new Error("Unsupported offset byte-size.");
      }
    } else {
      throw new TypeError("Invalid magic number.");
    }
    const firstIFDOffset = bigTiff ? dataView.getUint64(8, littleEndian) : dataView.getUint32(4, littleEndian);
    return new GeoTIFF(source2, littleEndian, bigTiff, firstIFDOffset, options);
  }
  close() {
    if (typeof this.source.close === "function") {
      return this.source.close();
    }
    return false;
  }
};
var MultiGeoTIFF = class extends GeoTIFFBase {
  constructor(mainFile, overviewFiles) {
    super();
    this.mainFile = mainFile;
    this.overviewFiles = overviewFiles;
    this.imageFiles = [mainFile].concat(overviewFiles);
    this.fileDirectoriesPerFile = null;
    this.fileDirectoriesPerFileParsing = null;
    this.imageCount = null;
  }
  async parseFileDirectoriesPerFile() {
    const requests = [this.mainFile.parseFileDirectoryAt(this.mainFile.firstIFDOffset)].concat(this.overviewFiles.map((file) => file.parseFileDirectoryAt(file.firstIFDOffset)));
    this.fileDirectoriesPerFile = await Promise.all(requests);
    return this.fileDirectoriesPerFile;
  }
  async getImage(index = 0) {
    await this.getImageCount();
    await this.parseFileDirectoriesPerFile();
    let visited = 0;
    let relativeIndex = 0;
    for (let i = 0; i < this.imageFiles.length; i++) {
      const imageFile = this.imageFiles[i];
      for (let ii = 0; ii < this.imageCounts[i]; ii++) {
        if (index === visited) {
          const ifd = await imageFile.requestIFD(relativeIndex);
          return new geotiffimage_default(ifd.fileDirectory, ifd.geoKeyDirectory, imageFile.dataView, imageFile.littleEndian, imageFile.cache, imageFile.source);
        }
        visited++;
        relativeIndex++;
      }
      relativeIndex = 0;
    }
    throw new RangeError("Invalid image index");
  }
  async getImageCount() {
    if (this.imageCount !== null) {
      return this.imageCount;
    }
    const requests = [this.mainFile.getImageCount()].concat(this.overviewFiles.map((file) => file.getImageCount()));
    this.imageCounts = await Promise.all(requests);
    this.imageCount = this.imageCounts.reduce((count, ifds) => count + ifds, 0);
    return this.imageCount;
  }
};
async function fromUrl(url2, options = {}, signal) {
  return GeoTIFF.fromSource(makeRemoteSource(url2, options), signal);
}
async function fromUrls(mainUrl, overviewUrls = [], options = {}, signal) {
  const mainFile = await GeoTIFF.fromSource(makeRemoteSource(mainUrl, options), signal);
  const overviewFiles = await Promise.all(overviewUrls.map((url2) => GeoTIFF.fromSource(makeRemoteSource(url2, options))));
  return new MultiGeoTIFF(mainFile, overviewFiles);
}

// node_modules/ol/worker/geotiff-decoder.js
var source = `function _typeof(e){return(_typeof="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e})(e)}function asyncGeneratorStep(e,t,r,n,a,i,o){try{var s=e[i](o),l=s.value}catch(e){return void r(e)}s.done?t(l):Promise.resolve(l).then(n,a)}function _asyncToGenerator(e){return function(){var t=this,r=arguments;return new Promise((function(n,a){var i=e.apply(t,r);function o(e){asyncGeneratorStep(i,n,a,o,s,"next",e)}function s(e){asyncGeneratorStep(i,n,a,o,s,"throw",e)}o(void 0)}))}}function _classCallCheck(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}function _defineProperties(e,t){for(var r=0;r<t.length;r++){var n=t[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(e,n.key,n)}}function _createClass(e,t,r){return t&&_defineProperties(e.prototype,t),r&&_defineProperties(e,r),e}function _defineProperty(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function _inherits(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function");e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,writable:!0,configurable:!0}}),t&&_setPrototypeOf(e,t)}function _getPrototypeOf(e){return(_getPrototypeOf=Object.setPrototypeOf?Object.getPrototypeOf:function(e){return e.__proto__||Object.getPrototypeOf(e)})(e)}function _setPrototypeOf(e,t){return(_setPrototypeOf=Object.setPrototypeOf||function(e,t){return e.__proto__=t,e})(e,t)}function _isNativeReflectConstruct(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){}))),!0}catch(e){return!1}}function _assertThisInitialized(e){if(void 0===e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return e}function _possibleConstructorReturn(e,t){if(t&&("object"==typeof t||"function"==typeof t))return t;if(void 0!==t)throw new TypeError("Derived constructors may only return object or undefined");return _assertThisInitialized(e)}function _createSuper(e){var t=_isNativeReflectConstruct();return function(){var r,n=_getPrototypeOf(e);if(t){var a=_getPrototypeOf(this).constructor;r=Reflect.construct(n,arguments,a)}else r=n.apply(this,arguments);return _possibleConstructorReturn(this,r)}}function _toConsumableArray(e){return _arrayWithoutHoles(e)||_iterableToArray(e)||_unsupportedIterableToArray(e)||_nonIterableSpread()}function _arrayWithoutHoles(e){if(Array.isArray(e))return _arrayLikeToArray(e)}function _iterableToArray(e){if("undefined"!=typeof Symbol&&null!=e[Symbol.iterator]||null!=e["@@iterator"])return Array.from(e)}function _unsupportedIterableToArray(e,t){if(e){if("string"==typeof e)return _arrayLikeToArray(e,t);var r=Object.prototype.toString.call(e).slice(8,-1);return"Object"===r&&e.constructor&&(r=e.constructor.name),"Map"===r||"Set"===r?Array.from(e):"Arguments"===r||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r)?_arrayLikeToArray(e,t):void 0}}function _arrayLikeToArray(e,t){(null==t||t>e.length)&&(t=e.length);for(var r=0,n=new Array(t);r<t;r++)n[r]=e[r];return n}function _nonIterableSpread(){throw new TypeError("Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}var commonjsGlobal="undefined"!=typeof globalThis?globalThis:"undefined"!=typeof window?window:"undefined"!=typeof global?global:"undefined"!=typeof self?self:{};function getDefaultExportFromCjs(e){return e&&e.__esModule&&Object.prototype.hasOwnProperty.call(e,"default")?e.default:e}var runtime={exports:{}};!function(e){var t=function(e){var t,r=Object.prototype,n=r.hasOwnProperty,a="function"==typeof Symbol?Symbol:{},i=a.iterator||"@@iterator",o=a.asyncIterator||"@@asyncIterator",s=a.toStringTag||"@@toStringTag";function l(e,t,r){return Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}),e[t]}try{l({},"")}catch(e){l=function(e,t,r){return e[t]=r}}function f(e,t,r,n){var a=t&&t.prototype instanceof g?t:g,i=Object.create(a.prototype),o=new A(n||[]);return i._invoke=function(e,t,r){var n=u;return function(a,i){if(n===h)throw new Error("Generator is already running");if(n===p){if("throw"===a)throw i;return I()}for(r.method=a,r.arg=i;;){var o=r.delegate;if(o){var s=x(o,r);if(s){if(s===m)continue;return s}}if("next"===r.method)r.sent=r._sent=r.arg;else if("throw"===r.method){if(n===u)throw n=p,r.arg;r.dispatchException(r.arg)}else"return"===r.method&&r.abrupt("return",r.arg);n=h;var l=c(e,t,r);if("normal"===l.type){if(n=r.done?p:d,l.arg===m)continue;return{value:l.arg,done:r.done}}"throw"===l.type&&(n=p,r.method="throw",r.arg=l.arg)}}}(e,r,o),i}function c(e,t,r){try{return{type:"normal",arg:e.call(t,r)}}catch(e){return{type:"throw",arg:e}}}e.wrap=f;var u="suspendedStart",d="suspendedYield",h="executing",p="completed",m={};function g(){}function y(){}function _(){}var b={};l(b,i,(function(){return this}));var v=Object.getPrototypeOf,w=v&&v(v(M([])));w&&w!==r&&n.call(w,i)&&(b=w);var k=_.prototype=g.prototype=Object.create(b);function T(e){["next","throw","return"].forEach((function(t){l(e,t,(function(e){return this._invoke(t,e)}))}))}function E(e,t){function r(a,i,o,s){var l=c(e[a],e,i);if("throw"!==l.type){var f=l.arg,u=f.value;return u&&"object"===_typeof(u)&&n.call(u,"__await")?t.resolve(u.__await).then((function(e){r("next",e,o,s)}),(function(e){r("throw",e,o,s)})):t.resolve(u).then((function(e){f.value=e,o(f)}),(function(e){return r("throw",e,o,s)}))}s(l.arg)}var a;this._invoke=function(e,n){function i(){return new t((function(t,a){r(e,n,t,a)}))}return a=a?a.then(i,i):i()}}function x(e,r){var n=e.iterator[r.method];if(n===t){if(r.delegate=null,"throw"===r.method){if(e.iterator.return&&(r.method="return",r.arg=t,x(e,r),"throw"===r.method))return m;r.method="throw",r.arg=new TypeError("The iterator does not provide a 'throw' method")}return m}var a=c(n,e.iterator,r.arg);if("throw"===a.type)return r.method="throw",r.arg=a.arg,r.delegate=null,m;var i=a.arg;return i?i.done?(r[e.resultName]=i.value,r.next=e.nextLoc,"return"!==r.method&&(r.method="next",r.arg=t),r.delegate=null,m):i:(r.method="throw",r.arg=new TypeError("iterator result is not an object"),r.delegate=null,m)}function S(e){var t={tryLoc:e[0]};1 in e&&(t.catchLoc=e[1]),2 in e&&(t.finallyLoc=e[2],t.afterLoc=e[3]),this.tryEntries.push(t)}function D(e){var t=e.completion||{};t.type="normal",delete t.arg,e.completion=t}function A(e){this.tryEntries=[{tryLoc:"root"}],e.forEach(S,this),this.reset(!0)}function M(e){if(e){var r=e[i];if(r)return r.call(e);if("function"==typeof e.next)return e;if(!isNaN(e.length)){var a=-1,o=function r(){for(;++a<e.length;)if(n.call(e,a))return r.value=e[a],r.done=!1,r;return r.value=t,r.done=!0,r};return o.next=o}}return{next:I}}function I(){return{value:t,done:!0}}return y.prototype=_,l(k,"constructor",_),l(_,"constructor",y),y.displayName=l(_,s,"GeneratorFunction"),e.isGeneratorFunction=function(e){var t="function"==typeof e&&e.constructor;return!!t&&(t===y||"GeneratorFunction"===(t.displayName||t.name))},e.mark=function(e){return Object.setPrototypeOf?Object.setPrototypeOf(e,_):(e.__proto__=_,l(e,s,"GeneratorFunction")),e.prototype=Object.create(k),e},e.awrap=function(e){return{__await:e}},T(E.prototype),l(E.prototype,o,(function(){return this})),e.AsyncIterator=E,e.async=function(t,r,n,a,i){void 0===i&&(i=Promise);var o=new E(f(t,r,n,a),i);return e.isGeneratorFunction(r)?o:o.next().then((function(e){return e.done?e.value:o.next()}))},T(k),l(k,s,"Generator"),l(k,i,(function(){return this})),l(k,"toString",(function(){return"[object Generator]"})),e.keys=function(e){var t=[];for(var r in e)t.push(r);return t.reverse(),function r(){for(;t.length;){var n=t.pop();if(n in e)return r.value=n,r.done=!1,r}return r.done=!0,r}},e.values=M,A.prototype={constructor:A,reset:function(e){if(this.prev=0,this.next=0,this.sent=this._sent=t,this.done=!1,this.delegate=null,this.method="next",this.arg=t,this.tryEntries.forEach(D),!e)for(var r in this)"t"===r.charAt(0)&&n.call(this,r)&&!isNaN(+r.slice(1))&&(this[r]=t)},stop:function(){this.done=!0;var e=this.tryEntries[0].completion;if("throw"===e.type)throw e.arg;return this.rval},dispatchException:function(e){if(this.done)throw e;var r=this;function a(n,a){return s.type="throw",s.arg=e,r.next=n,a&&(r.method="next",r.arg=t),!!a}for(var i=this.tryEntries.length-1;i>=0;--i){var o=this.tryEntries[i],s=o.completion;if("root"===o.tryLoc)return a("end");if(o.tryLoc<=this.prev){var l=n.call(o,"catchLoc"),f=n.call(o,"finallyLoc");if(l&&f){if(this.prev<o.catchLoc)return a(o.catchLoc,!0);if(this.prev<o.finallyLoc)return a(o.finallyLoc)}else if(l){if(this.prev<o.catchLoc)return a(o.catchLoc,!0)}else{if(!f)throw new Error("try statement without catch or finally");if(this.prev<o.finallyLoc)return a(o.finallyLoc)}}}},abrupt:function(e,t){for(var r=this.tryEntries.length-1;r>=0;--r){var a=this.tryEntries[r];if(a.tryLoc<=this.prev&&n.call(a,"finallyLoc")&&this.prev<a.finallyLoc){var i=a;break}}i&&("break"===e||"continue"===e)&&i.tryLoc<=t&&t<=i.finallyLoc&&(i=null);var o=i?i.completion:{};return o.type=e,o.arg=t,i?(this.method="next",this.next=i.finallyLoc,m):this.complete(o)},complete:function(e,t){if("throw"===e.type)throw e.arg;return"break"===e.type||"continue"===e.type?this.next=e.arg:"return"===e.type?(this.rval=this.arg=e.arg,this.method="return",this.next="end"):"normal"===e.type&&t&&(this.next=t),m},finish:function(e){for(var t=this.tryEntries.length-1;t>=0;--t){var r=this.tryEntries[t];if(r.finallyLoc===e)return this.complete(r.completion,r.afterLoc),D(r),m}},catch:function(e){for(var t=this.tryEntries.length-1;t>=0;--t){var r=this.tryEntries[t];if(r.tryLoc===e){var n=r.completion;if("throw"===n.type){var a=n.arg;D(r)}return a}}throw new Error("illegal catch attempt")},delegateYield:function(e,r,n){return this.delegate={iterator:M(e),resultName:r,nextLoc:n},"next"===this.method&&(this.arg=t),m}},e}(e.exports);try{regeneratorRuntime=t}catch(e){"object"===("undefined"==typeof globalThis?"undefined":_typeof(globalThis))?globalThis.regeneratorRuntime=t:Function("r","regeneratorRuntime = r")(t)}}(runtime);var worker={},isObservable=function(e){return!!e&&("symbol"===_typeof(Symbol.observable)&&"function"==typeof e[Symbol.observable]?e===e[Symbol.observable]():"function"==typeof e["@@observable"]&&e===e["@@observable"]())},common$1={},serializers={};function extendSerializer(e,t){var r=e.deserialize.bind(e),n=e.serialize.bind(e);return{deserialize:function(e){return t.deserialize(e,r)},serialize:function(e){return t.serialize(e,n)}}}Object.defineProperty(serializers,"__esModule",{value:!0}),serializers.DefaultSerializer=serializers.extendSerializer=void 0,serializers.extendSerializer=extendSerializer;var DefaultErrorSerializer={deserialize:function(e){return Object.assign(Error(e.message),{name:e.name,stack:e.stack})},serialize:function(e){return{__error_marker:"$$error",message:e.message,name:e.name,stack:e.stack}}},isSerializedError=function(e){return e&&"object"===_typeof(e)&&"__error_marker"in e&&"$$error"===e.__error_marker};serializers.DefaultSerializer={deserialize:function(e){return isSerializedError(e)?DefaultErrorSerializer.deserialize(e):e},serialize:function(e){return e instanceof Error?DefaultErrorSerializer.serialize(e):e}},Object.defineProperty(common$1,"__esModule",{value:!0}),common$1.serialize=common$1.deserialize=common$1.registerSerializer=void 0;var serializers_1=serializers,registeredSerializer=serializers_1.DefaultSerializer;function registerSerializer(e){registeredSerializer=serializers_1.extendSerializer(registeredSerializer,e)}function deserialize(e){return registeredSerializer.deserialize(e)}function serialize(e){return registeredSerializer.serialize(e)}common$1.registerSerializer=registerSerializer,common$1.deserialize=deserialize,common$1.serialize=serialize;var transferable={},symbols={};Object.defineProperty(symbols,"__esModule",{value:!0}),symbols.$worker=symbols.$transferable=symbols.$terminate=symbols.$events=symbols.$errors=void 0,symbols.$errors=Symbol("thread.errors"),symbols.$events=Symbol("thread.events"),symbols.$terminate=Symbol("thread.terminate"),symbols.$transferable=Symbol("thread.transferable"),symbols.$worker=Symbol("thread.worker"),Object.defineProperty(transferable,"__esModule",{value:!0}),transferable.Transfer=transferable.isTransferDescriptor=void 0;var symbols_1=symbols;function isTransferable(e){return!(!e||"object"!==_typeof(e))}function isTransferDescriptor(e){return e&&"object"===_typeof(e)&&e[symbols_1.$transferable]}function Transfer$1(e,t){var r;if(!t){if(!isTransferable(e))throw Error();t=[e]}return _defineProperty(r={},symbols_1.$transferable,!0),_defineProperty(r,"send",e),_defineProperty(r,"transferables",t),r}transferable.isTransferDescriptor=isTransferDescriptor,transferable.Transfer=Transfer$1;var messages$1={},exports,MasterMessageType,WorkerMessageType;exports=messages$1,Object.defineProperty(exports,"__esModule",{value:!0}),exports.WorkerMessageType=exports.MasterMessageType=void 0,(MasterMessageType=exports.MasterMessageType||(exports.MasterMessageType={})).cancel="cancel",MasterMessageType.run="run",(WorkerMessageType=exports.WorkerMessageType||(exports.WorkerMessageType={})).error="error",WorkerMessageType.init="init",WorkerMessageType.result="result",WorkerMessageType.running="running",WorkerMessageType.uncaughtError="uncaughtError";var implementation$1={},implementation_browser={};Object.defineProperty(implementation_browser,"__esModule",{value:!0});var isWorkerRuntime$2=function(){var e="undefined"!=typeof self&&"undefined"!=typeof Window&&self instanceof Window;return!("undefined"==typeof self||!self.postMessage||e)},postMessageToMaster$2=function(e,t){self.postMessage(e,t)},subscribeToMasterMessages$2=function(e){var t=function(t){e(t.data)};return self.addEventListener("message",t),function(){self.removeEventListener("message",t)}};implementation_browser.default={isWorkerRuntime:isWorkerRuntime$2,postMessageToMaster:postMessageToMaster$2,subscribeToMasterMessages:subscribeToMasterMessages$2};var implementation_tinyWorker={};Object.defineProperty(implementation_tinyWorker,"__esModule",{value:!0}),"undefined"==typeof self&&(commonjsGlobal.self=commonjsGlobal);var isWorkerRuntime$1=function(){return!("undefined"==typeof self||!self.postMessage)},postMessageToMaster$1=function(e){self.postMessage(e)},muxingHandlerSetUp=!1,messageHandlers=new Set,subscribeToMasterMessages$1=function(e){muxingHandlerSetUp||(self.addEventListener("message",(function(e){messageHandlers.forEach((function(t){return t(e.data)}))})),muxingHandlerSetUp=!0),messageHandlers.add(e);return function(){return messageHandlers.delete(e)}};implementation_tinyWorker.default={isWorkerRuntime:isWorkerRuntime$1,postMessageToMaster:postMessageToMaster$1,subscribeToMasterMessages:subscribeToMasterMessages$1};var implementation_worker_threads={},worker_threads={},implementation;function selectImplementation(){return"function"==typeof __non_webpack_require__?__non_webpack_require__("worker_threads"):eval("require")("worker_threads")}function getImplementation(){return implementation||(implementation=selectImplementation()),implementation}Object.defineProperty(worker_threads,"__esModule",{value:!0}),worker_threads.default=getImplementation;var __importDefault$1=commonjsGlobal&&commonjsGlobal.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(implementation_worker_threads,"__esModule",{value:!0});var worker_threads_1=__importDefault$1(worker_threads);function assertMessagePort(e){if(!e)throw Error("Invariant violation: MessagePort to parent is not available.");return e}var isWorkerRuntime=function(){return!worker_threads_1.default().isMainThread},postMessageToMaster=function(e,t){assertMessagePort(worker_threads_1.default().parentPort).postMessage(e,t)},subscribeToMasterMessages=function(e){var t=worker_threads_1.default().parentPort;if(!t)throw Error("Invariant violation: MessagePort to parent is not available.");var r=function(t){e(t)};return assertMessagePort(t).on("message",r),function(){assertMessagePort(t).off("message",r)}};function testImplementation(){worker_threads_1.default()}implementation_worker_threads.default={isWorkerRuntime:isWorkerRuntime,postMessageToMaster:postMessageToMaster,subscribeToMasterMessages:subscribeToMasterMessages,testImplementation:testImplementation};var __importDefault=commonjsGlobal&&commonjsGlobal.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(implementation$1,"__esModule",{value:!0});var implementation_browser_1=__importDefault(implementation_browser),implementation_tiny_worker_1=__importDefault(implementation_tinyWorker),implementation_worker_threads_1=__importDefault(implementation_worker_threads),runningInNode="undefined"!=typeof process&&"browser"!==process.arch&&"pid"in process;function selectNodeImplementation(){try{return implementation_worker_threads_1.default.testImplementation(),implementation_worker_threads_1.default}catch(e){return implementation_tiny_worker_1.default}}implementation$1.default=runningInNode?selectNodeImplementation():implementation_browser_1.default,function(e){var t=commonjsGlobal&&commonjsGlobal.__awaiter||function(e,t,r,n){return new(r||(r=Promise))((function(a,i){function o(e){try{l(n.next(e))}catch(e){i(e)}}function s(e){try{l(n.throw(e))}catch(e){i(e)}}function l(e){var t;e.done?a(e.value):(t=e.value,t instanceof r?t:new r((function(e){e(t)}))).then(o,s)}l((n=n.apply(e,t||[])).next())}))},r=commonjsGlobal&&commonjsGlobal.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(e,"__esModule",{value:!0}),e.expose=e.isWorkerRuntime=e.Transfer=e.registerSerializer=void 0;var n=r(isObservable),a=common$1,i=transferable,o=messages$1,s=r(implementation$1),l=common$1;Object.defineProperty(e,"registerSerializer",{enumerable:!0,get:function(){return l.registerSerializer}});var f=transferable;Object.defineProperty(e,"Transfer",{enumerable:!0,get:function(){return f.Transfer}}),e.isWorkerRuntime=s.default.isWorkerRuntime;var c=!1,u=new Map,d=function(e){return e&&e.type===o.MasterMessageType.run},h=function(e){return n.default(e)||function(e){return e&&"object"===_typeof(e)&&"function"==typeof e.subscribe}(e)};function p(e){return i.isTransferDescriptor(e)?{payload:e.send,transferables:e.transferables}:{payload:e,transferables:void 0}}function m(e,t){var r=p(t),n=r.payload,i=r.transferables,l={type:o.WorkerMessageType.error,uid:e,error:a.serialize(n)};s.default.postMessageToMaster(l,i)}function g(e,t,r){var n=p(r),a=n.payload,i=n.transferables,l={type:o.WorkerMessageType.result,uid:e,complete:!!t||void 0,payload:a};s.default.postMessageToMaster(l,i)}function y(e,t){var r={type:o.WorkerMessageType.running,uid:e,resultType:t};s.default.postMessageToMaster(r)}function _(e){try{var t={type:o.WorkerMessageType.uncaughtError,error:a.serialize(e)};s.default.postMessageToMaster(t)}catch(t){console.error("Not reporting uncaught error back to master thread as it occured while reporting an uncaught error already.\\nLatest error:",t,"\\nOriginal error:",e)}}function b(e,r,n){return t(this,void 0,void 0,regeneratorRuntime.mark((function t(){var i,o,s,l;return regeneratorRuntime.wrap((function(t){for(;;)switch(t.prev=t.next){case 0:t.prev=0,i=r.apply(void 0,_toConsumableArray(n)),t.next=7;break;case 4:return t.prev=4,t.t0=t.catch(0),t.abrupt("return",m(e,t.t0));case 7:if(o=h(i)?"observable":"promise",y(e,o),!h(i)){t.next=14;break}s=i.subscribe((function(t){return g(e,!1,a.serialize(t))}),(function(t){m(e,a.serialize(t)),u.delete(e)}),(function(){g(e,!0),u.delete(e)})),u.set(e,s),t.next=24;break;case 14:return t.prev=14,t.next=17,i;case 17:l=t.sent,g(e,!0,a.serialize(l)),t.next=24;break;case 21:t.prev=21,t.t1=t.catch(14),m(e,a.serialize(t.t1));case 24:case"end":return t.stop()}}),t,null,[[0,4],[14,21]])})))}e.expose=function(e){if(!s.default.isWorkerRuntime())throw Error("expose() called in the master thread.");if(c)throw Error("expose() called more than once. This is not possible. Pass an object to expose() if you want to expose multiple functions.");if(c=!0,"function"==typeof e)s.default.subscribeToMasterMessages((function(t){d(t)&&!t.method&&b(t.uid,e,t.args.map(a.deserialize))})),t={type:o.WorkerMessageType.init,exposed:{type:"function"}},s.default.postMessageToMaster(t);else{if("object"!==_typeof(e)||!e)throw Error("Invalid argument passed to expose(). Expected a function or an object, got: ".concat(e));s.default.subscribeToMasterMessages((function(t){d(t)&&t.method&&b(t.uid,e[t.method],t.args.map(a.deserialize))})),function(e){var t={type:o.WorkerMessageType.init,exposed:{type:"module",methods:e}};s.default.postMessageToMaster(t)}(Object.keys(e).filter((function(t){return"function"==typeof e[t]})))}var t;s.default.subscribeToMasterMessages((function(e){if((n=e)&&n.type===o.MasterMessageType.cancel){var t=e.uid,r=u.get(t);r&&(r.unsubscribe(),u.delete(t))}var n}))},"undefined"!=typeof self&&"function"==typeof self.addEventListener&&s.default.isWorkerRuntime()&&(self.addEventListener("error",(function(e){setTimeout((function(){return _(e.error||e)}),250)})),self.addEventListener("unhandledrejection",(function(e){var t=e.reason;t&&"string"==typeof t.message&&setTimeout((function(){return _(t)}),250)}))),"undefined"!=typeof process&&"function"==typeof process.on&&s.default.isWorkerRuntime()&&(process.on("uncaughtException",(function(e){setTimeout((function(){return _(e)}),250)})),process.on("unhandledRejection",(function(e){e&&"string"==typeof e.message&&setTimeout((function(){return _(e)}),250)})))}(worker);var WorkerContext=getDefaultExportFromCjs(worker),expose=WorkerContext.expose;WorkerContext.registerSerializer;var Transfer=WorkerContext.Transfer,registry=new Map;function addDecoder(e,t){Array.isArray(e)||(e=[e]),e.forEach((function(e){return registry.set(e,t)}))}function getDecoder(e){return _getDecoder.apply(this,arguments)}function _getDecoder(){return(_getDecoder=_asyncToGenerator(regeneratorRuntime.mark((function e(t){var r,n;return regeneratorRuntime.wrap((function(e){for(;;)switch(e.prev=e.next){case 0:if(r=registry.get(t.Compression)){e.next=3;break}throw new Error("Unknown compression method identifier: ".concat(t.Compression));case 3:return e.next=5,r();case 5:return n=e.sent,e.abrupt("return",new n(t));case 7:case"end":return e.stop()}}),e)})))).apply(this,arguments)}function decode(e,t){return _decode.apply(this,arguments)}function _decode(){return(_decode=_asyncToGenerator(regeneratorRuntime.mark((function e(t,r){var n,a;return regeneratorRuntime.wrap((function(e){for(;;)switch(e.prev=e.next){case 0:return e.next=2,getDecoder(t);case 2:return n=e.sent,e.next=5,n.decode(t,r);case 5:return a=e.sent,e.abrupt("return",Transfer(a));case 7:case"end":return e.stop()}}),e)})))).apply(this,arguments)}function decodeRowAcc(e,t){var r=e.length-t,n=0;do{for(var a=t;a>0;a--)e[n+t]+=e[n],n++;r-=t}while(r>0)}function decodeRowFloatingPoint(e,t,r){for(var n=0,a=e.length,i=a/r;a>t;){for(var o=t;o>0;--o)e[n+t]+=e[n],++n;a-=t}for(var s=e.slice(),l=0;l<i;++l)for(var f=0;f<r;++f)e[r*l+f]=s[(r-f-1)*i+l]}function applyPredictor(e,t,r,n,a,i){if(!t||1===t)return e;for(var o=0;o<a.length;++o){if(a[o]%8!=0)throw new Error("When decoding with predictor, only multiple of 8 bits are supported.");if(a[o]!==a[0])throw new Error("When decoding with predictor, all samples must have the same size.")}for(var s=a[0]/8,l=2===i?1:a.length,f=0;f<n&&!(f*l*r*s>=e.byteLength);++f){var c=void 0;if(2===t){switch(a[0]){case 8:c=new Uint8Array(e,f*l*r*s,l*r*s);break;case 16:c=new Uint16Array(e,f*l*r*s,l*r*s/2);break;case 32:c=new Uint32Array(e,f*l*r*s,l*r*s/4);break;default:throw new Error("Predictor 2 not allowed with ".concat(a[0]," bits per sample."))}decodeRowAcc(c,l)}else 3===t&&decodeRowFloatingPoint(c=new Uint8Array(e,f*l*r*s,l*r*s),l,s)}return e}addDecoder([void 0,1],(function(){return Promise.resolve().then((function(){return raw})).then((function(e){return e.default}))})),addDecoder(5,(function(){return Promise.resolve().then((function(){return lzw})).then((function(e){return e.default}))})),addDecoder(6,(function(){throw new Error("old style JPEG compression is not supported.")})),addDecoder(7,(function(){return Promise.resolve().then((function(){return jpeg})).then((function(e){return e.default}))})),addDecoder([8,32946],(function(){return Promise.resolve().then((function(){return deflate})).then((function(e){return e.default}))})),addDecoder(32773,(function(){return Promise.resolve().then((function(){return packbits})).then((function(e){return e.default}))})),addDecoder(34887,(function(){return Promise.resolve().then((function(){return lerc})).then((function(e){return e.default}))})),expose(decode);var BaseDecoder=function(){function e(){_classCallCheck(this,e)}return _createClass(e,[{key:"decode",value:function(){var e=_asyncToGenerator(regeneratorRuntime.mark((function e(t,r){var n,a,i,o,s;return regeneratorRuntime.wrap((function(e){for(;;)switch(e.prev=e.next){case 0:return e.next=2,this.decodeBlock(r);case 2:if(n=e.sent,1===(a=t.Predictor||1)){e.next=9;break}return i=!t.StripOffsets,o=i?t.TileWidth:t.ImageWidth,s=i?t.TileLength:t.RowsPerStrip||t.ImageLength,e.abrupt("return",applyPredictor(n,a,o,s,t.BitsPerSample,t.PlanarConfiguration));case 9:return e.abrupt("return",n);case 10:case"end":return e.stop()}}),e,this)})));return function(t,r){return e.apply(this,arguments)}}()}]),e}(),RawDecoder=function(e){_inherits(r,BaseDecoder);var t=_createSuper(r);function r(){return _classCallCheck(this,r),t.apply(this,arguments)}return _createClass(r,[{key:"decodeBlock",value:function(e){return e}}]),r}(),raw=Object.freeze({__proto__:null,default:RawDecoder}),MIN_BITS=9,CLEAR_CODE=256,EOI_CODE=257,MAX_BYTELENGTH=12;function getByte(e,t,r){var n=t%8,a=Math.floor(t/8),i=8-n,o=t+r-8*(a+1),s=8*(a+2)-(t+r),l=8*(a+2)-t;if(s=Math.max(0,s),a>=e.length)return console.warn("ran off the end of the buffer before finding EOI_CODE (end on input code)"),EOI_CODE;var f=e[a]&Math.pow(2,8-n)-1,c=f<<=r-i;if(a+1<e.length){var u=e[a+1]>>>s;c+=u<<=Math.max(0,r-l)}if(o>8&&a+2<e.length){var d=8*(a+3)-(t+r);c+=e[a+2]>>>d}return c}function appendReversed(e,t){for(var r=t.length-1;r>=0;r--)e.push(t[r]);return e}function decompress(e){for(var t=new Uint16Array(4093),r=new Uint8Array(4093),n=0;n<=257;n++)t[n]=4096,r[n]=n;var a=258,i=MIN_BITS,o=0;function s(){a=258,i=MIN_BITS}function l(e){var t=getByte(e,o,i);return o+=i,t}function f(e,n){return r[a]=n,t[a]=e,++a-1}function c(e){for(var n=[],a=e;4096!==a;a=t[a])n.push(r[a]);return n}var u=[];s();for(var d,h=new Uint8Array(e),p=l(h);p!==EOI_CODE;){if(p===CLEAR_CODE){for(s(),p=l(h);p===CLEAR_CODE;)p=l(h);if(p===EOI_CODE)break;if(p>CLEAR_CODE)throw new Error("corrupted code at scanline ".concat(p));appendReversed(u,c(p)),d=p}else if(p<a){var m=c(p);appendReversed(u,m),f(d,m[m.length-1]),d=p}else{var g=c(d);if(!g)throw new Error("Bogus entry. Not in dictionary, ".concat(d," / ").concat(a,", position: ").concat(o));appendReversed(u,g),u.push(g[g.length-1]),f(d,g[g.length-1]),d=p}a+1>=Math.pow(2,i)&&(i===MAX_BYTELENGTH?d=void 0:i++),p=l(h)}return new Uint8Array(u)}var LZWDecoder=function(e){_inherits(r,BaseDecoder);var t=_createSuper(r);function r(){return _classCallCheck(this,r),t.apply(this,arguments)}return _createClass(r,[{key:"decodeBlock",value:function(e){return decompress(e).buffer}}]),r}(),lzw=Object.freeze({__proto__:null,default:LZWDecoder}),dctZigZag=new Int32Array([0,1,8,16,9,2,3,10,17,24,32,25,18,11,4,5,12,19,26,33,40,48,41,34,27,20,13,6,7,14,21,28,35,42,49,56,57,50,43,36,29,22,15,23,30,37,44,51,58,59,52,45,38,31,39,46,53,60,61,54,47,55,62,63]),dctCos1=4017,dctSin1=799,dctCos3=3406,dctSin3=2276,dctCos6=1567,dctSin6=3784,dctSqrt2=5793,dctSqrt1d2=2896;function buildHuffmanTable(e,t){for(var r=0,n=[],a=16;a>0&&!e[a-1];)--a;n.push({children:[],index:0});for(var i,o=n[0],s=0;s<a;s++){for(var l=0;l<e[s];l++){for((o=n.pop()).children[o.index]=t[r];o.index>0;)o=n.pop();for(o.index++,n.push(o);n.length<=s;)n.push(i={children:[],index:0}),o.children[o.index]=i.children,o=i;r++}s+1<a&&(n.push(i={children:[],index:0}),o.children[o.index]=i.children,o=i)}return n[0].children}function decodeScan(e,t,r,n,a,i,o,s,l){var f=r.mcusPerLine,c=r.progressive,u=t,d=t,h=0,p=0;function m(){if(p>0)return p--,h>>p&1;if(255===(h=e[d++])){var t=e[d++];if(t)throw new Error("unexpected marker: ".concat((h<<8|t).toString(16)))}return p=7,h>>>7}function g(e){for(var t,r=e;null!==(t=m());){if("number"==typeof(r=r[t]))return r;if("object"!==_typeof(r))throw new Error("invalid huffman sequence")}return null}function y(e){for(var t=e,r=0;t>0;){var n=m();if(null===n)return;r=r<<1|n,--t}return r}function _(e){var t=y(e);return t>=1<<e-1?t:t+(-1<<e)+1}var b=0;var v,w=0;function k(e,t,r,n,a){var i=r%f,o=(r/f|0)*e.v+n,s=i*e.h+a;t(e,e.blocks[o][s])}function T(e,t,r){var n=r/e.blocksPerLine|0,a=r%e.blocksPerLine;t(e,e.blocks[n][a])}var E,x,S,D,A,M,I=n.length;M=c?0===i?0===s?function(e,t){var r=g(e.huffmanTableDC),n=0===r?0:_(r)<<l;e.pred+=n,t[0]=e.pred}:function(e,t){t[0]|=m()<<l}:0===s?function(e,t){if(b>0)b--;else for(var r=i,n=o;r<=n;){var a=g(e.huffmanTableAC),s=15&a,f=a>>4;if(0===s){if(f<15){b=y(f)+(1<<f)-1;break}r+=16}else t[dctZigZag[r+=f]]=_(s)*(1<<l),r++}}:function(e,t){for(var r=i,n=o,a=0;r<=n;){var s=dctZigZag[r],f=t[s]<0?-1:1;switch(w){case 0:var c=g(e.huffmanTableAC),u=15&c;if(a=c>>4,0===u)a<15?(b=y(a)+(1<<a),w=4):(a=16,w=1);else{if(1!==u)throw new Error("invalid ACn encoding");v=_(u),w=a?2:3}continue;case 1:case 2:t[s]?t[s]+=(m()<<l)*f:0==--a&&(w=2===w?3:0);break;case 3:t[s]?t[s]+=(m()<<l)*f:(t[s]=v<<l,w=0);break;case 4:t[s]&&(t[s]+=(m()<<l)*f)}r++}4===w&&0==--b&&(w=0)}:function(e,t){var r=g(e.huffmanTableDC),n=0===r?0:_(r);e.pred+=n,t[0]=e.pred;for(var a=1;a<64;){var i=g(e.huffmanTableAC),o=15&i,s=i>>4;if(0===o){if(s<15)break;a+=16}else t[dctZigZag[a+=s]]=_(o),a++}};var R,O,C=0;O=1===I?n[0].blocksPerLine*n[0].blocksPerColumn:f*r.mcusPerColumn;for(var P=a||O;C<O;){for(x=0;x<I;x++)n[x].pred=0;if(b=0,1===I)for(E=n[0],A=0;A<P;A++)T(E,M,C),C++;else for(A=0;A<P;A++){for(x=0;x<I;x++){var L=E=n[x],U=L.h,B=L.v;for(S=0;S<B;S++)for(D=0;D<U;D++)k(E,M,C,S,D)}if(++C===O)break}if(p=0,(R=e[d]<<8|e[d+1])<65280)throw new Error("marker was not found");if(!(R>=65488&&R<=65495))break;d+=2}return d-u}function buildComponentData(e,t){var r=[],n=t.blocksPerLine,a=t.blocksPerColumn,i=n<<3,o=new Int32Array(64),s=new Uint8Array(64);function l(e,r,n){var a,i,o,s,l,f,c,u,d,h,p=t.quantizationTable,m=n;for(h=0;h<64;h++)m[h]=e[h]*p[h];for(h=0;h<8;++h){var g=8*h;0!==m[1+g]||0!==m[2+g]||0!==m[3+g]||0!==m[4+g]||0!==m[5+g]||0!==m[6+g]||0!==m[7+g]?(a=dctSqrt2*m[0+g]+128>>8,i=dctSqrt2*m[4+g]+128>>8,o=m[2+g],s=m[6+g],l=dctSqrt1d2*(m[1+g]-m[7+g])+128>>8,u=dctSqrt1d2*(m[1+g]+m[7+g])+128>>8,f=m[3+g]<<4,c=m[5+g]<<4,d=a-i+1>>1,a=a+i+1>>1,i=d,d=o*dctSin6+s*dctCos6+128>>8,o=o*dctCos6-s*dctSin6+128>>8,s=d,d=l-c+1>>1,l=l+c+1>>1,c=d,d=u+f+1>>1,f=u-f+1>>1,u=d,d=a-s+1>>1,a=a+s+1>>1,s=d,d=i-o+1>>1,i=i+o+1>>1,o=d,d=l*dctSin3+u*dctCos3+2048>>12,l=l*dctCos3-u*dctSin3+2048>>12,u=d,d=f*dctSin1+c*dctCos1+2048>>12,f=f*dctCos1-c*dctSin1+2048>>12,c=d,m[0+g]=a+u,m[7+g]=a-u,m[1+g]=i+c,m[6+g]=i-c,m[2+g]=o+f,m[5+g]=o-f,m[3+g]=s+l,m[4+g]=s-l):(d=dctSqrt2*m[0+g]+512>>10,m[0+g]=d,m[1+g]=d,m[2+g]=d,m[3+g]=d,m[4+g]=d,m[5+g]=d,m[6+g]=d,m[7+g]=d)}for(h=0;h<8;++h){var y=h;0!==m[8+y]||0!==m[16+y]||0!==m[24+y]||0!==m[32+y]||0!==m[40+y]||0!==m[48+y]||0!==m[56+y]?(a=dctSqrt2*m[0+y]+2048>>12,i=dctSqrt2*m[32+y]+2048>>12,o=m[16+y],s=m[48+y],l=dctSqrt1d2*(m[8+y]-m[56+y])+2048>>12,u=dctSqrt1d2*(m[8+y]+m[56+y])+2048>>12,f=m[24+y],c=m[40+y],d=a-i+1>>1,a=a+i+1>>1,i=d,d=o*dctSin6+s*dctCos6+2048>>12,o=o*dctCos6-s*dctSin6+2048>>12,s=d,d=l-c+1>>1,l=l+c+1>>1,c=d,d=u+f+1>>1,f=u-f+1>>1,u=d,d=a-s+1>>1,a=a+s+1>>1,s=d,d=i-o+1>>1,i=i+o+1>>1,o=d,d=l*dctSin3+u*dctCos3+2048>>12,l=l*dctCos3-u*dctSin3+2048>>12,u=d,d=f*dctSin1+c*dctCos1+2048>>12,f=f*dctCos1-c*dctSin1+2048>>12,c=d,m[0+y]=a+u,m[56+y]=a-u,m[8+y]=i+c,m[48+y]=i-c,m[16+y]=o+f,m[40+y]=o-f,m[24+y]=s+l,m[32+y]=s-l):(d=dctSqrt2*n[h+0]+8192>>14,m[0+y]=d,m[8+y]=d,m[16+y]=d,m[24+y]=d,m[32+y]=d,m[40+y]=d,m[48+y]=d,m[56+y]=d)}for(h=0;h<64;++h){var _=128+(m[h]+8>>4);r[h]=_<0?0:_>255?255:_}}for(var f=0;f<a;f++){for(var c=f<<3,u=0;u<8;u++)r.push(new Uint8Array(i));for(var d=0;d<n;d++){l(t.blocks[f][d],s,o);for(var h=0,p=d<<3,m=0;m<8;m++)for(var g=r[c+m],y=0;y<8;y++)g[p+y]=s[h++]}}return r}var JpegStreamReader=function(){function e(){_classCallCheck(this,e),this.jfif=null,this.adobe=null,this.quantizationTables=[],this.huffmanTablesAC=[],this.huffmanTablesDC=[],this.resetFrames()}return _createClass(e,[{key:"resetFrames",value:function(){this.frames=[]}},{key:"parse",value:function(e){var t=0;function r(){var r=e[t]<<8|e[t+1];return t+=2,r}function n(e){var t,r,n=0,a=0;for(r in e.components)e.components.hasOwnProperty(r)&&(n<(t=e.components[r]).h&&(n=t.h),a<t.v&&(a=t.v));var i=Math.ceil(e.samplesPerLine/8/n),o=Math.ceil(e.scanLines/8/a);for(r in e.components)if(e.components.hasOwnProperty(r)){t=e.components[r];for(var s=Math.ceil(Math.ceil(e.samplesPerLine/8)*t.h/n),l=Math.ceil(Math.ceil(e.scanLines/8)*t.v/a),f=i*t.h,c=o*t.v,u=[],d=0;d<c;d++){for(var h=[],p=0;p<f;p++)h.push(new Int32Array(64));u.push(h)}t.blocksPerLine=s,t.blocksPerColumn=l,t.blocks=u}e.maxH=n,e.maxV=a,e.mcusPerLine=i,e.mcusPerColumn=o}var a,i,o=r();if(65496!==o)throw new Error("SOI not found");for(o=r();65497!==o;){switch(o){case 65280:break;case 65504:case 65505:case 65506:case 65507:case 65508:case 65509:case 65510:case 65511:case 65512:case 65513:case 65514:case 65515:case 65516:case 65517:case 65518:case 65519:case 65534:var s=(a=void 0,i=void 0,a=r(),i=e.subarray(t,t+a-2),t+=i.length,i);65504===o&&74===s[0]&&70===s[1]&&73===s[2]&&70===s[3]&&0===s[4]&&(this.jfif={version:{major:s[5],minor:s[6]},densityUnits:s[7],xDensity:s[8]<<8|s[9],yDensity:s[10]<<8|s[11],thumbWidth:s[12],thumbHeight:s[13],thumbData:s.subarray(14,14+3*s[12]*s[13])}),65518===o&&65===s[0]&&100===s[1]&&111===s[2]&&98===s[3]&&101===s[4]&&0===s[5]&&(this.adobe={version:s[6],flags0:s[7]<<8|s[8],flags1:s[9]<<8|s[10],transformCode:s[11]});break;case 65499:for(var l=r()+t-2;t<l;){var f=e[t++],c=new Int32Array(64);if(f>>4==0)for(var u=0;u<64;u++){c[dctZigZag[u]]=e[t++]}else{if(f>>4!=1)throw new Error("DQT: invalid table spec");for(var d=0;d<64;d++){c[dctZigZag[d]]=r()}}this.quantizationTables[15&f]=c}break;case 65472:case 65473:case 65474:r();for(var h={extended:65473===o,progressive:65474===o,precision:e[t++],scanLines:r(),samplesPerLine:r(),components:{},componentsOrder:[]},p=e[t++],m=void 0,g=0;g<p;g++){m=e[t];var y=e[t+1]>>4,_=15&e[t+1],b=e[t+2];h.componentsOrder.push(m),h.components[m]={h:y,v:_,quantizationIdx:b},t+=3}n(h),this.frames.push(h);break;case 65476:for(var v=r(),w=2;w<v;){for(var k=e[t++],T=new Uint8Array(16),E=0,x=0;x<16;x++,t++)T[x]=e[t],E+=T[x];for(var S=new Uint8Array(E),D=0;D<E;D++,t++)S[D]=e[t];w+=17+E,k>>4==0?this.huffmanTablesDC[15&k]=buildHuffmanTable(T,S):this.huffmanTablesAC[15&k]=buildHuffmanTable(T,S)}break;case 65501:r(),this.resetInterval=r();break;case 65498:r();for(var A=e[t++],M=[],I=this.frames[0],R=0;R<A;R++){var O=I.components[e[t++]],C=e[t++];O.huffmanTableDC=this.huffmanTablesDC[C>>4],O.huffmanTableAC=this.huffmanTablesAC[15&C],M.push(O)}var P=e[t++],L=e[t++],U=e[t++],B=decodeScan(e,t,I,M,this.resetInterval,P,L,U>>4,15&U);t+=B;break;case 65535:255!==e[t]&&t--;break;default:if(255===e[t-3]&&e[t-2]>=192&&e[t-2]<=254){t-=3;break}throw new Error("unknown JPEG marker ".concat(o.toString(16)))}o=r()}}},{key:"getResult",value:function(){var e=this.frames;if(0===this.frames.length)throw new Error("no frames were decoded");this.frames.length>1&&console.warn("more than one frame is not supported");for(var t=0;t<this.frames.length;t++)for(var r=this.frames[t].components,n=0,a=Object.keys(r);n<a.length;n++){var i=a[n];r[i].quantizationTable=this.quantizationTables[r[i].quantizationIdx],delete r[i].quantizationIdx}for(var o=e[0],s=o.components,l=o.componentsOrder,f=[],c=o.samplesPerLine,u=o.scanLines,d=0;d<l.length;d++){var h=s[l[d]];f.push({lines:buildComponentData(o,h),scaleX:h.h/o.maxH,scaleY:h.v/o.maxV})}for(var p=new Uint8Array(c*u*f.length),m=0,g=0;g<u;++g)for(var y=0;y<c;++y)for(var _=0;_<f.length;++_){var b=f[_];p[m]=b.lines[0|g*b.scaleY][0|y*b.scaleX],++m}return p}}]),e}(),JpegDecoder=function(e){_inherits(r,BaseDecoder);var t=_createSuper(r);function r(e){var n;return _classCallCheck(this,r),(n=t.call(this)).reader=new JpegStreamReader,e.JPEGTables&&n.reader.parse(e.JPEGTables),n}return _createClass(r,[{key:"decodeBlock",value:function(e){return this.reader.resetFrames(),this.reader.parse(new Uint8Array(e)),this.reader.getResult().buffer}}]),r}(),jpeg=Object.freeze({__proto__:null,default:JpegDecoder});function zero$1(e){for(var t=e.length;--t>=0;)e[t]=0}var MIN_MATCH$1=3,MAX_MATCH$1=258,LENGTH_CODES$1=29,LITERALS$1=256,L_CODES$1=LITERALS$1+1+LENGTH_CODES$1,D_CODES$1=30,DIST_CODE_LEN=512,static_ltree=new Array(2*(L_CODES$1+2));zero$1(static_ltree);var static_dtree=new Array(2*D_CODES$1);zero$1(static_dtree);var _dist_code=new Array(DIST_CODE_LEN);zero$1(_dist_code);var _length_code=new Array(MAX_MATCH$1-MIN_MATCH$1+1);zero$1(_length_code);var base_length=new Array(LENGTH_CODES$1);zero$1(base_length);var base_dist=new Array(D_CODES$1);zero$1(base_dist);var adler32=function(e,t,r,n){for(var a=65535&e|0,i=e>>>16&65535|0,o=0;0!==r;){r-=o=r>2e3?2e3:r;do{i=i+(a=a+t[n++]|0)|0}while(--o);a%=65521,i%=65521}return a|i<<16|0},adler32_1=adler32,makeTable=function(){for(var e,t=[],r=0;r<256;r++){e=r;for(var n=0;n<8;n++)e=1&e?3988292384^e>>>1:e>>>1;t[r]=e}return t},crcTable=new Uint32Array(makeTable()),crc32=function(e,t,r,n){var a=crcTable,i=n+r;e^=-1;for(var o=n;o<i;o++)e=e>>>8^a[255&(e^t[o])];return-1^e},crc32_1=crc32,messages={2:"need dictionary",1:"stream end",0:"","-1":"file error","-2":"stream error","-3":"data error","-4":"insufficient memory","-5":"buffer error","-6":"incompatible version"},constants$2={Z_NO_FLUSH:0,Z_PARTIAL_FLUSH:1,Z_SYNC_FLUSH:2,Z_FULL_FLUSH:3,Z_FINISH:4,Z_BLOCK:5,Z_TREES:6,Z_OK:0,Z_STREAM_END:1,Z_NEED_DICT:2,Z_ERRNO:-1,Z_STREAM_ERROR:-2,Z_DATA_ERROR:-3,Z_MEM_ERROR:-4,Z_BUF_ERROR:-5,Z_NO_COMPRESSION:0,Z_BEST_SPEED:1,Z_BEST_COMPRESSION:9,Z_DEFAULT_COMPRESSION:-1,Z_FILTERED:1,Z_HUFFMAN_ONLY:2,Z_RLE:3,Z_FIXED:4,Z_DEFAULT_STRATEGY:0,Z_BINARY:0,Z_TEXT:1,Z_UNKNOWN:2,Z_DEFLATED:8},_has=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},assign=function(e){for(var t=Array.prototype.slice.call(arguments,1);t.length;){var r=t.shift();if(r){if("object"!==_typeof(r))throw new TypeError(r+"must be non-object");for(var n in r)_has(r,n)&&(e[n]=r[n])}}return e},flattenChunks=function(e){for(var t=0,r=0,n=e.length;r<n;r++)t+=e[r].length;for(var a=new Uint8Array(t),i=0,o=0,s=e.length;i<s;i++){var l=e[i];a.set(l,o),o+=l.length}return a},common={assign:assign,flattenChunks:flattenChunks},STR_APPLY_UIA_OK=!0;try{String.fromCharCode.apply(null,new Uint8Array(1))}catch(e){STR_APPLY_UIA_OK=!1}for(var _utf8len=new Uint8Array(256),q=0;q<256;q++)_utf8len[q]=q>=252?6:q>=248?5:q>=240?4:q>=224?3:q>=192?2:1;_utf8len[254]=_utf8len[254]=1;var string2buf=function(e){if("function"==typeof TextEncoder&&TextEncoder.prototype.encode)return(new TextEncoder).encode(e);var t,r,n,a,i,o=e.length,s=0;for(a=0;a<o;a++)55296==(64512&(r=e.charCodeAt(a)))&&a+1<o&&56320==(64512&(n=e.charCodeAt(a+1)))&&(r=65536+(r-55296<<10)+(n-56320),a++),s+=r<128?1:r<2048?2:r<65536?3:4;for(t=new Uint8Array(s),i=0,a=0;i<s;a++)55296==(64512&(r=e.charCodeAt(a)))&&a+1<o&&56320==(64512&(n=e.charCodeAt(a+1)))&&(r=65536+(r-55296<<10)+(n-56320),a++),r<128?t[i++]=r:r<2048?(t[i++]=192|r>>>6,t[i++]=128|63&r):r<65536?(t[i++]=224|r>>>12,t[i++]=128|r>>>6&63,t[i++]=128|63&r):(t[i++]=240|r>>>18,t[i++]=128|r>>>12&63,t[i++]=128|r>>>6&63,t[i++]=128|63&r);return t},buf2binstring=function(e,t){if(t<65534&&e.subarray&&STR_APPLY_UIA_OK)return String.fromCharCode.apply(null,e.length===t?e:e.subarray(0,t));for(var r="",n=0;n<t;n++)r+=String.fromCharCode(e[n]);return r},buf2string=function(e,t){var r,n,a=t||e.length;if("function"==typeof TextDecoder&&TextDecoder.prototype.decode)return(new TextDecoder).decode(e.subarray(0,t));var i=new Array(2*a);for(n=0,r=0;r<a;){var o=e[r++];if(o<128)i[n++]=o;else{var s=_utf8len[o];if(s>4)i[n++]=65533,r+=s-1;else{for(o&=2===s?31:3===s?15:7;s>1&&r<a;)o=o<<6|63&e[r++],s--;s>1?i[n++]=65533:o<65536?i[n++]=o:(o-=65536,i[n++]=55296|o>>10&1023,i[n++]=56320|1023&o)}}}return buf2binstring(i,n)},utf8border=function(e,t){(t=t||e.length)>e.length&&(t=e.length);for(var r=t-1;r>=0&&128==(192&e[r]);)r--;return r<0||0===r?t:r+_utf8len[e[r]]>t?r:t},strings={string2buf:string2buf,buf2string:buf2string,utf8border:utf8border};function ZStream(){this.input=null,this.next_in=0,this.avail_in=0,this.total_in=0,this.output=null,this.next_out=0,this.avail_out=0,this.total_out=0,this.msg="",this.state=null,this.data_type=2,this.adler=0}var zstream=ZStream,BAD$1=30,TYPE$1=12,inffast=function(e,t){var r,n,a,i,o,s,l,f,c,u,d,h,p,m,g,y,_,b,v,w,k,T,E,x,S=e.state;r=e.next_in,E=e.input,n=r+(e.avail_in-5),a=e.next_out,x=e.output,i=a-(t-e.avail_out),o=a+(e.avail_out-257),s=S.dmax,l=S.wsize,f=S.whave,c=S.wnext,u=S.window,d=S.hold,h=S.bits,p=S.lencode,m=S.distcode,g=(1<<S.lenbits)-1,y=(1<<S.distbits)-1;e:do{h<15&&(d+=E[r++]<<h,h+=8,d+=E[r++]<<h,h+=8),_=p[d&g];t:for(;;){if(d>>>=b=_>>>24,h-=b,0===(b=_>>>16&255))x[a++]=65535&_;else{if(!(16&b)){if(0==(64&b)){_=p[(65535&_)+(d&(1<<b)-1)];continue t}if(32&b){S.mode=TYPE$1;break e}e.msg="invalid literal/length code",S.mode=BAD$1;break e}v=65535&_,(b&=15)&&(h<b&&(d+=E[r++]<<h,h+=8),v+=d&(1<<b)-1,d>>>=b,h-=b),h<15&&(d+=E[r++]<<h,h+=8,d+=E[r++]<<h,h+=8),_=m[d&y];r:for(;;){if(d>>>=b=_>>>24,h-=b,!(16&(b=_>>>16&255))){if(0==(64&b)){_=m[(65535&_)+(d&(1<<b)-1)];continue r}e.msg="invalid distance code",S.mode=BAD$1;break e}if(w=65535&_,h<(b&=15)&&(d+=E[r++]<<h,(h+=8)<b&&(d+=E[r++]<<h,h+=8)),(w+=d&(1<<b)-1)>s){e.msg="invalid distance too far back",S.mode=BAD$1;break e}if(d>>>=b,h-=b,w>(b=a-i)){if((b=w-b)>f&&S.sane){e.msg="invalid distance too far back",S.mode=BAD$1;break e}if(k=0,T=u,0===c){if(k+=l-b,b<v){v-=b;do{x[a++]=u[k++]}while(--b);k=a-w,T=x}}else if(c<b){if(k+=l+c-b,(b-=c)<v){v-=b;do{x[a++]=u[k++]}while(--b);if(k=0,c<v){v-=b=c;do{x[a++]=u[k++]}while(--b);k=a-w,T=x}}}else if(k+=c-b,b<v){v-=b;do{x[a++]=u[k++]}while(--b);k=a-w,T=x}for(;v>2;)x[a++]=T[k++],x[a++]=T[k++],x[a++]=T[k++],v-=3;v&&(x[a++]=T[k++],v>1&&(x[a++]=T[k++]))}else{k=a-w;do{x[a++]=x[k++],x[a++]=x[k++],x[a++]=x[k++],v-=3}while(v>2);v&&(x[a++]=x[k++],v>1&&(x[a++]=x[k++]))}break}}break}}while(r<n&&a<o);r-=v=h>>3,d&=(1<<(h-=v<<3))-1,e.next_in=r,e.next_out=a,e.avail_in=r<n?n-r+5:5-(r-n),e.avail_out=a<o?o-a+257:257-(a-o),S.hold=d,S.bits=h},MAXBITS=15,ENOUGH_LENS$1=852,ENOUGH_DISTS$1=592,CODES$1=0,LENS$1=1,DISTS$1=2,lbase=new Uint16Array([3,4,5,6,7,8,9,10,11,13,15,17,19,23,27,31,35,43,51,59,67,83,99,115,131,163,195,227,258,0,0]),lext=new Uint8Array([16,16,16,16,16,16,16,16,17,17,17,17,18,18,18,18,19,19,19,19,20,20,20,20,21,21,21,21,16,72,78]),dbase=new Uint16Array([1,2,3,4,5,7,9,13,17,25,33,49,65,97,129,193,257,385,513,769,1025,1537,2049,3073,4097,6145,8193,12289,16385,24577,0,0]),dext=new Uint8Array([16,16,16,16,17,17,18,18,19,19,20,20,21,21,22,22,23,23,24,24,25,25,26,26,27,27,28,28,29,29,64,64]),inflate_table=function(e,t,r,n,a,i,o,s){var l,f,c,u,d,h,p,m,g,y=s.bits,_=0,b=0,v=0,w=0,k=0,T=0,E=0,x=0,S=0,D=0,A=null,M=0,I=new Uint16Array(MAXBITS+1),R=new Uint16Array(MAXBITS+1),O=null,C=0;for(_=0;_<=MAXBITS;_++)I[_]=0;for(b=0;b<n;b++)I[t[r+b]]++;for(k=y,w=MAXBITS;w>=1&&0===I[w];w--);if(k>w&&(k=w),0===w)return a[i++]=20971520,a[i++]=20971520,s.bits=1,0;for(v=1;v<w&&0===I[v];v++);for(k<v&&(k=v),x=1,_=1;_<=MAXBITS;_++)if(x<<=1,(x-=I[_])<0)return-1;if(x>0&&(e===CODES$1||1!==w))return-1;for(R[1]=0,_=1;_<MAXBITS;_++)R[_+1]=R[_]+I[_];for(b=0;b<n;b++)0!==t[r+b]&&(o[R[t[r+b]]++]=b);if(e===CODES$1?(A=O=o,h=19):e===LENS$1?(A=lbase,M-=257,O=lext,C-=257,h=256):(A=dbase,O=dext,h=-1),D=0,b=0,_=v,d=i,T=k,E=0,c=-1,u=(S=1<<k)-1,e===LENS$1&&S>ENOUGH_LENS$1||e===DISTS$1&&S>ENOUGH_DISTS$1)return 1;for(;;){p=_-E,o[b]<h?(m=0,g=o[b]):o[b]>h?(m=O[C+o[b]],g=A[M+o[b]]):(m=96,g=0),l=1<<_-E,v=f=1<<T;do{a[d+(D>>E)+(f-=l)]=p<<24|m<<16|g|0}while(0!==f);for(l=1<<_-1;D&l;)l>>=1;if(0!==l?(D&=l-1,D+=l):D=0,b++,0==--I[_]){if(_===w)break;_=t[r+o[b]]}if(_>k&&(D&u)!==c){for(0===E&&(E=k),d+=v,x=1<<(T=_-E);T+E<w&&!((x-=I[T+E])<=0);)T++,x<<=1;if(S+=1<<T,e===LENS$1&&S>ENOUGH_LENS$1||e===DISTS$1&&S>ENOUGH_DISTS$1)return 1;a[c=D&u]=k<<24|T<<16|d-i|0}}return 0!==D&&(a[d+D]=_-E<<24|64<<16|0),s.bits=k,0},inftrees=inflate_table,CODES=0,LENS=1,DISTS=2,Z_FINISH$1=constants$2.Z_FINISH,Z_BLOCK=constants$2.Z_BLOCK,Z_TREES=constants$2.Z_TREES,Z_OK$1=constants$2.Z_OK,Z_STREAM_END$1=constants$2.Z_STREAM_END,Z_NEED_DICT$1=constants$2.Z_NEED_DICT,Z_STREAM_ERROR$1=constants$2.Z_STREAM_ERROR,Z_DATA_ERROR$1=constants$2.Z_DATA_ERROR,Z_MEM_ERROR$1=constants$2.Z_MEM_ERROR,Z_BUF_ERROR=constants$2.Z_BUF_ERROR,Z_DEFLATED=constants$2.Z_DEFLATED,HEAD=1,FLAGS=2,TIME=3,OS=4,EXLEN=5,EXTRA=6,NAME=7,COMMENT=8,HCRC=9,DICTID=10,DICT=11,TYPE=12,TYPEDO=13,STORED=14,COPY_=15,COPY=16,TABLE=17,LENLENS=18,CODELENS=19,LEN_=20,LEN=21,LENEXT=22,DIST=23,DISTEXT=24,MATCH=25,LIT=26,CHECK=27,LENGTH=28,DONE=29,BAD=30,MEM=31,SYNC=32,ENOUGH_LENS=852,ENOUGH_DISTS=592,MAX_WBITS=15,DEF_WBITS=MAX_WBITS,zswap32=function(e){return(e>>>24&255)+(e>>>8&65280)+((65280&e)<<8)+((255&e)<<24)};function InflateState(){this.mode=0,this.last=!1,this.wrap=0,this.havedict=!1,this.flags=0,this.dmax=0,this.check=0,this.total=0,this.head=null,this.wbits=0,this.wsize=0,this.whave=0,this.wnext=0,this.window=null,this.hold=0,this.bits=0,this.length=0,this.offset=0,this.extra=0,this.lencode=null,this.distcode=null,this.lenbits=0,this.distbits=0,this.ncode=0,this.nlen=0,this.ndist=0,this.have=0,this.next=null,this.lens=new Uint16Array(320),this.work=new Uint16Array(288),this.lendyn=null,this.distdyn=null,this.sane=0,this.back=0,this.was=0}var inflateResetKeep=function(e){if(!e||!e.state)return Z_STREAM_ERROR$1;var t=e.state;return e.total_in=e.total_out=t.total=0,e.msg="",t.wrap&&(e.adler=1&t.wrap),t.mode=HEAD,t.last=0,t.havedict=0,t.dmax=32768,t.head=null,t.hold=0,t.bits=0,t.lencode=t.lendyn=new Int32Array(ENOUGH_LENS),t.distcode=t.distdyn=new Int32Array(ENOUGH_DISTS),t.sane=1,t.back=-1,Z_OK$1},inflateReset=function(e){if(!e||!e.state)return Z_STREAM_ERROR$1;var t=e.state;return t.wsize=0,t.whave=0,t.wnext=0,inflateResetKeep(e)},inflateReset2=function(e,t){var r;if(!e||!e.state)return Z_STREAM_ERROR$1;var n=e.state;return t<0?(r=0,t=-t):(r=1+(t>>4),t<48&&(t&=15)),t&&(t<8||t>15)?Z_STREAM_ERROR$1:(null!==n.window&&n.wbits!==t&&(n.window=null),n.wrap=r,n.wbits=t,inflateReset(e))},inflateInit2=function(e,t){if(!e)return Z_STREAM_ERROR$1;var r=new InflateState;e.state=r,r.window=null;var n=inflateReset2(e,t);return n!==Z_OK$1&&(e.state=null),n},inflateInit=function(e){return inflateInit2(e,DEF_WBITS)},virgin=!0,lenfix,distfix,fixedtables=function(e){if(virgin){lenfix=new Int32Array(512),distfix=new Int32Array(32);for(var t=0;t<144;)e.lens[t++]=8;for(;t<256;)e.lens[t++]=9;for(;t<280;)e.lens[t++]=7;for(;t<288;)e.lens[t++]=8;for(inftrees(LENS,e.lens,0,288,lenfix,0,e.work,{bits:9}),t=0;t<32;)e.lens[t++]=5;inftrees(DISTS,e.lens,0,32,distfix,0,e.work,{bits:5}),virgin=!1}e.lencode=lenfix,e.lenbits=9,e.distcode=distfix,e.distbits=5},updatewindow=function(e,t,r,n){var a,i=e.state;return null===i.window&&(i.wsize=1<<i.wbits,i.wnext=0,i.whave=0,i.window=new Uint8Array(i.wsize)),n>=i.wsize?(i.window.set(t.subarray(r-i.wsize,r),0),i.wnext=0,i.whave=i.wsize):((a=i.wsize-i.wnext)>n&&(a=n),i.window.set(t.subarray(r-n,r-n+a),i.wnext),(n-=a)?(i.window.set(t.subarray(r-n,r),0),i.wnext=n,i.whave=i.wsize):(i.wnext+=a,i.wnext===i.wsize&&(i.wnext=0),i.whave<i.wsize&&(i.whave+=a))),0},inflate$2=function(e,t){var r,n,a,i,o,s,l,f,c,u,d,h,p,m,g,y,_,b,v,w,k,T,E,x,S=0,D=new Uint8Array(4),A=new Uint8Array([16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15]);if(!e||!e.state||!e.output||!e.input&&0!==e.avail_in)return Z_STREAM_ERROR$1;(r=e.state).mode===TYPE&&(r.mode=TYPEDO),o=e.next_out,a=e.output,l=e.avail_out,i=e.next_in,n=e.input,s=e.avail_in,f=r.hold,c=r.bits,u=s,d=l,T=Z_OK$1;e:for(;;)switch(r.mode){case HEAD:if(0===r.wrap){r.mode=TYPEDO;break}for(;c<16;){if(0===s)break e;s--,f+=n[i++]<<c,c+=8}if(2&r.wrap&&35615===f){r.check=0,D[0]=255&f,D[1]=f>>>8&255,r.check=crc32_1(r.check,D,2,0),f=0,c=0,r.mode=FLAGS;break}if(r.flags=0,r.head&&(r.head.done=!1),!(1&r.wrap)||(((255&f)<<8)+(f>>8))%31){e.msg="incorrect header check",r.mode=BAD;break}if((15&f)!==Z_DEFLATED){e.msg="unknown compression method",r.mode=BAD;break}if(c-=4,k=8+(15&(f>>>=4)),0===r.wbits)r.wbits=k;else if(k>r.wbits){e.msg="invalid window size",r.mode=BAD;break}r.dmax=1<<r.wbits,e.adler=r.check=1,r.mode=512&f?DICTID:TYPE,f=0,c=0;break;case FLAGS:for(;c<16;){if(0===s)break e;s--,f+=n[i++]<<c,c+=8}if(r.flags=f,(255&r.flags)!==Z_DEFLATED){e.msg="unknown compression method",r.mode=BAD;break}if(57344&r.flags){e.msg="unknown header flags set",r.mode=BAD;break}r.head&&(r.head.text=f>>8&1),512&r.flags&&(D[0]=255&f,D[1]=f>>>8&255,r.check=crc32_1(r.check,D,2,0)),f=0,c=0,r.mode=TIME;case TIME:for(;c<32;){if(0===s)break e;s--,f+=n[i++]<<c,c+=8}r.head&&(r.head.time=f),512&r.flags&&(D[0]=255&f,D[1]=f>>>8&255,D[2]=f>>>16&255,D[3]=f>>>24&255,r.check=crc32_1(r.check,D,4,0)),f=0,c=0,r.mode=OS;case OS:for(;c<16;){if(0===s)break e;s--,f+=n[i++]<<c,c+=8}r.head&&(r.head.xflags=255&f,r.head.os=f>>8),512&r.flags&&(D[0]=255&f,D[1]=f>>>8&255,r.check=crc32_1(r.check,D,2,0)),f=0,c=0,r.mode=EXLEN;case EXLEN:if(1024&r.flags){for(;c<16;){if(0===s)break e;s--,f+=n[i++]<<c,c+=8}r.length=f,r.head&&(r.head.extra_len=f),512&r.flags&&(D[0]=255&f,D[1]=f>>>8&255,r.check=crc32_1(r.check,D,2,0)),f=0,c=0}else r.head&&(r.head.extra=null);r.mode=EXTRA;case EXTRA:if(1024&r.flags&&((h=r.length)>s&&(h=s),h&&(r.head&&(k=r.head.extra_len-r.length,r.head.extra||(r.head.extra=new Uint8Array(r.head.extra_len)),r.head.extra.set(n.subarray(i,i+h),k)),512&r.flags&&(r.check=crc32_1(r.check,n,h,i)),s-=h,i+=h,r.length-=h),r.length))break e;r.length=0,r.mode=NAME;case NAME:if(2048&r.flags){if(0===s)break e;h=0;do{k=n[i+h++],r.head&&k&&r.length<65536&&(r.head.name+=String.fromCharCode(k))}while(k&&h<s);if(512&r.flags&&(r.check=crc32_1(r.check,n,h,i)),s-=h,i+=h,k)break e}else r.head&&(r.head.name=null);r.length=0,r.mode=COMMENT;case COMMENT:if(4096&r.flags){if(0===s)break e;h=0;do{k=n[i+h++],r.head&&k&&r.length<65536&&(r.head.comment+=String.fromCharCode(k))}while(k&&h<s);if(512&r.flags&&(r.check=crc32_1(r.check,n,h,i)),s-=h,i+=h,k)break e}else r.head&&(r.head.comment=null);r.mode=HCRC;case HCRC:if(512&r.flags){for(;c<16;){if(0===s)break e;s--,f+=n[i++]<<c,c+=8}if(f!==(65535&r.check)){e.msg="header crc mismatch",r.mode=BAD;break}f=0,c=0}r.head&&(r.head.hcrc=r.flags>>9&1,r.head.done=!0),e.adler=r.check=0,r.mode=TYPE;break;case DICTID:for(;c<32;){if(0===s)break e;s--,f+=n[i++]<<c,c+=8}e.adler=r.check=zswap32(f),f=0,c=0,r.mode=DICT;case DICT:if(0===r.havedict)return e.next_out=o,e.avail_out=l,e.next_in=i,e.avail_in=s,r.hold=f,r.bits=c,Z_NEED_DICT$1;e.adler=r.check=1,r.mode=TYPE;case TYPE:if(t===Z_BLOCK||t===Z_TREES)break e;case TYPEDO:if(r.last){f>>>=7&c,c-=7&c,r.mode=CHECK;break}for(;c<3;){if(0===s)break e;s--,f+=n[i++]<<c,c+=8}switch(r.last=1&f,c-=1,3&(f>>>=1)){case 0:r.mode=STORED;break;case 1:if(fixedtables(r),r.mode=LEN_,t===Z_TREES){f>>>=2,c-=2;break e}break;case 2:r.mode=TABLE;break;case 3:e.msg="invalid block type",r.mode=BAD}f>>>=2,c-=2;break;case STORED:for(f>>>=7&c,c-=7&c;c<32;){if(0===s)break e;s--,f+=n[i++]<<c,c+=8}if((65535&f)!=(f>>>16^65535)){e.msg="invalid stored block lengths",r.mode=BAD;break}if(r.length=65535&f,f=0,c=0,r.mode=COPY_,t===Z_TREES)break e;case COPY_:r.mode=COPY;case COPY:if(h=r.length){if(h>s&&(h=s),h>l&&(h=l),0===h)break e;a.set(n.subarray(i,i+h),o),s-=h,i+=h,l-=h,o+=h,r.length-=h;break}r.mode=TYPE;break;case TABLE:for(;c<14;){if(0===s)break e;s--,f+=n[i++]<<c,c+=8}if(r.nlen=257+(31&f),f>>>=5,c-=5,r.ndist=1+(31&f),f>>>=5,c-=5,r.ncode=4+(15&f),f>>>=4,c-=4,r.nlen>286||r.ndist>30){e.msg="too many length or distance symbols",r.mode=BAD;break}r.have=0,r.mode=LENLENS;case LENLENS:for(;r.have<r.ncode;){for(;c<3;){if(0===s)break e;s--,f+=n[i++]<<c,c+=8}r.lens[A[r.have++]]=7&f,f>>>=3,c-=3}for(;r.have<19;)r.lens[A[r.have++]]=0;if(r.lencode=r.lendyn,r.lenbits=7,E={bits:r.lenbits},T=inftrees(CODES,r.lens,0,19,r.lencode,0,r.work,E),r.lenbits=E.bits,T){e.msg="invalid code lengths set",r.mode=BAD;break}r.have=0,r.mode=CODELENS;case CODELENS:for(;r.have<r.nlen+r.ndist;){for(;y=(S=r.lencode[f&(1<<r.lenbits)-1])>>>16&255,_=65535&S,!((g=S>>>24)<=c);){if(0===s)break e;s--,f+=n[i++]<<c,c+=8}if(_<16)f>>>=g,c-=g,r.lens[r.have++]=_;else{if(16===_){for(x=g+2;c<x;){if(0===s)break e;s--,f+=n[i++]<<c,c+=8}if(f>>>=g,c-=g,0===r.have){e.msg="invalid bit length repeat",r.mode=BAD;break}k=r.lens[r.have-1],h=3+(3&f),f>>>=2,c-=2}else if(17===_){for(x=g+3;c<x;){if(0===s)break e;s--,f+=n[i++]<<c,c+=8}c-=g,k=0,h=3+(7&(f>>>=g)),f>>>=3,c-=3}else{for(x=g+7;c<x;){if(0===s)break e;s--,f+=n[i++]<<c,c+=8}c-=g,k=0,h=11+(127&(f>>>=g)),f>>>=7,c-=7}if(r.have+h>r.nlen+r.ndist){e.msg="invalid bit length repeat",r.mode=BAD;break}for(;h--;)r.lens[r.have++]=k}}if(r.mode===BAD)break;if(0===r.lens[256]){e.msg="invalid code -- missing end-of-block",r.mode=BAD;break}if(r.lenbits=9,E={bits:r.lenbits},T=inftrees(LENS,r.lens,0,r.nlen,r.lencode,0,r.work,E),r.lenbits=E.bits,T){e.msg="invalid literal/lengths set",r.mode=BAD;break}if(r.distbits=6,r.distcode=r.distdyn,E={bits:r.distbits},T=inftrees(DISTS,r.lens,r.nlen,r.ndist,r.distcode,0,r.work,E),r.distbits=E.bits,T){e.msg="invalid distances set",r.mode=BAD;break}if(r.mode=LEN_,t===Z_TREES)break e;case LEN_:r.mode=LEN;case LEN:if(s>=6&&l>=258){e.next_out=o,e.avail_out=l,e.next_in=i,e.avail_in=s,r.hold=f,r.bits=c,inffast(e,d),o=e.next_out,a=e.output,l=e.avail_out,i=e.next_in,n=e.input,s=e.avail_in,f=r.hold,c=r.bits,r.mode===TYPE&&(r.back=-1);break}for(r.back=0;y=(S=r.lencode[f&(1<<r.lenbits)-1])>>>16&255,_=65535&S,!((g=S>>>24)<=c);){if(0===s)break e;s--,f+=n[i++]<<c,c+=8}if(y&&0==(240&y)){for(b=g,v=y,w=_;y=(S=r.lencode[w+((f&(1<<b+v)-1)>>b)])>>>16&255,_=65535&S,!(b+(g=S>>>24)<=c);){if(0===s)break e;s--,f+=n[i++]<<c,c+=8}f>>>=b,c-=b,r.back+=b}if(f>>>=g,c-=g,r.back+=g,r.length=_,0===y){r.mode=LIT;break}if(32&y){r.back=-1,r.mode=TYPE;break}if(64&y){e.msg="invalid literal/length code",r.mode=BAD;break}r.extra=15&y,r.mode=LENEXT;case LENEXT:if(r.extra){for(x=r.extra;c<x;){if(0===s)break e;s--,f+=n[i++]<<c,c+=8}r.length+=f&(1<<r.extra)-1,f>>>=r.extra,c-=r.extra,r.back+=r.extra}r.was=r.length,r.mode=DIST;case DIST:for(;y=(S=r.distcode[f&(1<<r.distbits)-1])>>>16&255,_=65535&S,!((g=S>>>24)<=c);){if(0===s)break e;s--,f+=n[i++]<<c,c+=8}if(0==(240&y)){for(b=g,v=y,w=_;y=(S=r.distcode[w+((f&(1<<b+v)-1)>>b)])>>>16&255,_=65535&S,!(b+(g=S>>>24)<=c);){if(0===s)break e;s--,f+=n[i++]<<c,c+=8}f>>>=b,c-=b,r.back+=b}if(f>>>=g,c-=g,r.back+=g,64&y){e.msg="invalid distance code",r.mode=BAD;break}r.offset=_,r.extra=15&y,r.mode=DISTEXT;case DISTEXT:if(r.extra){for(x=r.extra;c<x;){if(0===s)break e;s--,f+=n[i++]<<c,c+=8}r.offset+=f&(1<<r.extra)-1,f>>>=r.extra,c-=r.extra,r.back+=r.extra}if(r.offset>r.dmax){e.msg="invalid distance too far back",r.mode=BAD;break}r.mode=MATCH;case MATCH:if(0===l)break e;if(h=d-l,r.offset>h){if((h=r.offset-h)>r.whave&&r.sane){e.msg="invalid distance too far back",r.mode=BAD;break}h>r.wnext?(h-=r.wnext,p=r.wsize-h):p=r.wnext-h,h>r.length&&(h=r.length),m=r.window}else m=a,p=o-r.offset,h=r.length;h>l&&(h=l),l-=h,r.length-=h;do{a[o++]=m[p++]}while(--h);0===r.length&&(r.mode=LEN);break;case LIT:if(0===l)break e;a[o++]=r.length,l--,r.mode=LEN;break;case CHECK:if(r.wrap){for(;c<32;){if(0===s)break e;s--,f|=n[i++]<<c,c+=8}if(d-=l,e.total_out+=d,r.total+=d,d&&(e.adler=r.check=r.flags?crc32_1(r.check,a,d,o-d):adler32_1(r.check,a,d,o-d)),d=l,(r.flags?f:zswap32(f))!==r.check){e.msg="incorrect data check",r.mode=BAD;break}f=0,c=0}r.mode=LENGTH;case LENGTH:if(r.wrap&&r.flags){for(;c<32;){if(0===s)break e;s--,f+=n[i++]<<c,c+=8}if(f!==(4294967295&r.total)){e.msg="incorrect length check",r.mode=BAD;break}f=0,c=0}r.mode=DONE;case DONE:T=Z_STREAM_END$1;break e;case BAD:T=Z_DATA_ERROR$1;break e;case MEM:return Z_MEM_ERROR$1;case SYNC:default:return Z_STREAM_ERROR$1}return e.next_out=o,e.avail_out=l,e.next_in=i,e.avail_in=s,r.hold=f,r.bits=c,(r.wsize||d!==e.avail_out&&r.mode<BAD&&(r.mode<CHECK||t!==Z_FINISH$1))&&updatewindow(e,e.output,e.next_out,d-e.avail_out),u-=e.avail_in,d-=e.avail_out,e.total_in+=u,e.total_out+=d,r.total+=d,r.wrap&&d&&(e.adler=r.check=r.flags?crc32_1(r.check,a,d,e.next_out-d):adler32_1(r.check,a,d,e.next_out-d)),e.data_type=r.bits+(r.last?64:0)+(r.mode===TYPE?128:0)+(r.mode===LEN_||r.mode===COPY_?256:0),(0===u&&0===d||t===Z_FINISH$1)&&T===Z_OK$1&&(T=Z_BUF_ERROR),T},inflateEnd=function(e){if(!e||!e.state)return Z_STREAM_ERROR$1;var t=e.state;return t.window&&(t.window=null),e.state=null,Z_OK$1},inflateGetHeader=function(e,t){if(!e||!e.state)return Z_STREAM_ERROR$1;var r=e.state;return 0==(2&r.wrap)?Z_STREAM_ERROR$1:(r.head=t,t.done=!1,Z_OK$1)},inflateSetDictionary=function(e,t){var r,n=t.length;return e&&e.state?0!==(r=e.state).wrap&&r.mode!==DICT?Z_STREAM_ERROR$1:r.mode===DICT&&adler32_1(1,t,n,0)!==r.check?Z_DATA_ERROR$1:updatewindow(e,t,n,n)?(r.mode=MEM,Z_MEM_ERROR$1):(r.havedict=1,Z_OK$1):Z_STREAM_ERROR$1},inflateReset_1=inflateReset,inflateReset2_1=inflateReset2,inflateResetKeep_1=inflateResetKeep,inflateInit_1=inflateInit,inflateInit2_1=inflateInit2,inflate_2$1=inflate$2,inflateEnd_1=inflateEnd,inflateGetHeader_1=inflateGetHeader,inflateSetDictionary_1=inflateSetDictionary,inflateInfo="pako inflate (from Nodeca project)",inflate_1$2={inflateReset:inflateReset_1,inflateReset2:inflateReset2_1,inflateResetKeep:inflateResetKeep_1,inflateInit:inflateInit_1,inflateInit2:inflateInit2_1,inflate:inflate_2$1,inflateEnd:inflateEnd_1,inflateGetHeader:inflateGetHeader_1,inflateSetDictionary:inflateSetDictionary_1,inflateInfo:inflateInfo};function GZheader(){this.text=0,this.time=0,this.xflags=0,this.os=0,this.extra=null,this.extra_len=0,this.name="",this.comment="",this.hcrc=0,this.done=!1}var gzheader=GZheader,toString=Object.prototype.toString,Z_NO_FLUSH=constants$2.Z_NO_FLUSH,Z_FINISH=constants$2.Z_FINISH,Z_OK=constants$2.Z_OK,Z_STREAM_END=constants$2.Z_STREAM_END,Z_NEED_DICT=constants$2.Z_NEED_DICT,Z_STREAM_ERROR=constants$2.Z_STREAM_ERROR,Z_DATA_ERROR=constants$2.Z_DATA_ERROR,Z_MEM_ERROR=constants$2.Z_MEM_ERROR;function Inflate$1(e){this.options=common.assign({chunkSize:65536,windowBits:15,to:""},e||{});var t=this.options;t.raw&&t.windowBits>=0&&t.windowBits<16&&(t.windowBits=-t.windowBits,0===t.windowBits&&(t.windowBits=-15)),!(t.windowBits>=0&&t.windowBits<16)||e&&e.windowBits||(t.windowBits+=32),t.windowBits>15&&t.windowBits<48&&0==(15&t.windowBits)&&(t.windowBits|=15),this.err=0,this.msg="",this.ended=!1,this.chunks=[],this.strm=new zstream,this.strm.avail_out=0;var r=inflate_1$2.inflateInit2(this.strm,t.windowBits);if(r!==Z_OK)throw new Error(messages[r]);if(this.header=new gzheader,inflate_1$2.inflateGetHeader(this.strm,this.header),t.dictionary&&("string"==typeof t.dictionary?t.dictionary=strings.string2buf(t.dictionary):"[object ArrayBuffer]"===toString.call(t.dictionary)&&(t.dictionary=new Uint8Array(t.dictionary)),t.raw&&(r=inflate_1$2.inflateSetDictionary(this.strm,t.dictionary))!==Z_OK))throw new Error(messages[r])}function inflate$1(e,t){var r=new Inflate$1(t);if(r.push(e),r.err)throw r.msg||messages[r.err];return r.result}function inflateRaw$1(e,t){return(t=t||{}).raw=!0,inflate$1(e,t)}Inflate$1.prototype.push=function(e,t){var r,n,a,i=this.strm,o=this.options.chunkSize,s=this.options.dictionary;if(this.ended)return!1;for(n=t===~~t?t:!0===t?Z_FINISH:Z_NO_FLUSH,"[object ArrayBuffer]"===toString.call(e)?i.input=new Uint8Array(e):i.input=e,i.next_in=0,i.avail_in=i.input.length;;){for(0===i.avail_out&&(i.output=new Uint8Array(o),i.next_out=0,i.avail_out=o),(r=inflate_1$2.inflate(i,n))===Z_NEED_DICT&&s&&((r=inflate_1$2.inflateSetDictionary(i,s))===Z_OK?r=inflate_1$2.inflate(i,n):r===Z_DATA_ERROR&&(r=Z_NEED_DICT));i.avail_in>0&&r===Z_STREAM_END&&i.state.wrap>0&&0!==e[i.next_in];)inflate_1$2.inflateReset(i),r=inflate_1$2.inflate(i,n);switch(r){case Z_STREAM_ERROR:case Z_DATA_ERROR:case Z_NEED_DICT:case Z_MEM_ERROR:return this.onEnd(r),this.ended=!0,!1}if(a=i.avail_out,i.next_out&&(0===i.avail_out||r===Z_STREAM_END))if("string"===this.options.to){var l=strings.utf8border(i.output,i.next_out),f=i.next_out-l,c=strings.buf2string(i.output,l);i.next_out=f,i.avail_out=o-f,f&&i.output.set(i.output.subarray(l,l+f),0),this.onData(c)}else this.onData(i.output.length===i.next_out?i.output:i.output.subarray(0,i.next_out));if(r!==Z_OK||0!==a){if(r===Z_STREAM_END)return r=inflate_1$2.inflateEnd(this.strm),this.onEnd(r),this.ended=!0,!0;if(0===i.avail_in)break}}return!0},Inflate$1.prototype.onData=function(e){this.chunks.push(e)},Inflate$1.prototype.onEnd=function(e){e===Z_OK&&("string"===this.options.to?this.result=this.chunks.join(""):this.result=common.flattenChunks(this.chunks)),this.chunks=[],this.err=e,this.msg=this.strm.msg};var Inflate_1$1=Inflate$1,inflate_2=inflate$1,inflateRaw_1$1=inflateRaw$1,ungzip$1=inflate$1,constants=constants$2,inflate_1$1={Inflate:Inflate_1$1,inflate:inflate_2,inflateRaw:inflateRaw_1$1,ungzip:ungzip$1,constants:constants},inflate=inflate_1$1.inflate,inflate_1=inflate,DeflateDecoder=function(e){_inherits(r,BaseDecoder);var t=_createSuper(r);function r(){return _classCallCheck(this,r),t.apply(this,arguments)}return _createClass(r,[{key:"decodeBlock",value:function(e){return inflate_1(new Uint8Array(e)).buffer}}]),r}(),deflate=Object.freeze({__proto__:null,default:DeflateDecoder}),PackbitsDecoder=function(e){_inherits(r,BaseDecoder);var t=_createSuper(r);function r(){return _classCallCheck(this,r),t.apply(this,arguments)}return _createClass(r,[{key:"decodeBlock",value:function(e){for(var t=new DataView(e),r=[],n=0;n<e.byteLength;++n){var a=t.getInt8(n);if(a<0){var i=t.getUint8(n+1);a=-a;for(var o=0;o<=a;++o)r.push(i);n+=1}else{for(var s=0;s<=a;++s)r.push(t.getUint8(n+s+1));n+=a+1}}return new Uint8Array(r).buffer}}]),r}(),packbits=Object.freeze({__proto__:null,default:PackbitsDecoder}),LercDecode={exports:{}},module;module=LercDecode,
/* Copyright 2015-2021 Esri. Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 @preserve */
function(){var e,t,r,n,a,i,o,s,l,f,c,u,d,h,p,m,g=(e={defaultNoDataValue:-34027999387901484e22,decode:function(i,o){var s=(o=o||{}).encodedMaskData||null===o.encodedMaskData,l=a(i,o.inputOffset||0,s),f=null!==o.noDataValue?o.noDataValue:e.defaultNoDataValue,c=t(l,o.pixelType||Float32Array,o.encodedMaskData,f,o.returnMask),u={width:l.width,height:l.height,pixelData:c.resultPixels,minValue:c.minValue,maxValue:l.pixels.maxValue,noDataValue:f};return c.resultMask&&(u.maskData=c.resultMask),o.returnEncodedMask&&l.mask&&(u.encodedMaskData=l.mask.bitset?l.mask.bitset:null),o.returnFileInfo&&(u.fileInfo=r(l),o.computeUsedBitDepths&&(u.fileInfo.bitDepths=n(l))),u}},t=function(e,t,r,n,a){var o,s,l,f=0,c=e.pixels.numBlocksX,u=e.pixels.numBlocksY,d=Math.floor(e.width/c),h=Math.floor(e.height/u),p=2*e.maxZError,m=Number.MAX_VALUE;r=r||(e.mask?e.mask.bitset:null),s=new t(e.width*e.height),a&&r&&(l=new Uint8Array(e.width*e.height));for(var g,y,_=new Float32Array(d*h),b=0;b<=u;b++){var v=b!==u?h:e.height%u;if(0!==v)for(var w=0;w<=c;w++){var k=w!==c?d:e.width%c;if(0!==k){var T,E,x,S,D=b*e.width*h+w*d,A=e.width-k,M=e.pixels.blocks[f];if(M.encoding<2?(0===M.encoding?T=M.rawData:(i(M.stuffedData,M.bitsPerPixel,M.numValidPixels,M.offset,p,_,e.pixels.maxValue),T=_),E=0):x=2===M.encoding?0:M.offset,r)for(y=0;y<v;y++){for(7&D&&(S=r[D>>3],S<<=7&D),g=0;g<k;g++)7&D||(S=r[D>>3]),128&S?(l&&(l[D]=1),m=m>(o=M.encoding<2?T[E++]:x)?o:m,s[D++]=o):(l&&(l[D]=0),s[D++]=n),S<<=1;D+=A}else if(M.encoding<2)for(y=0;y<v;y++){for(g=0;g<k;g++)m=m>(o=T[E++])?o:m,s[D++]=o;D+=A}else for(m=m>x?x:m,y=0;y<v;y++){for(g=0;g<k;g++)s[D++]=x;D+=A}if(1===M.encoding&&E!==M.numValidPixels)throw"Block and Mask do not match";f++}}}return{resultPixels:s,resultMask:l,minValue:m}},r=function(e){return{fileIdentifierString:e.fileIdentifierString,fileVersion:e.fileVersion,imageType:e.imageType,height:e.height,width:e.width,maxZError:e.maxZError,eofOffset:e.eofOffset,mask:e.mask?{numBlocksX:e.mask.numBlocksX,numBlocksY:e.mask.numBlocksY,numBytes:e.mask.numBytes,maxValue:e.mask.maxValue}:null,pixels:{numBlocksX:e.pixels.numBlocksX,numBlocksY:e.pixels.numBlocksY,numBytes:e.pixels.numBytes,maxValue:e.pixels.maxValue,noDataValue:e.noDataValue}}},n=function(e){for(var t=e.pixels.numBlocksX*e.pixels.numBlocksY,r={},n=0;n<t;n++){var a=e.pixels.blocks[n];0===a.encoding?r.float32=!0:1===a.encoding?r[a.bitsPerPixel]=!0:r[0]=!0}return Object.keys(r)},a=function(e,t,r){var n={},a=new Uint8Array(e,t,10);if(n.fileIdentifierString=String.fromCharCode.apply(null,a),"CntZImage"!==n.fileIdentifierString.trim())throw"Unexpected file identifier string: "+n.fileIdentifierString;t+=10;var i=new DataView(e,t,24);if(n.fileVersion=i.getInt32(0,!0),n.imageType=i.getInt32(4,!0),n.height=i.getUint32(8,!0),n.width=i.getUint32(12,!0),n.maxZError=i.getFloat64(16,!0),t+=24,!r)if(i=new DataView(e,t,16),n.mask={},n.mask.numBlocksY=i.getUint32(0,!0),n.mask.numBlocksX=i.getUint32(4,!0),n.mask.numBytes=i.getUint32(8,!0),n.mask.maxValue=i.getFloat32(12,!0),t+=16,n.mask.numBytes>0){var o=new Uint8Array(Math.ceil(n.width*n.height/8)),s=(i=new DataView(e,t,n.mask.numBytes)).getInt16(0,!0),l=2,f=0;do{if(s>0)for(;s--;)o[f++]=i.getUint8(l++);else{var c=i.getUint8(l++);for(s=-s;s--;)o[f++]=c}s=i.getInt16(l,!0),l+=2}while(l<n.mask.numBytes);if(-32768!==s||f<o.length)throw"Unexpected end of mask RLE encoding";n.mask.bitset=o,t+=n.mask.numBytes}else 0==(n.mask.numBytes|n.mask.numBlocksY|n.mask.maxValue)&&(n.mask.bitset=new Uint8Array(Math.ceil(n.width*n.height/8)));i=new DataView(e,t,16),n.pixels={},n.pixels.numBlocksY=i.getUint32(0,!0),n.pixels.numBlocksX=i.getUint32(4,!0),n.pixels.numBytes=i.getUint32(8,!0),n.pixels.maxValue=i.getFloat32(12,!0),t+=16;var u=n.pixels.numBlocksX,d=n.pixels.numBlocksY,h=u+(n.width%u>0?1:0),p=d+(n.height%d>0?1:0);n.pixels.blocks=new Array(h*p);for(var m=0,g=0;g<p;g++)for(var y=0;y<h;y++){var _=0,b=e.byteLength-t;i=new DataView(e,t,Math.min(10,b));var v={};n.pixels.blocks[m++]=v;var w=i.getUint8(0);if(_++,v.encoding=63&w,v.encoding>3)throw"Invalid block encoding ("+v.encoding+")";if(2!==v.encoding){if(0!==w&&2!==w){if(w>>=6,v.offsetType=w,2===w)v.offset=i.getInt8(1),_++;else if(1===w)v.offset=i.getInt16(1,!0),_+=2;else{if(0!==w)throw"Invalid block offset type";v.offset=i.getFloat32(1,!0),_+=4}if(1===v.encoding)if(w=i.getUint8(_),_++,v.bitsPerPixel=63&w,w>>=6,v.numValidPixelsType=w,2===w)v.numValidPixels=i.getUint8(_),_++;else if(1===w)v.numValidPixels=i.getUint16(_,!0),_+=2;else{if(0!==w)throw"Invalid valid pixel count type";v.numValidPixels=i.getUint32(_,!0),_+=4}}var k;if(t+=_,3!==v.encoding)if(0===v.encoding){var T=(n.pixels.numBytes-1)/4;if(T!==Math.floor(T))throw"uncompressed block has invalid length";k=new ArrayBuffer(4*T),new Uint8Array(k).set(new Uint8Array(e,t,4*T));var E=new Float32Array(k);v.rawData=E,t+=4*T}else if(1===v.encoding){var x=Math.ceil(v.numValidPixels*v.bitsPerPixel/8),S=Math.ceil(x/4);k=new ArrayBuffer(4*S),new Uint8Array(k).set(new Uint8Array(e,t,x)),v.stuffedData=new Uint32Array(k),t+=x}}else t++}return n.eofOffset=t,n},i=function(e,t,r,n,a,i,o){var s,l,f,c=(1<<t)-1,u=0,d=0,h=Math.ceil((o-n)/a),p=4*e.length-Math.ceil(t*r/8);for(e[e.length-1]<<=8*p,s=0;s<r;s++){if(0===d&&(f=e[u++],d=32),d>=t)l=f>>>d-t&c,d-=t;else{var m=t-d;l=(f&c)<<m&c,l+=(f=e[u++])>>>(d=32-m)}i[s]=l<h?n+l*a:o}return i},e),y=(o=function(e,t,r,n,a,i,o,s){var l,f,c,u,d,h=(1<<r)-1,p=0,m=0,g=4*e.length-Math.ceil(r*n/8);if(e[e.length-1]<<=8*g,a)for(l=0;l<n;l++)0===m&&(c=e[p++],m=32),m>=r?(f=c>>>m-r&h,m-=r):(f=(c&h)<<(u=r-m)&h,f+=(c=e[p++])>>>(m=32-u)),t[l]=a[f];else for(d=Math.ceil((s-i)/o),l=0;l<n;l++)0===m&&(c=e[p++],m=32),m>=r?(f=c>>>m-r&h,m-=r):(f=(c&h)<<(u=r-m)&h,f+=(c=e[p++])>>>(m=32-u)),t[l]=f<d?i+f*o:s},s=function(e,t,r,n,a,i){var o,s=(1<<t)-1,l=0,f=0,c=0,u=0,d=0,h=[],p=4*e.length-Math.ceil(t*r/8);e[e.length-1]<<=8*p;var m=Math.ceil((i-n)/a);for(f=0;f<r;f++)0===u&&(o=e[l++],u=32),u>=t?(d=o>>>u-t&s,u-=t):(d=(o&s)<<(c=t-u)&s,d+=(o=e[l++])>>>(u=32-c)),h[f]=d<m?n+d*a:i;return h.unshift(n),h},l=function(e,t,r,n,a,i,o,s){var l,f,c,u,d=(1<<r)-1,h=0,p=0,m=0;if(a)for(l=0;l<n;l++)0===p&&(c=e[h++],p=32,m=0),p>=r?(f=c>>>m&d,p-=r,m+=r):(f=c>>>m&d,p=32-(u=r-p),f|=((c=e[h++])&(1<<u)-1)<<r-u,m=u),t[l]=a[f];else{var g=Math.ceil((s-i)/o);for(l=0;l<n;l++)0===p&&(c=e[h++],p=32,m=0),p>=r?(f=c>>>m&d,p-=r,m+=r):(f=c>>>m&d,p=32-(u=r-p),f|=((c=e[h++])&(1<<u)-1)<<r-u,m=u),t[l]=f<g?i+f*o:s}return t},f=function(e,t,r,n,a,i){var o,s=(1<<t)-1,l=0,f=0,c=0,u=0,d=0,h=0,p=[],m=Math.ceil((i-n)/a);for(f=0;f<r;f++)0===u&&(o=e[l++],u=32,h=0),u>=t?(d=o>>>h&s,u-=t,h+=t):(d=o>>>h&s,u=32-(c=t-u),d|=((o=e[l++])&(1<<c)-1)<<t-c,h=c),p[f]=d<m?n+d*a:i;return p.unshift(n),p},c=function(e,t,r,n){var a,i,o,s,l=(1<<r)-1,f=0,c=0,u=4*e.length-Math.ceil(r*n/8);for(e[e.length-1]<<=8*u,a=0;a<n;a++)0===c&&(o=e[f++],c=32),c>=r?(i=o>>>c-r&l,c-=r):(i=(o&l)<<(s=r-c)&l,i+=(o=e[f++])>>>(c=32-s)),t[a]=i;return t},u=function(e,t,r,n){var a,i,o,s,l=(1<<r)-1,f=0,c=0,u=0;for(a=0;a<n;a++)0===c&&(o=e[f++],c=32,u=0),c>=r?(i=o>>>u&l,c-=r,u+=r):(i=o>>>u&l,c=32-(s=r-c),i|=((o=e[f++])&(1<<s)-1)<<r-s,u=s),t[a]=i;return t},d={HUFFMAN_LUT_BITS_MAX:12,computeChecksumFletcher32:function(e){for(var t=65535,r=65535,n=e.length,a=Math.floor(n/2),i=0;a;){var o=a>=359?359:a;a-=o;do{t+=e[i++]<<8,r+=t+=e[i++]}while(--o);t=(65535&t)+(t>>>16),r=(65535&r)+(r>>>16)}return 1&n&&(r+=t+=e[i]<<8),((r=(65535&r)+(r>>>16))<<16|(t=(65535&t)+(t>>>16)))>>>0},readHeaderInfo:function(e,t){var r=t.ptr,n=new Uint8Array(e,r,6),a={};if(a.fileIdentifierString=String.fromCharCode.apply(null,n),0!==a.fileIdentifierString.lastIndexOf("Lerc2",0))throw"Unexpected file identifier string (expect Lerc2 ): "+a.fileIdentifierString;r+=6;var i,o=new DataView(e,r,8),s=o.getInt32(0,!0);if(a.fileVersion=s,r+=4,s>=3&&(a.checksum=o.getUint32(4,!0),r+=4),o=new DataView(e,r,12),a.height=o.getUint32(0,!0),a.width=o.getUint32(4,!0),r+=8,s>=4?(a.numDims=o.getUint32(8,!0),r+=4):a.numDims=1,o=new DataView(e,r,40),a.numValidPixel=o.getUint32(0,!0),a.microBlockSize=o.getInt32(4,!0),a.blobSize=o.getInt32(8,!0),a.imageType=o.getInt32(12,!0),a.maxZError=o.getFloat64(16,!0),a.zMin=o.getFloat64(24,!0),a.zMax=o.getFloat64(32,!0),r+=40,t.headerInfo=a,t.ptr=r,s>=3&&(i=s>=4?52:48,this.computeChecksumFletcher32(new Uint8Array(e,r-i,a.blobSize-14))!==a.checksum))throw"Checksum failed.";return!0},checkMinMaxRanges:function(e,t){var r=t.headerInfo,n=this.getDataTypeArray(r.imageType),a=r.numDims*this.getDataTypeSize(r.imageType),i=this.readSubArray(e,t.ptr,n,a),o=this.readSubArray(e,t.ptr+a,n,a);t.ptr+=2*a;var s,l=!0;for(s=0;s<r.numDims;s++)if(i[s]!==o[s]){l=!1;break}return r.minValues=i,r.maxValues=o,l},readSubArray:function(e,t,r,n){var a;if(r===Uint8Array)a=new Uint8Array(e,t,n);else{var i=new ArrayBuffer(n);new Uint8Array(i).set(new Uint8Array(e,t,n)),a=new r(i)}return a},readMask:function(e,t){var r,n,a=t.ptr,i=t.headerInfo,o=i.width*i.height,s=i.numValidPixel,l=new DataView(e,a,4),f={};if(f.numBytes=l.getUint32(0,!0),a+=4,(0===s||o===s)&&0!==f.numBytes)throw"invalid mask";if(0===s)r=new Uint8Array(Math.ceil(o/8)),f.bitset=r,n=new Uint8Array(o),t.pixels.resultMask=n,a+=f.numBytes;else if(f.numBytes>0){r=new Uint8Array(Math.ceil(o/8));var c=(l=new DataView(e,a,f.numBytes)).getInt16(0,!0),u=2,d=0,h=0;do{if(c>0)for(;c--;)r[d++]=l.getUint8(u++);else for(h=l.getUint8(u++),c=-c;c--;)r[d++]=h;c=l.getInt16(u,!0),u+=2}while(u<f.numBytes);if(-32768!==c||d<r.length)throw"Unexpected end of mask RLE encoding";n=new Uint8Array(o);var p=0,m=0;for(m=0;m<o;m++)7&m?(p=r[m>>3],p<<=7&m):p=r[m>>3],128&p&&(n[m]=1);t.pixels.resultMask=n,f.bitset=r,a+=f.numBytes}return t.ptr=a,t.mask=f,!0},readDataOneSweep:function(e,t,r,n){var a,i=t.ptr,o=t.headerInfo,s=o.numDims,l=o.width*o.height,f=o.imageType,c=o.numValidPixel*d.getDataTypeSize(f)*s,u=t.pixels.resultMask;if(r===Uint8Array)a=new Uint8Array(e,i,c);else{var h=new ArrayBuffer(c);new Uint8Array(h).set(new Uint8Array(e,i,c)),a=new r(h)}if(a.length===l*s)t.pixels.resultPixels=n?d.swapDimensionOrder(a,l,s,r,!0):a;else{t.pixels.resultPixels=new r(l*s);var p=0,m=0,g=0,y=0;if(s>1){if(n){for(m=0;m<l;m++)if(u[m])for(y=m,g=0;g<s;g++,y+=l)t.pixels.resultPixels[y]=a[p++]}else for(m=0;m<l;m++)if(u[m])for(y=m*s,g=0;g<s;g++)t.pixels.resultPixels[y+g]=a[p++]}else for(m=0;m<l;m++)u[m]&&(t.pixels.resultPixels[m]=a[p++])}return i+=c,t.ptr=i,!0},readHuffmanTree:function(e,t){var r=this.HUFFMAN_LUT_BITS_MAX,n=new DataView(e,t.ptr,16);if(t.ptr+=16,n.getInt32(0,!0)<2)throw"unsupported Huffman version";var a=n.getInt32(4,!0),i=n.getInt32(8,!0),o=n.getInt32(12,!0);if(i>=o)return!1;var s=new Uint32Array(o-i);d.decodeBits(e,t,s);var l,f,c,u,p=[];for(l=i;l<o;l++)p[f=l-(l<a?0:a)]={first:s[l-i],second:null};var m=e.byteLength-t.ptr,g=Math.ceil(m/4),y=new ArrayBuffer(4*g);new Uint8Array(y).set(new Uint8Array(e,t.ptr,m));var _,b=new Uint32Array(y),v=0,w=0;for(_=b[0],l=i;l<o;l++)(u=p[f=l-(l<a?0:a)].first)>0&&(p[f].second=_<<v>>>32-u,32-v>=u?32===(v+=u)&&(v=0,_=b[++w]):(v+=u-32,_=b[++w],p[f].second|=_>>>32-v));var k=0,T=0,E=new h;for(l=0;l<p.length;l++)void 0!==p[l]&&(k=Math.max(k,p[l].first));T=k>=r?r:k;var x,S,D,A,M,I=[];for(l=i;l<o;l++)if((u=p[f=l-(l<a?0:a)].first)>0)if(x=[u,f],u<=T)for(S=p[f].second<<T-u,D=1<<T-u,c=0;c<D;c++)I[S|c]=x;else for(S=p[f].second,M=E,A=u-1;A>=0;A--)S>>>A&1?(M.right||(M.right=new h),M=M.right):(M.left||(M.left=new h),M=M.left),0!==A||M.val||(M.val=x[1]);return{decodeLut:I,numBitsLUTQick:T,numBitsLUT:k,tree:E,stuffedData:b,srcPtr:w,bitPos:v}},readHuffman:function(e,t,r,n){var a,i,o,s,l,f,c,u,h,p=t.headerInfo.numDims,m=t.headerInfo.height,g=t.headerInfo.width,y=g*m,_=this.readHuffmanTree(e,t),b=_.decodeLut,v=_.tree,w=_.stuffedData,k=_.srcPtr,T=_.bitPos,E=_.numBitsLUTQick,x=_.numBitsLUT,S=0===t.headerInfo.imageType?128:0,D=t.pixels.resultMask,A=0;T>0&&(k++,T=0);var M,I=w[k],R=1===t.encodeMode,O=new r(y*p),C=O;if(p<2||R){for(M=0;M<p;M++)if(p>1&&(C=new r(O.buffer,y*M,y),A=0),t.headerInfo.numValidPixel===g*m)for(u=0,f=0;f<m;f++)for(c=0;c<g;c++,u++){if(i=0,l=s=I<<T>>>32-E,32-T<E&&(l=s|=w[k+1]>>>64-T-E),b[l])i=b[l][1],T+=b[l][0];else for(l=s=I<<T>>>32-x,32-T<x&&(l=s|=w[k+1]>>>64-T-x),a=v,h=0;h<x;h++)if(!(a=s>>>x-h-1&1?a.right:a.left).left&&!a.right){i=a.val,T=T+h+1;break}T>=32&&(T-=32,I=w[++k]),o=i-S,R?(o+=c>0?A:f>0?C[u-g]:A,o&=255,C[u]=o,A=o):C[u]=o}else for(u=0,f=0;f<m;f++)for(c=0;c<g;c++,u++)if(D[u]){if(i=0,l=s=I<<T>>>32-E,32-T<E&&(l=s|=w[k+1]>>>64-T-E),b[l])i=b[l][1],T+=b[l][0];else for(l=s=I<<T>>>32-x,32-T<x&&(l=s|=w[k+1]>>>64-T-x),a=v,h=0;h<x;h++)if(!(a=s>>>x-h-1&1?a.right:a.left).left&&!a.right){i=a.val,T=T+h+1;break}T>=32&&(T-=32,I=w[++k]),o=i-S,R?(c>0&&D[u-1]?o+=A:f>0&&D[u-g]?o+=C[u-g]:o+=A,o&=255,C[u]=o,A=o):C[u]=o}}else for(u=0,f=0;f<m;f++)for(c=0;c<g;c++)if(u=f*g+c,!D||D[u])for(M=0;M<p;M++,u+=y){if(i=0,l=s=I<<T>>>32-E,32-T<E&&(l=s|=w[k+1]>>>64-T-E),b[l])i=b[l][1],T+=b[l][0];else for(l=s=I<<T>>>32-x,32-T<x&&(l=s|=w[k+1]>>>64-T-x),a=v,h=0;h<x;h++)if(!(a=s>>>x-h-1&1?a.right:a.left).left&&!a.right){i=a.val,T=T+h+1;break}T>=32&&(T-=32,I=w[++k]),o=i-S,C[u]=o}t.ptr=t.ptr+4*(k+1)+(T>0?4:0),t.pixels.resultPixels=O,p>1&&!n&&(t.pixels.resultPixels=d.swapDimensionOrder(O,y,p,r))},decodeBits:function(e,t,r,n,a){var i=t.headerInfo,d=i.fileVersion,h=0,p=e.byteLength-t.ptr>=5?5:e.byteLength-t.ptr,m=new DataView(e,t.ptr,p),g=m.getUint8(0);h++;var y=g>>6,_=0===y?4:3-y,b=(32&g)>0,v=31&g,w=0;if(1===_)w=m.getUint8(h),h++;else if(2===_)w=m.getUint16(h,!0),h+=2;else{if(4!==_)throw"Invalid valid pixel count type";w=m.getUint32(h,!0),h+=4}var k,T,E,x,S,D,A,M,I,R=2*i.maxZError,O=i.numDims>1?i.maxValues[a]:i.zMax;if(b){for(t.counter.lut++,M=m.getUint8(h),h++,x=Math.ceil((M-1)*v/8),S=Math.ceil(x/4),T=new ArrayBuffer(4*S),E=new Uint8Array(T),t.ptr+=h,E.set(new Uint8Array(e,t.ptr,x)),A=new Uint32Array(T),t.ptr+=x,I=0;M-1>>>I;)I++;x=Math.ceil(w*I/8),S=Math.ceil(x/4),T=new ArrayBuffer(4*S),(E=new Uint8Array(T)).set(new Uint8Array(e,t.ptr,x)),k=new Uint32Array(T),t.ptr+=x,D=d>=3?f(A,v,M-1,n,R,O):s(A,v,M-1,n,R,O),d>=3?l(k,r,I,w,D):o(k,r,I,w,D)}else t.counter.bitstuffer++,I=v,t.ptr+=h,I>0&&(x=Math.ceil(w*I/8),S=Math.ceil(x/4),T=new ArrayBuffer(4*S),(E=new Uint8Array(T)).set(new Uint8Array(e,t.ptr,x)),k=new Uint32Array(T),t.ptr+=x,d>=3?null==n?u(k,r,I,w):l(k,r,I,w,!1,n,R,O):null==n?c(k,r,I,w):o(k,r,I,w,!1,n,R,O))},readTiles:function(e,t,r,n){var a=t.headerInfo,i=a.width,o=a.height,s=i*o,l=a.microBlockSize,f=a.imageType,c=d.getDataTypeSize(f),u=Math.ceil(i/l),h=Math.ceil(o/l);t.pixels.numBlocksY=h,t.pixels.numBlocksX=u,t.pixels.ptr=0;var p,m,g,y,_,b,v,w,k,T,E=0,x=0,S=0,D=0,A=0,M=0,I=0,R=0,O=0,C=0,P=0,L=0,U=0,B=0,$=0,N=new r(l*l),z=o%l||l,Z=i%l||l,G=a.numDims,j=t.pixels.resultMask,V=t.pixels.resultPixels,F=a.fileVersion>=5?14:15,K=a.zMax;for(S=0;S<h;S++)for(A=S!==h-1?l:z,D=0;D<u;D++)for(C=S*i*l+D*l,P=i-(M=D!==u-1?l:Z),w=0;w<G;w++){if(G>1?(T=V,C=S*i*l+D*l,V=new r(t.pixels.resultPixels.buffer,s*w*c,s),K=a.maxValues[w]):T=null,I=e.byteLength-t.ptr,m={},$=0,R=(p=new DataView(e,t.ptr,Math.min(10,I))).getUint8(0),$++,k=a.fileVersion>=5?4&R:0,O=R>>6&255,(R>>2&F)!=(D*l>>3&F))throw"integrity issue";if(k&&0===w)throw"integrity issue";if((_=3&R)>3)throw t.ptr+=$,"Invalid block encoding ("+_+")";if(2!==_)if(0===_){if(k)throw"integrity issue";if(t.counter.uncompressed++,t.ptr+=$,L=(L=A*M*c)<(U=e.byteLength-t.ptr)?L:U,g=new ArrayBuffer(L%c==0?L:L+c-L%c),new Uint8Array(g).set(new Uint8Array(e,t.ptr,L)),y=new r(g),B=0,j)for(E=0;E<A;E++){for(x=0;x<M;x++)j[C]&&(V[C]=y[B++]),C++;C+=P}else for(E=0;E<A;E++){for(x=0;x<M;x++)V[C++]=y[B++];C+=P}t.ptr+=B*c}else if(b=d.getDataTypeUsed(k&&f<6?4:f,O),v=d.getOnePixel(m,$,b,p),$+=d.getDataTypeSize(b),3===_)if(t.ptr+=$,t.counter.constantoffset++,j)for(E=0;E<A;E++){for(x=0;x<M;x++)j[C]&&(V[C]=k?Math.min(K,T[C]+v):v),C++;C+=P}else for(E=0;E<A;E++){for(x=0;x<M;x++)V[C]=k?Math.min(K,T[C]+v):v,C++;C+=P}else if(t.ptr+=$,d.decodeBits(e,t,N,v,w),$=0,k)if(j)for(E=0;E<A;E++){for(x=0;x<M;x++)j[C]&&(V[C]=N[$++]+T[C]),C++;C+=P}else for(E=0;E<A;E++){for(x=0;x<M;x++)V[C]=N[$++]+T[C],C++;C+=P}else if(j)for(E=0;E<A;E++){for(x=0;x<M;x++)j[C]&&(V[C]=N[$++]),C++;C+=P}else for(E=0;E<A;E++){for(x=0;x<M;x++)V[C++]=N[$++];C+=P}else{if(k)if(j)for(E=0;E<A;E++)for(x=0;x<M;x++)j[C]&&(V[C]=T[C]),C++;else for(E=0;E<A;E++)for(x=0;x<M;x++)V[C]=T[C],C++;t.counter.constant++,t.ptr+=$}}G>1&&!n&&(t.pixels.resultPixels=d.swapDimensionOrder(t.pixels.resultPixels,s,G,r))},formatFileInfo:function(e){return{fileIdentifierString:e.headerInfo.fileIdentifierString,fileVersion:e.headerInfo.fileVersion,imageType:e.headerInfo.imageType,height:e.headerInfo.height,width:e.headerInfo.width,numValidPixel:e.headerInfo.numValidPixel,microBlockSize:e.headerInfo.microBlockSize,blobSize:e.headerInfo.blobSize,maxZError:e.headerInfo.maxZError,pixelType:d.getPixelType(e.headerInfo.imageType),eofOffset:e.eofOffset,mask:e.mask?{numBytes:e.mask.numBytes}:null,pixels:{numBlocksX:e.pixels.numBlocksX,numBlocksY:e.pixels.numBlocksY,maxValue:e.headerInfo.zMax,minValue:e.headerInfo.zMin,noDataValue:e.noDataValue}}},constructConstantSurface:function(e,t){var r=e.headerInfo.zMax,n=e.headerInfo.zMin,a=e.headerInfo.maxValues,i=e.headerInfo.numDims,o=e.headerInfo.height*e.headerInfo.width,s=0,l=0,f=0,c=e.pixels.resultMask,u=e.pixels.resultPixels;if(c)if(i>1){if(t)for(s=0;s<i;s++)for(f=s*o,r=a[s],l=0;l<o;l++)c[l]&&(u[f+l]=r);else for(l=0;l<o;l++)if(c[l])for(f=l*i,s=0;s<i;s++)u[f+i]=a[s]}else for(l=0;l<o;l++)c[l]&&(u[l]=r);else if(i>1&&n!==r)if(t)for(s=0;s<i;s++)for(f=s*o,r=a[s],l=0;l<o;l++)u[f+l]=r;else for(l=0;l<o;l++)for(f=l*i,s=0;s<i;s++)u[f+s]=a[s];else for(l=0;l<o*i;l++)u[l]=r},getDataTypeArray:function(e){var t;switch(e){case 0:t=Int8Array;break;case 1:t=Uint8Array;break;case 2:t=Int16Array;break;case 3:t=Uint16Array;break;case 4:t=Int32Array;break;case 5:t=Uint32Array;break;case 6:t=Float32Array;break;case 7:t=Float64Array;break;default:t=Float32Array}return t},getPixelType:function(e){var t;switch(e){case 0:t="S8";break;case 1:t="U8";break;case 2:t="S16";break;case 3:t="U16";break;case 4:t="S32";break;case 5:t="U32";break;case 6:t="F32";break;case 7:t="F64";break;default:t="F32"}return t},isValidPixelValue:function(e,t){if(null==t)return!1;var r;switch(e){case 0:r=t>=-128&&t<=127;break;case 1:r=t>=0&&t<=255;break;case 2:r=t>=-32768&&t<=32767;break;case 3:r=t>=0&&t<=65536;break;case 4:r=t>=-2147483648&&t<=2147483647;break;case 5:r=t>=0&&t<=4294967296;break;case 6:r=t>=-34027999387901484e22&&t<=34027999387901484e22;break;case 7:r=t>=-17976931348623157e292&&t<=17976931348623157e292;break;default:r=!1}return r},getDataTypeSize:function(e){var t=0;switch(e){case 0:case 1:t=1;break;case 2:case 3:t=2;break;case 4:case 5:case 6:t=4;break;case 7:t=8;break;default:t=e}return t},getDataTypeUsed:function(e,t){var r=e;switch(e){case 2:case 4:r=e-t;break;case 3:case 5:r=e-2*t;break;case 6:r=0===t?e:1===t?2:1;break;case 7:r=0===t?e:e-2*t+1;break;default:r=e}return r},getOnePixel:function(e,t,r,n){var a=0;switch(r){case 0:a=n.getInt8(t);break;case 1:a=n.getUint8(t);break;case 2:a=n.getInt16(t,!0);break;case 3:a=n.getUint16(t,!0);break;case 4:a=n.getInt32(t,!0);break;case 5:a=n.getUInt32(t,!0);break;case 6:a=n.getFloat32(t,!0);break;case 7:a=n.getFloat64(t,!0);break;default:throw"the decoder does not understand this pixel type"}return a},swapDimensionOrder:function(e,t,r,n,a){var i=0,o=0,s=0,l=0,f=e;if(r>1)if(f=new n(t*r),a)for(i=0;i<t;i++)for(l=i,s=0;s<r;s++,l+=t)f[l]=e[o++];else for(i=0;i<t;i++)for(l=i,s=0;s<r;s++,l+=t)f[o++]=e[l];return f}},h=function(e,t,r){this.val=e,this.left=t,this.right=r},{decode:function(e,t){var r=(t=t||{}).noDataValue,n=0,a={};a.ptr=t.inputOffset||0,a.pixels={},d.readHeaderInfo(e,a);var i=a.headerInfo,o=i.fileVersion,s=d.getDataTypeArray(i.imageType);if(o>5)throw"unsupported lerc version 2."+o;d.readMask(e,a),i.numValidPixel===i.width*i.height||a.pixels.resultMask||(a.pixels.resultMask=t.maskData);var l=i.width*i.height;a.pixels.resultPixels=new s(l*i.numDims),a.counter={onesweep:0,uncompressed:0,lut:0,bitstuffer:0,constant:0,constantoffset:0};var f,c=!t.returnPixelInterleavedDims;if(0!==i.numValidPixel)if(i.zMax===i.zMin)d.constructConstantSurface(a,c);else if(o>=4&&d.checkMinMaxRanges(e,a))d.constructConstantSurface(a,c);else{var u=new DataView(e,a.ptr,2),h=u.getUint8(0);if(a.ptr++,h)d.readDataOneSweep(e,a,s,c);else if(o>1&&i.imageType<=1&&Math.abs(i.maxZError-.5)<1e-5){var p=u.getUint8(1);if(a.ptr++,a.encodeMode=p,p>2||o<4&&p>1)throw"Invalid Huffman flag "+p;p?d.readHuffman(e,a,s,c):d.readTiles(e,a,s,c)}else d.readTiles(e,a,s,c)}a.eofOffset=a.ptr,t.inputOffset?(f=a.headerInfo.blobSize+t.inputOffset-a.ptr,Math.abs(f)>=1&&(a.eofOffset=t.inputOffset+a.headerInfo.blobSize)):(f=a.headerInfo.blobSize-a.ptr,Math.abs(f)>=1&&(a.eofOffset=a.headerInfo.blobSize));var m={width:i.width,height:i.height,pixelData:a.pixels.resultPixels,minValue:i.zMin,maxValue:i.zMax,validPixelCount:i.numValidPixel,dimCount:i.numDims,dimStats:{minValues:i.minValues,maxValues:i.maxValues},maskData:a.pixels.resultMask};if(a.pixels.resultMask&&d.isValidPixelValue(i.imageType,r)){var g=a.pixels.resultMask;for(n=0;n<l;n++)g[n]||(m.pixelData[n]=r);m.noDataValue=r}return a.noDataValue=r,t.returnFileInfo&&(m.fileInfo=d.formatFileInfo(a)),m},getBandCount:function(e){for(var t=0,r=0,n={ptr:0,pixels:{}};r<e.byteLength-58;)d.readHeaderInfo(e,n),r+=n.headerInfo.blobSize,t++,n.ptr=r;return t}}),_=(p=new ArrayBuffer(4),m=new Uint8Array(p),new Uint32Array(p)[0]=1,1===m[0]),b={decode:function(e,t){if(!_)throw"Big endian system is not supported.";var r,n,a=(t=t||{}).inputOffset||0,i=new Uint8Array(e,a,10),o=String.fromCharCode.apply(null,i);if("CntZImage"===o.trim())r=g,n=1;else{if("Lerc2"!==o.substring(0,5))throw"Unexpected file identifier string: "+o;r=y,n=2}for(var s,l,f,c,u,d,h=0,p=e.byteLength-10,m=[],b={width:0,height:0,pixels:[],pixelType:t.pixelType,mask:null,statistics:[]},v=0;a<p;){var w=r.decode(e,{inputOffset:a,encodedMaskData:s,maskData:f,returnMask:0===h,returnEncodedMask:0===h,returnFileInfo:!0,returnPixelInterleavedDims:t.returnPixelInterleavedDims,pixelType:t.pixelType||null,noDataValue:t.noDataValue||null});a=w.fileInfo.eofOffset,f=w.maskData,0===h&&(s=w.encodedMaskData,b.width=w.width,b.height=w.height,b.dimCount=w.dimCount||1,b.pixelType=w.pixelType||w.fileInfo.pixelType,b.mask=f),n>1&&(f&&m.push(f),w.fileInfo.mask&&w.fileInfo.mask.numBytes>0&&v++),h++,b.pixels.push(w.pixelData),b.statistics.push({minValue:w.minValue,maxValue:w.maxValue,noDataValue:w.noDataValue,dimStats:w.dimStats})}if(n>1&&v>1){for(d=b.width*b.height,b.bandMasks=m,(f=new Uint8Array(d)).set(m[0]),c=1;c<m.length;c++)for(l=m[c],u=0;u<d;u++)f[u]=f[u]&l[u];b.maskData=f}return b}};module.exports?module.exports=b:this.Lerc=b}();var Lerc=LercDecode.exports,fieldTagNames={315:"Artist",258:"BitsPerSample",265:"CellLength",264:"CellWidth",320:"ColorMap",259:"Compression",33432:"Copyright",306:"DateTime",338:"ExtraSamples",266:"FillOrder",289:"FreeByteCounts",288:"FreeOffsets",291:"GrayResponseCurve",290:"GrayResponseUnit",316:"HostComputer",270:"ImageDescription",257:"ImageLength",256:"ImageWidth",271:"Make",281:"MaxSampleValue",280:"MinSampleValue",272:"Model",254:"NewSubfileType",274:"Orientation",262:"PhotometricInterpretation",284:"PlanarConfiguration",296:"ResolutionUnit",278:"RowsPerStrip",277:"SamplesPerPixel",305:"Software",279:"StripByteCounts",273:"StripOffsets",255:"SubfileType",263:"Threshholding",282:"XResolution",283:"YResolution",326:"BadFaxLines",327:"CleanFaxData",343:"ClipPath",328:"ConsecutiveBadFaxLines",433:"Decode",434:"DefaultImageColor",269:"DocumentName",336:"DotRange",321:"HalftoneHints",346:"Indexed",347:"JPEGTables",285:"PageName",297:"PageNumber",317:"Predictor",319:"PrimaryChromaticities",532:"ReferenceBlackWhite",339:"SampleFormat",340:"SMinSampleValue",341:"SMaxSampleValue",559:"StripRowCounts",330:"SubIFDs",292:"T4Options",293:"T6Options",325:"TileByteCounts",323:"TileLength",324:"TileOffsets",322:"TileWidth",301:"TransferFunction",318:"WhitePoint",344:"XClipPathUnits",286:"XPosition",529:"YCbCrCoefficients",531:"YCbCrPositioning",530:"YCbCrSubSampling",345:"YClipPathUnits",287:"YPosition",37378:"ApertureValue",40961:"ColorSpace",36868:"DateTimeDigitized",36867:"DateTimeOriginal",34665:"Exif IFD",36864:"ExifVersion",33434:"ExposureTime",41728:"FileSource",37385:"Flash",40960:"FlashpixVersion",33437:"FNumber",42016:"ImageUniqueID",37384:"LightSource",37500:"MakerNote",37377:"ShutterSpeedValue",37510:"UserComment",33723:"IPTC",34675:"ICC Profile",700:"XMP",42112:"GDAL_METADATA",42113:"GDAL_NODATA",34377:"Photoshop",33550:"ModelPixelScale",33922:"ModelTiepoint",34264:"ModelTransformation",34735:"GeoKeyDirectory",34736:"GeoDoubleParams",34737:"GeoAsciiParams",50674:"LercParameters"},fieldTags={};for(var key in fieldTagNames)fieldTagNames.hasOwnProperty(key)&&(fieldTags[fieldTagNames[key]]=parseInt(key,10));fieldTags.BitsPerSample,fieldTags.ExtraSamples,fieldTags.SampleFormat,fieldTags.StripByteCounts,fieldTags.StripOffsets,fieldTags.StripRowCounts,fieldTags.TileByteCounts,fieldTags.TileOffsets,fieldTags.SubIFDs;var fieldTypeNames={1:"BYTE",2:"ASCII",3:"SHORT",4:"LONG",5:"RATIONAL",6:"SBYTE",7:"UNDEFINED",8:"SSHORT",9:"SLONG",10:"SRATIONAL",11:"FLOAT",12:"DOUBLE",13:"IFD",16:"LONG8",17:"SLONG8",18:"IFD8"},fieldTypes={};for(var _key in fieldTypeNames)fieldTypeNames.hasOwnProperty(_key)&&(fieldTypes[fieldTypeNames[_key]]=parseInt(_key,10));var LercParameters={Version:0,AddCompression:1},LercAddCompression={None:0,Deflate:1},geoKeyNames={1024:"GTModelTypeGeoKey",1025:"GTRasterTypeGeoKey",1026:"GTCitationGeoKey",2048:"GeographicTypeGeoKey",2049:"GeogCitationGeoKey",2050:"GeogGeodeticDatumGeoKey",2051:"GeogPrimeMeridianGeoKey",2052:"GeogLinearUnitsGeoKey",2053:"GeogLinearUnitSizeGeoKey",2054:"GeogAngularUnitsGeoKey",2055:"GeogAngularUnitSizeGeoKey",2056:"GeogEllipsoidGeoKey",2057:"GeogSemiMajorAxisGeoKey",2058:"GeogSemiMinorAxisGeoKey",2059:"GeogInvFlatteningGeoKey",2060:"GeogAzimuthUnitsGeoKey",2061:"GeogPrimeMeridianLongGeoKey",2062:"GeogTOWGS84GeoKey",3072:"ProjectedCSTypeGeoKey",3073:"PCSCitationGeoKey",3074:"ProjectionGeoKey",3075:"ProjCoordTransGeoKey",3076:"ProjLinearUnitsGeoKey",3077:"ProjLinearUnitSizeGeoKey",3078:"ProjStdParallel1GeoKey",3079:"ProjStdParallel2GeoKey",3080:"ProjNatOriginLongGeoKey",3081:"ProjNatOriginLatGeoKey",3082:"ProjFalseEastingGeoKey",3083:"ProjFalseNorthingGeoKey",3084:"ProjFalseOriginLongGeoKey",3085:"ProjFalseOriginLatGeoKey",3086:"ProjFalseOriginEastingGeoKey",3087:"ProjFalseOriginNorthingGeoKey",3088:"ProjCenterLongGeoKey",3089:"ProjCenterLatGeoKey",3090:"ProjCenterEastingGeoKey",3091:"ProjCenterNorthingGeoKey",3092:"ProjScaleAtNatOriginGeoKey",3093:"ProjScaleAtCenterGeoKey",3094:"ProjAzimuthAngleGeoKey",3095:"ProjStraightVertPoleLongGeoKey",3096:"ProjRectifiedGridAngleGeoKey",4096:"VerticalCSTypeGeoKey",4097:"VerticalCitationGeoKey",4098:"VerticalDatumGeoKey",4099:"VerticalUnitsGeoKey"},geoKeys={};for(var _key2 in geoKeyNames)geoKeyNames.hasOwnProperty(_key2)&&(geoKeys[geoKeyNames[_key2]]=parseInt(_key2,10));var LercDecoder=function(e){_inherits(r,BaseDecoder);var t=_createSuper(r);function r(e){var n;return _classCallCheck(this,r),(n=t.call(this)).planarConfiguration=void 0!==e.PlanarConfiguration?e.PlanarConfiguration:1,n.samplesPerPixel=void 0!==e.SamplesPerPixel?e.SamplesPerPixel:1,n.addCompression=e.LercParameters[LercParameters.AddCompression],n}return _createClass(r,[{key:"decodeBlock",value:function(e){switch(this.addCompression){case LercAddCompression.None:break;case LercAddCompression.Deflate:e=inflate_1(new Uint8Array(e)).buffer;break;default:throw new Error("Unsupported LERC additional compression method identifier: ".concat(this.addCompression))}return Lerc.decode(e,{returnPixelInterleavedDims:1===this.planarConfiguration}).pixels[0].buffer}}]),r}(),lerc=Object.freeze({__proto__:null,default:LercDecoder});`;
var blob = new Blob([source], { type: "application/javascript" });
var url = URL.createObjectURL(blob);
function create2() {
  return new Worker(url);
}

// node_modules/ol/source/GeoTIFF.js
var __extends6 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var workerPool;
function getWorkerPool() {
  if (!workerPool) {
    workerPool = new pool_default(void 0, create2());
  }
  return workerPool;
}
function getBoundingBox(image) {
  try {
    return image.getBoundingBox();
  } catch (_3) {
    var fileDirectory = image.fileDirectory;
    return [0, 0, fileDirectory.ImageWidth, fileDirectory.ImageLength];
  }
}
function getOrigin(image) {
  try {
    return image.getOrigin().slice(0, 2);
  } catch (_3) {
    return [0, image.fileDirectory.ImageLength];
  }
}
function getResolution(image, referenceImage) {
  try {
    return image.getResolution(referenceImage)[0];
  } catch (_3) {
    return referenceImage.fileDirectory.ImageWidth / image.fileDirectory.ImageWidth;
  }
}
function getProjection(image) {
  var geoKeys = image.geoKeys;
  if (!geoKeys) {
    return null;
  }
  if (geoKeys.ProjectedCSTypeGeoKey) {
    var code = "EPSG:" + geoKeys.ProjectedCSTypeGeoKey;
    var projection = get(code);
    if (!projection) {
      var units = fromCode(geoKeys.ProjLinearUnitsGeoKey);
      if (units) {
        projection = new Projection_default({
          code,
          units
        });
      }
    }
    return projection;
  }
  if (geoKeys.GeographicTypeGeoKey) {
    var code = "EPSG:" + geoKeys.GeographicTypeGeoKey;
    var projection = get(code);
    if (!projection) {
      var units = fromCode(geoKeys.GeogAngularUnitsGeoKey);
      if (units) {
        projection = new Projection_default({
          code,
          units
        });
      }
    }
    return projection;
  }
  return null;
}
function getImagesForTIFF(tiff) {
  return tiff.getImageCount().then(function(count) {
    var requests = new Array(count);
    for (var i = 0; i < count; ++i) {
      requests[i] = tiff.getImage(i);
    }
    return Promise.all(requests);
  });
}
function getImagesForSource(source2) {
  var request;
  if (source2.overviews) {
    request = fromUrls(source2.url, source2.overviews);
  } else {
    request = fromUrl(source2.url);
  }
  return request.then(getImagesForTIFF);
}
function assertEqual(expected, got, tolerance, message, rejector) {
  if (Array.isArray(expected)) {
    var length_1 = expected.length;
    if (!Array.isArray(got) || length_1 != got.length) {
      var error = new Error(message);
      rejector(error);
      throw error;
    }
    for (var i = 0; i < length_1; ++i) {
      assertEqual(expected[i], got[i], tolerance, message, rejector);
    }
    return;
  }
  got = got;
  if (Math.abs(expected - got) > tolerance * expected) {
    throw new Error(message);
  }
}
function getMinForDataType(array) {
  if (array instanceof Int8Array) {
    return -128;
  }
  if (array instanceof Int16Array) {
    return -32768;
  }
  if (array instanceof Int32Array) {
    return -2147483648;
  }
  if (array instanceof Float32Array) {
    return 12e-39;
  }
  return 0;
}
function getMaxForDataType(array) {
  if (array instanceof Int8Array) {
    return 127;
  }
  if (array instanceof Uint8Array) {
    return 255;
  }
  if (array instanceof Uint8ClampedArray) {
    return 255;
  }
  if (array instanceof Int16Array) {
    return 32767;
  }
  if (array instanceof Uint16Array) {
    return 65535;
  }
  if (array instanceof Int32Array) {
    return 2147483647;
  }
  if (array instanceof Uint32Array) {
    return 4294967295;
  }
  if (array instanceof Float32Array) {
    return 34e37;
  }
  return 255;
}
var GeoTIFFSource = function(_super) {
  __extends6(GeoTIFFSource2, _super);
  function GeoTIFFSource2(options) {
    var _this = _super.call(this, {
      state: State_default.LOADING,
      tileGrid: null,
      projection: null,
      opaque: options.opaque,
      transition: options.transition
    }) || this;
    _this.sourceInfo_ = options.sources;
    var numSources = _this.sourceInfo_.length;
    _this.sourceImagery_ = new Array(numSources);
    _this.resolutionFactors_ = new Array(numSources);
    _this.samplesPerPixel_;
    _this.nodataValues_;
    _this.normalize_ = options.normalize !== false;
    _this.addAlpha_ = false;
    _this.error_ = null;
    _this.readMethod_ = options.convertToRGB ? "readRGB" : "readRasters";
    _this.setKey(_this.sourceInfo_.map(function(source2) {
      return source2.url;
    }).join(","));
    var self2 = _this;
    var requests = new Array(numSources);
    for (var i = 0; i < numSources; ++i) {
      requests[i] = getImagesForSource(_this.sourceInfo_[i]);
    }
    Promise.all(requests).then(function(sources) {
      self2.configure_(sources);
    }).catch(function(error) {
      console.error(error);
      self2.error_ = error;
      self2.setState(State_default.ERROR);
    });
    return _this;
  }
  GeoTIFFSource2.prototype.getError = function() {
    return this.error_;
  };
  GeoTIFFSource2.prototype.configure_ = function(sources) {
    var extent;
    var origin;
    var tileSizes;
    var resolutions;
    var samplesPerPixel = new Array(sources.length);
    var nodataValues = new Array(sources.length);
    var minZoom = 0;
    var sourceCount = sources.length;
    var _loop_1 = function(sourceIndex2) {
      var images = sources[sourceIndex2];
      var imageCount = images.length;
      var sourceExtent = void 0;
      var sourceOrigin = void 0;
      var sourceTileSizes = new Array(imageCount);
      var sourceResolutions = new Array(imageCount);
      nodataValues[sourceIndex2] = new Array(imageCount);
      for (var imageIndex2 = 0; imageIndex2 < imageCount; ++imageIndex2) {
        var image2 = images[imageIndex2];
        var nodataValue = image2.getGDALNoData();
        nodataValues[sourceIndex2][imageIndex2] = nodataValue === null ? NaN : nodataValue;
        var wantedSamples = this_1.sourceInfo_[sourceIndex2].bands;
        samplesPerPixel[sourceIndex2] = wantedSamples ? wantedSamples.length : image2.getSamplesPerPixel();
        var level = imageCount - (imageIndex2 + 1);
        if (!sourceExtent) {
          sourceExtent = getBoundingBox(image2);
        }
        if (!sourceOrigin) {
          sourceOrigin = getOrigin(image2);
        }
        sourceResolutions[level] = getResolution(image2, images[0]);
        sourceTileSizes[level] = [image2.getTileWidth(), image2.getTileHeight()];
      }
      if (!extent) {
        extent = sourceExtent;
      } else {
        getIntersection(extent, sourceExtent, extent);
      }
      if (!origin) {
        origin = sourceOrigin;
      } else {
        var message = "Origin mismatch for source " + sourceIndex2 + ", got [" + sourceOrigin + "] but expected [" + origin + "]";
        assertEqual(origin, sourceOrigin, 0, message, this_1.viewRejector);
      }
      if (!resolutions) {
        resolutions = sourceResolutions;
        this_1.resolutionFactors_[sourceIndex2] = 1;
      } else {
        if (resolutions.length - minZoom > sourceResolutions.length) {
          minZoom = resolutions.length - sourceResolutions.length;
        }
        var resolutionFactor_1 = resolutions[resolutions.length - 1] / sourceResolutions[sourceResolutions.length - 1];
        this_1.resolutionFactors_[sourceIndex2] = resolutionFactor_1;
        var scaledSourceResolutions = sourceResolutions.map(function(resolution) {
          return resolution *= resolutionFactor_1;
        });
        var message = "Resolution mismatch for source " + sourceIndex2 + ", got [" + scaledSourceResolutions + "] but expected [" + resolutions + "]";
        assertEqual(resolutions.slice(minZoom, resolutions.length), scaledSourceResolutions, 5e-3, message, this_1.viewRejector);
      }
      if (!tileSizes) {
        tileSizes = sourceTileSizes;
      } else {
        assertEqual(tileSizes.slice(minZoom, tileSizes.length), sourceTileSizes, 0, "Tile size mismatch for source " + sourceIndex2, this_1.viewRejector);
      }
      this_1.sourceImagery_[sourceIndex2] = images.reverse();
    };
    var this_1 = this;
    for (var sourceIndex = 0; sourceIndex < sourceCount; ++sourceIndex) {
      _loop_1(sourceIndex);
    }
    for (var i = 0, ii = this.sourceImagery_.length; i < ii; ++i) {
      var sourceImagery = this.sourceImagery_[i];
      while (sourceImagery.length < resolutions.length) {
        sourceImagery.unshift(void 0);
      }
    }
    if (!this.getProjection()) {
      var firstSource = sources[0];
      for (var i = firstSource.length - 1; i >= 0; --i) {
        var image = firstSource[i];
        var projection = getProjection(image);
        if (projection) {
          this.projection = projection;
          break;
        }
      }
    }
    this.samplesPerPixel_ = samplesPerPixel;
    this.nodataValues_ = nodataValues;
    outer:
      for (var sourceIndex = 0; sourceIndex < sourceCount; ++sourceIndex) {
        if (this.sourceInfo_[sourceIndex].nodata !== void 0) {
          this.addAlpha_ = true;
          break;
        }
        var values = nodataValues[sourceIndex];
        var bands = this.sourceInfo_[sourceIndex].bands;
        if (bands) {
          for (var i = 0; i < bands.length; ++i) {
            if (!isNaN(values[bands[i] - 1])) {
              this.addAlpha_ = true;
              break outer;
            }
          }
          continue;
        }
        for (var imageIndex = 0; imageIndex < values.length; ++imageIndex) {
          if (!isNaN(values[imageIndex])) {
            this.addAlpha_ = true;
            break outer;
          }
        }
      }
    var additionalBands = this.addAlpha_ ? 1 : 0;
    this.bandCount = samplesPerPixel.reduce(function(accumulator, value) {
      accumulator += value;
      return accumulator;
    }, 0) + additionalBands;
    var tileGrid = new TileGrid_default({
      extent,
      minZoom,
      origin,
      resolutions,
      tileSizes
    });
    this.tileGrid = tileGrid;
    this.setLoader(this.loadTile_.bind(this));
    this.setState(State_default.READY);
    this.viewResolver({
      projection: this.projection,
      resolutions,
      center: toUserCoordinate(getCenter(extent), this.projection),
      extent: toUserExtent(extent, this.projection),
      zoom: 0
    });
  };
  GeoTIFFSource2.prototype.loadTile_ = function(z, x, y) {
    var size = toSize(this.tileGrid.getTileSize(z));
    var sourceCount = this.sourceImagery_.length;
    var requests = new Array(sourceCount);
    var addAlpha = this.addAlpha_;
    var bandCount = this.bandCount;
    var samplesPerPixel = this.samplesPerPixel_;
    var nodataValues = this.nodataValues_;
    var sourceInfo = this.sourceInfo_;
    var _loop_2 = function(sourceIndex2) {
      var source2 = sourceInfo[sourceIndex2];
      var resolutionFactor = this_2.resolutionFactors_[sourceIndex2];
      var pixelBounds = [
        Math.round(x * (size[0] * resolutionFactor)),
        Math.round(y * (size[1] * resolutionFactor)),
        Math.round((x + 1) * (size[0] * resolutionFactor)),
        Math.round((y + 1) * (size[1] * resolutionFactor))
      ];
      var image = this_2.sourceImagery_[sourceIndex2][z];
      var samples = void 0;
      if (source2.bands) {
        samples = source2.bands.map(function(bandNumber) {
          return bandNumber - 1;
        });
      }
      var fillValue = void 0;
      if (!isNaN(source2.nodata)) {
        fillValue = source2.nodata;
      } else {
        if (!samples) {
          fillValue = nodataValues[sourceIndex2];
        } else {
          fillValue = samples.map(function(sampleIndex) {
            return nodataValues[sourceIndex2][sampleIndex];
          });
        }
      }
      requests[sourceIndex2] = image[this_2.readMethod_]({
        window: pixelBounds,
        width: size[0],
        height: size[1],
        samples,
        fillValue,
        pool: getWorkerPool(),
        interleave: false
      });
    };
    var this_2 = this;
    for (var sourceIndex = 0; sourceIndex < sourceCount; ++sourceIndex) {
      _loop_2(sourceIndex);
    }
    var pixelCount = size[0] * size[1];
    var dataLength = pixelCount * bandCount;
    var normalize = this.normalize_;
    return Promise.all(requests).then(function(sourceSamples) {
      var data;
      if (normalize) {
        data = new Uint8Array(dataLength);
      } else {
        data = new Float32Array(dataLength);
      }
      var dataIndex = 0;
      for (var pixelIndex = 0; pixelIndex < pixelCount; ++pixelIndex) {
        var transparent = addAlpha;
        for (var sourceIndex2 = 0; sourceIndex2 < sourceCount; ++sourceIndex2) {
          var source2 = sourceInfo[sourceIndex2];
          var min = source2.min;
          var max = source2.max;
          var gain = void 0, bias = void 0;
          if (normalize) {
            if (min === void 0) {
              min = getMinForDataType(sourceSamples[sourceIndex2][0]);
            }
            if (max === void 0) {
              max = getMaxForDataType(sourceSamples[sourceIndex2][0]);
            }
            gain = 255 / (max - min);
            bias = -min * gain;
          }
          for (var sampleIndex = 0; sampleIndex < samplesPerPixel[sourceIndex2]; ++sampleIndex) {
            var sourceValue = sourceSamples[sourceIndex2][sampleIndex][pixelIndex];
            var value = void 0;
            if (normalize) {
              value = clamp(gain * sourceValue + bias, 0, 255);
            } else {
              value = sourceValue;
            }
            if (!addAlpha) {
              data[dataIndex] = value;
            } else {
              var nodata = source2.nodata;
              if (nodata === void 0) {
                var bandIndex = void 0;
                if (source2.bands) {
                  bandIndex = source2.bands[sampleIndex] - 1;
                } else {
                  bandIndex = sampleIndex;
                }
                nodata = nodataValues[sourceIndex2][bandIndex];
              }
              if (sourceValue !== nodata) {
                transparent = false;
                data[dataIndex] = value;
              }
            }
            dataIndex++;
          }
        }
        if (addAlpha) {
          if (!transparent) {
            data[dataIndex] = 255;
          }
          dataIndex++;
        }
      }
      return data;
    });
  };
  return GeoTIFFSource2;
}(DataTile_default2);
GeoTIFFSource.prototype.getView;
var GeoTIFF_default = GeoTIFFSource;

// node_modules/ol/source/Zoomify.js
var __extends7 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var TierSizeCalculation = {
  DEFAULT: "default",
  TRUNCATED: "truncated"
};
var CustomTile = function(_super) {
  __extends7(CustomTile3, _super);
  function CustomTile3(tileSize, tileCoord, state, src, crossOrigin, tileLoadFunction, opt_options) {
    var _this = _super.call(this, tileCoord, state, src, crossOrigin, tileLoadFunction, opt_options) || this;
    _this.zoomifyImage_ = null;
    _this.tileSize_ = tileSize;
    return _this;
  }
  CustomTile3.prototype.getImage = function() {
    if (this.zoomifyImage_) {
      return this.zoomifyImage_;
    }
    var image = _super.prototype.getImage.call(this);
    if (this.state == TileState_default.LOADED) {
      var tileSize = this.tileSize_;
      if (image.width == tileSize[0] && image.height == tileSize[1]) {
        this.zoomifyImage_ = image;
        return image;
      } else {
        var context2 = createCanvasContext2D(tileSize[0], tileSize[1]);
        context2.drawImage(image, 0, 0);
        this.zoomifyImage_ = context2.canvas;
        return context2.canvas;
      }
    } else {
      return image;
    }
  };
  return CustomTile3;
}(ImageTile_default);
var Zoomify = function(_super) {
  __extends7(Zoomify2, _super);
  function Zoomify2(opt_options) {
    var _this = this;
    var options = opt_options;
    var size = options.size;
    var tierSizeCalculation = options.tierSizeCalculation !== void 0 ? options.tierSizeCalculation : TierSizeCalculation.DEFAULT;
    var tilePixelRatio = options.tilePixelRatio || 1;
    var imageWidth = size[0];
    var imageHeight = size[1];
    var tierSizeInTiles = [];
    var tileSize = options.tileSize || DEFAULT_TILE_SIZE;
    var tileSizeForTierSizeCalculation = tileSize * tilePixelRatio;
    switch (tierSizeCalculation) {
      case TierSizeCalculation.DEFAULT:
        while (imageWidth > tileSizeForTierSizeCalculation || imageHeight > tileSizeForTierSizeCalculation) {
          tierSizeInTiles.push([
            Math.ceil(imageWidth / tileSizeForTierSizeCalculation),
            Math.ceil(imageHeight / tileSizeForTierSizeCalculation)
          ]);
          tileSizeForTierSizeCalculation += tileSizeForTierSizeCalculation;
        }
        break;
      case TierSizeCalculation.TRUNCATED:
        var width = imageWidth;
        var height = imageHeight;
        while (width > tileSizeForTierSizeCalculation || height > tileSizeForTierSizeCalculation) {
          tierSizeInTiles.push([
            Math.ceil(width / tileSizeForTierSizeCalculation),
            Math.ceil(height / tileSizeForTierSizeCalculation)
          ]);
          width >>= 1;
          height >>= 1;
        }
        break;
      default:
        assert(false, 53);
        break;
    }
    tierSizeInTiles.push([1, 1]);
    tierSizeInTiles.reverse();
    var resolutions = [tilePixelRatio];
    var tileCountUpToTier = [0];
    for (var i = 1, ii = tierSizeInTiles.length; i < ii; i++) {
      resolutions.push(tilePixelRatio << i);
      tileCountUpToTier.push(tierSizeInTiles[i - 1][0] * tierSizeInTiles[i - 1][1] + tileCountUpToTier[i - 1]);
    }
    resolutions.reverse();
    var tileGrid = new TileGrid_default({
      tileSize,
      extent: options.extent || [0, -imageHeight, imageWidth, 0],
      resolutions
    });
    var url2 = options.url;
    if (url2 && url2.indexOf("{TileGroup}") == -1 && url2.indexOf("{tileIndex}") == -1) {
      url2 += "{TileGroup}/{z}-{x}-{y}.jpg";
    }
    var urls = expandUrl(url2);
    var tileWidth = tileSize * tilePixelRatio;
    function createFromTemplate(template) {
      return function(tileCoord, pixelRatio, projection) {
        if (!tileCoord) {
          return void 0;
        } else {
          var tileCoordZ = tileCoord[0];
          var tileCoordX = tileCoord[1];
          var tileCoordY = tileCoord[2];
          var tileIndex = tileCoordX + tileCoordY * tierSizeInTiles[tileCoordZ][0];
          var tileGroup = (tileIndex + tileCountUpToTier[tileCoordZ]) / tileWidth | 0;
          var localContext_1 = {
            "z": tileCoordZ,
            "x": tileCoordX,
            "y": tileCoordY,
            "tileIndex": tileIndex,
            "TileGroup": "TileGroup" + tileGroup
          };
          return template.replace(/\{(\w+?)\}/g, function(m, p) {
            return localContext_1[p];
          });
        }
      };
    }
    var tileUrlFunction = createFromTileUrlFunctions(urls.map(createFromTemplate));
    var ZoomifyTileClass = CustomTile.bind(null, toSize(tileSize * tilePixelRatio));
    _this = _super.call(this, {
      attributions: options.attributions,
      cacheSize: options.cacheSize,
      crossOrigin: options.crossOrigin,
      imageSmoothing: options.imageSmoothing,
      projection: options.projection,
      tilePixelRatio,
      reprojectionErrorThreshold: options.reprojectionErrorThreshold,
      tileClass: ZoomifyTileClass,
      tileGrid,
      tileUrlFunction,
      transition: options.transition
    }) || this;
    _this.zDirection = options.zDirection;
    var tileUrl = tileGrid.getTileCoordForCoordAndResolution(getCenter(tileGrid.getExtent()), resolutions[resolutions.length - 1]);
    var testTileUrl = tileUrlFunction(tileUrl, 1, null);
    var image = new Image();
    image.addEventListener("error", function() {
      tileWidth = tileSize;
      this.changed();
    }.bind(_this));
    image.src = testTileUrl;
    return _this;
  }
  return Zoomify2;
}(TileImage_default);
var Zoomify_default = Zoomify;

// node_modules/ol/format/IIIFInfo.js
var __spreadArray = function(to, from) {
  for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
    to[j] = from[i];
  return to;
};
var Versions = {
  VERSION1: "version1",
  VERSION2: "version2",
  VERSION3: "version3"
};
var IIIF_PROFILE_VALUES = {};
IIIF_PROFILE_VALUES[Versions.VERSION1] = {
  "level0": {
    supports: [],
    formats: [],
    qualities: ["native"]
  },
  "level1": {
    supports: ["regionByPx", "sizeByW", "sizeByH", "sizeByPct"],
    formats: ["jpg"],
    qualities: ["native"]
  },
  "level2": {
    supports: [
      "regionByPx",
      "regionByPct",
      "sizeByW",
      "sizeByH",
      "sizeByPct",
      "sizeByConfinedWh",
      "sizeByWh"
    ],
    formats: ["jpg", "png"],
    qualities: ["native", "color", "grey", "bitonal"]
  }
};
IIIF_PROFILE_VALUES[Versions.VERSION2] = {
  "level0": {
    supports: [],
    formats: ["jpg"],
    qualities: ["default"]
  },
  "level1": {
    supports: ["regionByPx", "sizeByW", "sizeByH", "sizeByPct"],
    formats: ["jpg"],
    qualities: ["default"]
  },
  "level2": {
    supports: [
      "regionByPx",
      "regionByPct",
      "sizeByW",
      "sizeByH",
      "sizeByPct",
      "sizeByConfinedWh",
      "sizeByDistortedWh",
      "sizeByWh"
    ],
    formats: ["jpg", "png"],
    qualities: ["default", "bitonal"]
  }
};
IIIF_PROFILE_VALUES[Versions.VERSION3] = {
  "level0": {
    supports: [],
    formats: ["jpg"],
    qualities: ["default"]
  },
  "level1": {
    supports: ["regionByPx", "regionSquare", "sizeByW", "sizeByH", "sizeByWh"],
    formats: ["jpg"],
    qualities: ["default"]
  },
  "level2": {
    supports: [
      "regionByPx",
      "regionSquare",
      "regionByPct",
      "sizeByW",
      "sizeByH",
      "sizeByPct",
      "sizeByConfinedWh",
      "sizeByWh"
    ],
    formats: ["jpg", "png"],
    qualities: ["default"]
  }
};
IIIF_PROFILE_VALUES["none"] = {
  "none": {
    supports: [],
    formats: [],
    qualities: []
  }
};
var COMPLIANCE_VERSION1 = /^https?:\/\/library\.stanford\.edu\/iiif\/image-api\/(?:1\.1\/)?compliance\.html#level[0-2]$/;
var COMPLIANCE_VERSION2 = /^https?:\/\/iiif\.io\/api\/image\/2\/level[0-2](?:\.json)?$/;
var COMPLIANCE_VERSION3 = /(^https?:\/\/iiif\.io\/api\/image\/3\/level[0-2](?:\.json)?$)|(^level[0-2]$)/;
function generateVersion1Options(iiifInfo) {
  var levelProfile = iiifInfo.getComplianceLevelSupportedFeatures();
  if (levelProfile === void 0) {
    levelProfile = IIIF_PROFILE_VALUES[Versions.VERSION1]["level0"];
  }
  return {
    url: iiifInfo.imageInfo["@id"] === void 0 ? void 0 : iiifInfo.imageInfo["@id"].replace(/\/?(?:info\.json)?$/g, ""),
    supports: levelProfile.supports,
    formats: __spreadArray(__spreadArray([], levelProfile.formats), [
      iiifInfo.imageInfo.formats === void 0 ? [] : iiifInfo.imageInfo.formats
    ]),
    qualities: __spreadArray(__spreadArray([], levelProfile.qualities), [
      iiifInfo.imageInfo.qualities === void 0 ? [] : iiifInfo.imageInfo.qualities
    ]),
    resolutions: iiifInfo.imageInfo.scale_factors,
    tileSize: iiifInfo.imageInfo.tile_width !== void 0 ? iiifInfo.imageInfo.tile_height !== void 0 ? [iiifInfo.imageInfo.tile_width, iiifInfo.imageInfo.tile_height] : [iiifInfo.imageInfo.tile_width, iiifInfo.imageInfo.tile_width] : iiifInfo.imageInfo.tile_height != void 0 ? [iiifInfo.imageInfo.tile_height, iiifInfo.imageInfo.tile_height] : void 0
  };
}
function generateVersion2Options(iiifInfo) {
  var levelProfile = iiifInfo.getComplianceLevelSupportedFeatures(), additionalProfile = Array.isArray(iiifInfo.imageInfo.profile) && iiifInfo.imageInfo.profile.length > 1, profileSupports = additionalProfile && iiifInfo.imageInfo.profile[1].supports ? iiifInfo.imageInfo.profile[1].supports : [], profileFormats = additionalProfile && iiifInfo.imageInfo.profile[1].formats ? iiifInfo.imageInfo.profile[1].formats : [], profileQualities = additionalProfile && iiifInfo.imageInfo.profile[1].qualities ? iiifInfo.imageInfo.profile[1].qualities : [];
  return {
    url: iiifInfo.imageInfo["@id"].replace(/\/?(?:info\.json)?$/g, ""),
    sizes: iiifInfo.imageInfo.sizes === void 0 ? void 0 : iiifInfo.imageInfo.sizes.map(function(size) {
      return [size.width, size.height];
    }),
    tileSize: iiifInfo.imageInfo.tiles === void 0 ? void 0 : [
      iiifInfo.imageInfo.tiles.map(function(tile) {
        return tile.width;
      })[0],
      iiifInfo.imageInfo.tiles.map(function(tile) {
        return tile.height === void 0 ? tile.width : tile.height;
      })[0]
    ],
    resolutions: iiifInfo.imageInfo.tiles === void 0 ? void 0 : iiifInfo.imageInfo.tiles.map(function(tile) {
      return tile.scaleFactors;
    })[0],
    supports: __spreadArray(__spreadArray([], levelProfile.supports), profileSupports),
    formats: __spreadArray(__spreadArray([], levelProfile.formats), profileFormats),
    qualities: __spreadArray(__spreadArray([], levelProfile.qualities), profileQualities)
  };
}
function generateVersion3Options(iiifInfo) {
  var levelProfile = iiifInfo.getComplianceLevelSupportedFeatures(), formats = iiifInfo.imageInfo.extraFormats === void 0 ? levelProfile.formats : __spreadArray(__spreadArray([], levelProfile.formats), iiifInfo.imageInfo.extraFormats), preferredFormat = iiifInfo.imageInfo.preferredFormats !== void 0 && Array.isArray(iiifInfo.imageInfo.preferredFormats) && iiifInfo.imageInfo.preferredFormats.length > 0 ? iiifInfo.imageInfo.preferredFormats.filter(function(format) {
    return includes(["jpg", "png", "gif"], format);
  }).reduce(function(acc, format) {
    return acc === void 0 && includes(formats, format) ? format : acc;
  }, void 0) : void 0;
  return {
    url: iiifInfo.imageInfo["id"],
    sizes: iiifInfo.imageInfo.sizes === void 0 ? void 0 : iiifInfo.imageInfo.sizes.map(function(size) {
      return [size.width, size.height];
    }),
    tileSize: iiifInfo.imageInfo.tiles === void 0 ? void 0 : [
      iiifInfo.imageInfo.tiles.map(function(tile) {
        return tile.width;
      })[0],
      iiifInfo.imageInfo.tiles.map(function(tile) {
        return tile.height;
      })[0]
    ],
    resolutions: iiifInfo.imageInfo.tiles === void 0 ? void 0 : iiifInfo.imageInfo.tiles.map(function(tile) {
      return tile.scaleFactors;
    })[0],
    supports: iiifInfo.imageInfo.extraFeatures === void 0 ? levelProfile.supports : __spreadArray(__spreadArray([], levelProfile.supports), iiifInfo.imageInfo.extraFeatures),
    formats,
    qualities: iiifInfo.imageInfo.extraQualities === void 0 ? levelProfile.qualities : __spreadArray(__spreadArray([], levelProfile.qualities), iiifInfo.imageInfo.extraQualities),
    preferredFormat
  };
}
var versionFunctions = {};
versionFunctions[Versions.VERSION1] = generateVersion1Options;
versionFunctions[Versions.VERSION2] = generateVersion2Options;
versionFunctions[Versions.VERSION3] = generateVersion3Options;
var IIIFInfo = function() {
  function IIIFInfo2(imageInfo) {
    this.setImageInfo(imageInfo);
  }
  IIIFInfo2.prototype.setImageInfo = function(imageInfo) {
    if (typeof imageInfo == "string") {
      this.imageInfo = JSON.parse(imageInfo);
    } else {
      this.imageInfo = imageInfo;
    }
  };
  IIIFInfo2.prototype.getImageApiVersion = function() {
    if (this.imageInfo === void 0) {
      return;
    }
    var context2 = this.imageInfo["@context"] || "ol-no-context";
    if (typeof context2 == "string") {
      context2 = [context2];
    }
    for (var i = 0; i < context2.length; i++) {
      switch (context2[i]) {
        case "http://library.stanford.edu/iiif/image-api/1.1/context.json":
        case "http://iiif.io/api/image/1/context.json":
          return Versions.VERSION1;
        case "http://iiif.io/api/image/2/context.json":
          return Versions.VERSION2;
        case "http://iiif.io/api/image/3/context.json":
          return Versions.VERSION3;
        case "ol-no-context":
          if (this.getComplianceLevelEntryFromProfile(Versions.VERSION1) && this.imageInfo.identifier) {
            return Versions.VERSION1;
          }
          break;
        default:
      }
    }
    assert(false, 61);
  };
  IIIFInfo2.prototype.getComplianceLevelEntryFromProfile = function(version) {
    if (this.imageInfo === void 0 || this.imageInfo.profile === void 0) {
      return;
    }
    if (version === void 0) {
      version = this.getImageApiVersion();
    }
    switch (version) {
      case Versions.VERSION1:
        if (COMPLIANCE_VERSION1.test(this.imageInfo.profile)) {
          return this.imageInfo.profile;
        }
        break;
      case Versions.VERSION3:
        if (COMPLIANCE_VERSION3.test(this.imageInfo.profile)) {
          return this.imageInfo.profile;
        }
        break;
      case Versions.VERSION2:
        if (typeof this.imageInfo.profile === "string" && COMPLIANCE_VERSION2.test(this.imageInfo.profile)) {
          return this.imageInfo.profile;
        }
        if (Array.isArray(this.imageInfo.profile) && this.imageInfo.profile.length > 0 && typeof this.imageInfo.profile[0] === "string" && COMPLIANCE_VERSION2.test(this.imageInfo.profile[0])) {
          return this.imageInfo.profile[0];
        }
        break;
      default:
    }
  };
  IIIFInfo2.prototype.getComplianceLevelFromProfile = function(version) {
    var complianceLevel = this.getComplianceLevelEntryFromProfile(version);
    if (complianceLevel === void 0) {
      return void 0;
    }
    var level = complianceLevel.match(/level[0-2](?:\.json)?$/g);
    return Array.isArray(level) ? level[0].replace(".json", "") : void 0;
  };
  IIIFInfo2.prototype.getComplianceLevelSupportedFeatures = function() {
    if (this.imageInfo === void 0) {
      return;
    }
    var version = this.getImageApiVersion();
    var level = this.getComplianceLevelFromProfile(version);
    if (level === void 0) {
      return IIIF_PROFILE_VALUES["none"]["none"];
    }
    return IIIF_PROFILE_VALUES[version][level];
  };
  IIIFInfo2.prototype.getTileSourceOptions = function(opt_preferredOptions) {
    var options = opt_preferredOptions || {}, version = this.getImageApiVersion();
    if (version === void 0) {
      return;
    }
    var imageOptions = version === void 0 ? void 0 : versionFunctions[version](this);
    if (imageOptions === void 0) {
      return;
    }
    return {
      url: imageOptions.url,
      version,
      size: [this.imageInfo.width, this.imageInfo.height],
      sizes: imageOptions.sizes,
      format: options.format !== void 0 && includes(imageOptions.formats, options.format) ? options.format : imageOptions.preferredFormat !== void 0 ? imageOptions.preferredFormat : "jpg",
      supports: imageOptions.supports,
      quality: options.quality && includes(imageOptions.qualities, options.quality) ? options.quality : includes(imageOptions.qualities, "native") ? "native" : "default",
      resolutions: Array.isArray(imageOptions.resolutions) ? imageOptions.resolutions.sort(function(a, b) {
        return b - a;
      }) : void 0,
      tileSize: imageOptions.tileSize
    };
  };
  return IIIFInfo2;
}();

// node_modules/ol/source/IIIF.js
var __extends8 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
function formatPercentage(percentage) {
  return percentage.toLocaleString("en", { maximumFractionDigits: 10 });
}
var IIIF = function(_super) {
  __extends8(IIIF2, _super);
  function IIIF2(opt_options) {
    var _this = this;
    var options = opt_options || {};
    var baseUrl = options.url || "";
    baseUrl = baseUrl + (baseUrl.lastIndexOf("/") === baseUrl.length - 1 || baseUrl === "" ? "" : "/");
    var version = options.version || Versions.VERSION2;
    var sizes = options.sizes || [];
    var size = options.size;
    assert(size != void 0 && Array.isArray(size) && size.length == 2 && !isNaN(size[0]) && size[0] > 0 && !isNaN(size[1]) && size[1] > 0, 60);
    var width = size[0];
    var height = size[1];
    var tileSize = options.tileSize;
    var tilePixelRatio = options.tilePixelRatio || 1;
    var format = options.format || "jpg";
    var quality = options.quality || (options.version == Versions.VERSION1 ? "native" : "default");
    var resolutions = options.resolutions || [];
    var supports = options.supports || [];
    var extent = options.extent || [0, -height, width, 0];
    var supportsListedSizes = sizes != void 0 && Array.isArray(sizes) && sizes.length > 0;
    var supportsListedTiles = tileSize !== void 0 && (typeof tileSize === "number" && Number.isInteger(tileSize) && tileSize > 0 || Array.isArray(tileSize) && tileSize.length > 0);
    var supportsArbitraryTiling = supports != void 0 && Array.isArray(supports) && (includes(supports, "regionByPx") || includes(supports, "regionByPct")) && (includes(supports, "sizeByWh") || includes(supports, "sizeByH") || includes(supports, "sizeByW") || includes(supports, "sizeByPct"));
    var tileWidth, tileHeight, maxZoom;
    resolutions.sort(function(a, b) {
      return b - a;
    });
    if (supportsListedTiles || supportsArbitraryTiling) {
      if (tileSize != void 0) {
        if (typeof tileSize === "number" && Number.isInteger(tileSize) && tileSize > 0) {
          tileWidth = tileSize;
          tileHeight = tileSize;
        } else if (Array.isArray(tileSize) && tileSize.length > 0) {
          if (tileSize.length == 1 || tileSize[1] == void 0 && Number.isInteger(tileSize[0])) {
            tileWidth = tileSize[0];
            tileHeight = tileSize[0];
          }
          if (tileSize.length == 2) {
            if (Number.isInteger(tileSize[0]) && Number.isInteger(tileSize[1])) {
              tileWidth = tileSize[0];
              tileHeight = tileSize[1];
            } else if (tileSize[0] == void 0 && Number.isInteger(tileSize[1])) {
              tileWidth = tileSize[1];
              tileHeight = tileSize[1];
            }
          }
        }
      }
      if (tileWidth === void 0 || tileHeight === void 0) {
        tileWidth = DEFAULT_TILE_SIZE;
        tileHeight = DEFAULT_TILE_SIZE;
      }
      if (resolutions.length == 0) {
        maxZoom = Math.max(Math.ceil(Math.log(width / tileWidth) / Math.LN2), Math.ceil(Math.log(height / tileHeight) / Math.LN2));
        for (var i = maxZoom; i >= 0; i--) {
          resolutions.push(Math.pow(2, i));
        }
      } else {
        var maxScaleFactor = Math.max.apply(Math, resolutions);
        maxZoom = Math.round(Math.log(maxScaleFactor) / Math.LN2);
      }
    } else {
      tileWidth = width;
      tileHeight = height;
      resolutions = [];
      if (supportsListedSizes) {
        sizes.sort(function(a, b) {
          return a[0] - b[0];
        });
        maxZoom = -1;
        var ignoredSizesIndex = [];
        for (var i = 0; i < sizes.length; i++) {
          var resolution = width / sizes[i][0];
          if (resolutions.length > 0 && resolutions[resolutions.length - 1] == resolution) {
            ignoredSizesIndex.push(i);
            continue;
          }
          resolutions.push(resolution);
          maxZoom++;
        }
        if (ignoredSizesIndex.length > 0) {
          for (var i = 0; i < ignoredSizesIndex.length; i++) {
            sizes.splice(ignoredSizesIndex[i] - i, 1);
          }
        }
      } else {
        resolutions.push(1);
        sizes.push([width, height]);
        maxZoom = 0;
      }
    }
    var tileGrid = new TileGrid_default({
      tileSize: [tileWidth, tileHeight],
      extent,
      origin: getTopLeft(extent),
      resolutions
    });
    var tileUrlFunction = function(tileCoord, pixelRatio, projection) {
      var regionParam, sizeParam;
      var zoom = tileCoord[0];
      if (zoom > maxZoom) {
        return;
      }
      var tileX = tileCoord[1], tileY = tileCoord[2], scale3 = resolutions[zoom];
      if (tileX === void 0 || tileY === void 0 || scale3 === void 0 || tileX < 0 || Math.ceil(width / scale3 / tileWidth) <= tileX || tileY < 0 || Math.ceil(height / scale3 / tileHeight) <= tileY) {
        return;
      }
      if (supportsArbitraryTiling || supportsListedTiles) {
        var regionX = tileX * tileWidth * scale3, regionY = tileY * tileHeight * scale3;
        var regionW = tileWidth * scale3, regionH = tileHeight * scale3, sizeW = tileWidth, sizeH = tileHeight;
        if (regionX + regionW > width) {
          regionW = width - regionX;
        }
        if (regionY + regionH > height) {
          regionH = height - regionY;
        }
        if (regionX + tileWidth * scale3 > width) {
          sizeW = Math.floor((width - regionX + scale3 - 1) / scale3);
        }
        if (regionY + tileHeight * scale3 > height) {
          sizeH = Math.floor((height - regionY + scale3 - 1) / scale3);
        }
        if (regionX == 0 && regionW == width && regionY == 0 && regionH == height) {
          regionParam = "full";
        } else if (!supportsArbitraryTiling || includes(supports, "regionByPx")) {
          regionParam = regionX + "," + regionY + "," + regionW + "," + regionH;
        } else if (includes(supports, "regionByPct")) {
          var pctX = formatPercentage(regionX / width * 100), pctY = formatPercentage(regionY / height * 100), pctW = formatPercentage(regionW / width * 100), pctH = formatPercentage(regionH / height * 100);
          regionParam = "pct:" + pctX + "," + pctY + "," + pctW + "," + pctH;
        }
        if (version == Versions.VERSION3 && (!supportsArbitraryTiling || includes(supports, "sizeByWh"))) {
          sizeParam = sizeW + "," + sizeH;
        } else if (!supportsArbitraryTiling || includes(supports, "sizeByW")) {
          sizeParam = sizeW + ",";
        } else if (includes(supports, "sizeByH")) {
          sizeParam = "," + sizeH;
        } else if (includes(supports, "sizeByWh")) {
          sizeParam = sizeW + "," + sizeH;
        } else if (includes(supports, "sizeByPct")) {
          sizeParam = "pct:" + formatPercentage(100 / scale3);
        }
      } else {
        regionParam = "full";
        if (supportsListedSizes) {
          var regionWidth = sizes[zoom][0], regionHeight = sizes[zoom][1];
          if (version == Versions.VERSION3) {
            if (regionWidth == width && regionHeight == height) {
              sizeParam = "max";
            } else {
              sizeParam = regionWidth + "," + regionHeight;
            }
          } else {
            if (regionWidth == width) {
              sizeParam = "full";
            } else {
              sizeParam = regionWidth + ",";
            }
          }
        } else {
          sizeParam = version == Versions.VERSION3 ? "max" : "full";
        }
      }
      return baseUrl + regionParam + "/" + sizeParam + "/0/" + quality + "." + format;
    };
    var IiifTileClass = CustomTile.bind(null, toSize(tileSize || 256).map(function(size2) {
      return size2 * tilePixelRatio;
    }));
    _this = _super.call(this, {
      attributions: options.attributions,
      attributionsCollapsible: options.attributionsCollapsible,
      cacheSize: options.cacheSize,
      crossOrigin: options.crossOrigin,
      imageSmoothing: options.imageSmoothing,
      projection: options.projection,
      reprojectionErrorThreshold: options.reprojectionErrorThreshold,
      state: options.state,
      tileClass: IiifTileClass,
      tileGrid,
      tilePixelRatio: options.tilePixelRatio,
      tileUrlFunction,
      transition: options.transition
    }) || this;
    _this.zDirection = options.zDirection;
    return _this;
  }
  return IIIF2;
}(TileImage_default);
var IIIF_default = IIIF;

// node_modules/ol/reproj/Image.js
var __extends9 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var ReprojImage = function(_super) {
  __extends9(ReprojImage2, _super);
  function ReprojImage2(sourceProj, targetProj, targetExtent, targetResolution, pixelRatio, getImageFunction, opt_contextOptions) {
    var _this = this;
    var maxSourceExtent = sourceProj.getExtent();
    var maxTargetExtent = targetProj.getExtent();
    var limitedTargetExtent = maxTargetExtent ? getIntersection(targetExtent, maxTargetExtent) : targetExtent;
    var targetCenter = getCenter(limitedTargetExtent);
    var sourceResolution = calculateSourceResolution(sourceProj, targetProj, targetCenter, targetResolution);
    var errorThresholdInPixels = ERROR_THRESHOLD;
    var triangulation = new Triangulation_default(sourceProj, targetProj, limitedTargetExtent, maxSourceExtent, sourceResolution * errorThresholdInPixels, targetResolution);
    var sourceExtent = triangulation.calculateSourceExtent();
    var sourceImage = getImageFunction(sourceExtent, sourceResolution, pixelRatio);
    var state = sourceImage ? ImageState_default.IDLE : ImageState_default.EMPTY;
    var sourcePixelRatio = sourceImage ? sourceImage.getPixelRatio() : 1;
    _this = _super.call(this, targetExtent, targetResolution, sourcePixelRatio, state) || this;
    _this.targetProj_ = targetProj;
    _this.maxSourceExtent_ = maxSourceExtent;
    _this.triangulation_ = triangulation;
    _this.targetResolution_ = targetResolution;
    _this.targetExtent_ = targetExtent;
    _this.sourceImage_ = sourceImage;
    _this.sourcePixelRatio_ = sourcePixelRatio;
    _this.contextOptions_ = opt_contextOptions;
    _this.canvas_ = null;
    _this.sourceListenerKey_ = null;
    return _this;
  }
  ReprojImage2.prototype.disposeInternal = function() {
    if (this.state == ImageState_default.LOADING) {
      this.unlistenSource_();
    }
    _super.prototype.disposeInternal.call(this);
  };
  ReprojImage2.prototype.getImage = function() {
    return this.canvas_;
  };
  ReprojImage2.prototype.getProjection = function() {
    return this.targetProj_;
  };
  ReprojImage2.prototype.reproject_ = function() {
    var sourceState = this.sourceImage_.getState();
    if (sourceState == ImageState_default.LOADED) {
      var width = getWidth(this.targetExtent_) / this.targetResolution_;
      var height = getHeight(this.targetExtent_) / this.targetResolution_;
      this.canvas_ = render(width, height, this.sourcePixelRatio_, this.sourceImage_.getResolution(), this.maxSourceExtent_, this.targetResolution_, this.targetExtent_, this.triangulation_, [
        {
          extent: this.sourceImage_.getExtent(),
          image: this.sourceImage_.getImage()
        }
      ], 0, void 0, this.contextOptions_);
    }
    this.state = sourceState;
    this.changed();
  };
  ReprojImage2.prototype.load = function() {
    if (this.state == ImageState_default.IDLE) {
      this.state = ImageState_default.LOADING;
      this.changed();
      var sourceState = this.sourceImage_.getState();
      if (sourceState == ImageState_default.LOADED || sourceState == ImageState_default.ERROR) {
        this.reproject_();
      } else {
        this.sourceListenerKey_ = listen(this.sourceImage_, EventType_default.CHANGE, function(e) {
          var sourceState2 = this.sourceImage_.getState();
          if (sourceState2 == ImageState_default.LOADED || sourceState2 == ImageState_default.ERROR) {
            this.unlistenSource_();
            this.reproject_();
          }
        }, this);
        this.sourceImage_.load();
      }
    }
  };
  ReprojImage2.prototype.unlistenSource_ = function() {
    unlistenByKey(this.sourceListenerKey_);
    this.sourceListenerKey_ = null;
  };
  return ReprojImage2;
}(ImageBase_default);
var Image_default3 = ReprojImage;

// node_modules/ol/source/Image.js
var __extends10 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var ImageSourceEventType = {
  IMAGELOADSTART: "imageloadstart",
  IMAGELOADEND: "imageloadend",
  IMAGELOADERROR: "imageloaderror"
};
var ImageSourceEvent = function(_super) {
  __extends10(ImageSourceEvent2, _super);
  function ImageSourceEvent2(type, image) {
    var _this = _super.call(this, type) || this;
    _this.image = image;
    return _this;
  }
  return ImageSourceEvent2;
}(Event_default);
var ImageSource = function(_super) {
  __extends10(ImageSource2, _super);
  function ImageSource2(options) {
    var _this = _super.call(this, {
      attributions: options.attributions,
      projection: options.projection,
      state: options.state
    }) || this;
    _this.on;
    _this.once;
    _this.un;
    _this.resolutions_ = options.resolutions !== void 0 ? options.resolutions : null;
    _this.reprojectedImage_ = null;
    _this.reprojectedRevision_ = 0;
    _this.contextOptions_ = options.imageSmoothing === false ? IMAGE_SMOOTHING_DISABLED : void 0;
    return _this;
  }
  ImageSource2.prototype.getResolutions = function() {
    return this.resolutions_;
  };
  ImageSource2.prototype.getContextOptions = function() {
    return this.contextOptions_;
  };
  ImageSource2.prototype.findNearestResolution = function(resolution) {
    if (this.resolutions_) {
      var idx = linearFindNearest(this.resolutions_, resolution, 0);
      resolution = this.resolutions_[idx];
    }
    return resolution;
  };
  ImageSource2.prototype.getImage = function(extent, resolution, pixelRatio, projection) {
    var sourceProjection = this.getProjection();
    if (!ENABLE_RASTER_REPROJECTION || !sourceProjection || !projection || equivalent(sourceProjection, projection)) {
      if (sourceProjection) {
        projection = sourceProjection;
      }
      return this.getImageInternal(extent, resolution, pixelRatio, projection);
    } else {
      if (this.reprojectedImage_) {
        if (this.reprojectedRevision_ == this.getRevision() && equivalent(this.reprojectedImage_.getProjection(), projection) && this.reprojectedImage_.getResolution() == resolution && equals(this.reprojectedImage_.getExtent(), extent)) {
          return this.reprojectedImage_;
        }
        this.reprojectedImage_.dispose();
        this.reprojectedImage_ = null;
      }
      this.reprojectedImage_ = new Image_default3(sourceProjection, projection, extent, resolution, pixelRatio, function(extent2, resolution2, pixelRatio2) {
        return this.getImageInternal(extent2, resolution2, pixelRatio2, sourceProjection);
      }.bind(this), this.contextOptions_);
      this.reprojectedRevision_ = this.getRevision();
      return this.reprojectedImage_;
    }
  };
  ImageSource2.prototype.getImageInternal = function(extent, resolution, pixelRatio, projection) {
    return abstract();
  };
  ImageSource2.prototype.handleImageChange = function(event) {
    var image = event.target;
    switch (image.getState()) {
      case ImageState_default.LOADING:
        this.loading = true;
        this.dispatchEvent(new ImageSourceEvent(ImageSourceEventType.IMAGELOADSTART, image));
        break;
      case ImageState_default.LOADED:
        this.loading = false;
        this.dispatchEvent(new ImageSourceEvent(ImageSourceEventType.IMAGELOADEND, image));
        break;
      case ImageState_default.ERROR:
        this.loading = false;
        this.dispatchEvent(new ImageSourceEvent(ImageSourceEventType.IMAGELOADERROR, image));
        break;
      default:
    }
  };
  return ImageSource2;
}(Source_default);
function defaultImageLoadFunction(image, src) {
  image.getImage().src = src;
}
var Image_default4 = ImageSource;

// node_modules/ol/uri.js
function appendParams(uri, params) {
  var keyParams = [];
  Object.keys(params).forEach(function(k) {
    if (params[k] !== null && params[k] !== void 0) {
      keyParams.push(k + "=" + encodeURIComponent(params[k]));
    }
  });
  var qs = keyParams.join("&");
  uri = uri.replace(/[?&]$/, "");
  uri = uri.indexOf("?") === -1 ? uri + "?" : uri + "&";
  return uri + qs;
}

// node_modules/ol/source/ImageArcGISRest.js
var __extends11 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var ImageArcGISRest = function(_super) {
  __extends11(ImageArcGISRest2, _super);
  function ImageArcGISRest2(opt_options) {
    var _this = this;
    var options = opt_options ? opt_options : {};
    _this = _super.call(this, {
      attributions: options.attributions,
      imageSmoothing: options.imageSmoothing,
      projection: options.projection,
      resolutions: options.resolutions
    }) || this;
    _this.crossOrigin_ = options.crossOrigin !== void 0 ? options.crossOrigin : null;
    _this.hidpi_ = options.hidpi !== void 0 ? options.hidpi : true;
    _this.url_ = options.url;
    _this.imageLoadFunction_ = options.imageLoadFunction !== void 0 ? options.imageLoadFunction : defaultImageLoadFunction;
    _this.params_ = options.params || {};
    _this.image_ = null;
    _this.imageSize_ = [0, 0];
    _this.renderedRevision_ = 0;
    _this.ratio_ = options.ratio !== void 0 ? options.ratio : 1.5;
    return _this;
  }
  ImageArcGISRest2.prototype.getParams = function() {
    return this.params_;
  };
  ImageArcGISRest2.prototype.getImageInternal = function(extent, resolution, pixelRatio, projection) {
    if (this.url_ === void 0) {
      return null;
    }
    resolution = this.findNearestResolution(resolution);
    pixelRatio = this.hidpi_ ? pixelRatio : 1;
    var image = this.image_;
    if (image && this.renderedRevision_ == this.getRevision() && image.getResolution() == resolution && image.getPixelRatio() == pixelRatio && containsExtent(image.getExtent(), extent)) {
      return image;
    }
    var params = {
      "F": "image",
      "FORMAT": "PNG32",
      "TRANSPARENT": true
    };
    assign(params, this.params_);
    extent = extent.slice();
    var centerX = (extent[0] + extent[2]) / 2;
    var centerY = (extent[1] + extent[3]) / 2;
    if (this.ratio_ != 1) {
      var halfWidth = this.ratio_ * getWidth(extent) / 2;
      var halfHeight = this.ratio_ * getHeight(extent) / 2;
      extent[0] = centerX - halfWidth;
      extent[1] = centerY - halfHeight;
      extent[2] = centerX + halfWidth;
      extent[3] = centerY + halfHeight;
    }
    var imageResolution = resolution / pixelRatio;
    var width = Math.ceil(getWidth(extent) / imageResolution);
    var height = Math.ceil(getHeight(extent) / imageResolution);
    extent[0] = centerX - imageResolution * width / 2;
    extent[2] = centerX + imageResolution * width / 2;
    extent[1] = centerY - imageResolution * height / 2;
    extent[3] = centerY + imageResolution * height / 2;
    this.imageSize_[0] = width;
    this.imageSize_[1] = height;
    var url2 = this.getRequestUrl_(extent, this.imageSize_, pixelRatio, projection, params);
    this.image_ = new Image_default(extent, resolution, pixelRatio, url2, this.crossOrigin_, this.imageLoadFunction_);
    this.renderedRevision_ = this.getRevision();
    this.image_.addEventListener(EventType_default.CHANGE, this.handleImageChange.bind(this));
    return this.image_;
  };
  ImageArcGISRest2.prototype.getImageLoadFunction = function() {
    return this.imageLoadFunction_;
  };
  ImageArcGISRest2.prototype.getRequestUrl_ = function(extent, size, pixelRatio, projection, params) {
    var srid = projection.getCode().split(/:(?=\d+$)/).pop();
    params["SIZE"] = size[0] + "," + size[1];
    params["BBOX"] = extent.join(",");
    params["BBOXSR"] = srid;
    params["IMAGESR"] = srid;
    params["DPI"] = Math.round(90 * pixelRatio);
    var url2 = this.url_;
    var modifiedUrl = url2.replace(/MapServer\/?$/, "MapServer/export").replace(/ImageServer\/?$/, "ImageServer/exportImage");
    if (modifiedUrl == url2) {
      assert(false, 50);
    }
    return appendParams(modifiedUrl, params);
  };
  ImageArcGISRest2.prototype.getUrl = function() {
    return this.url_;
  };
  ImageArcGISRest2.prototype.setImageLoadFunction = function(imageLoadFunction) {
    this.image_ = null;
    this.imageLoadFunction_ = imageLoadFunction;
    this.changed();
  };
  ImageArcGISRest2.prototype.setUrl = function(url2) {
    if (url2 != this.url_) {
      this.url_ = url2;
      this.image_ = null;
      this.changed();
    }
  };
  ImageArcGISRest2.prototype.updateParams = function(params) {
    assign(this.params_, params);
    this.image_ = null;
    this.changed();
  };
  return ImageArcGISRest2;
}(Image_default4);
var ImageArcGISRest_default = ImageArcGISRest;

// node_modules/ol/source/ImageCanvas.js
var __extends12 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var ImageCanvasSource = function(_super) {
  __extends12(ImageCanvasSource2, _super);
  function ImageCanvasSource2(opt_options) {
    var _this = this;
    var options = opt_options ? opt_options : {};
    _this = _super.call(this, {
      attributions: options.attributions,
      imageSmoothing: options.imageSmoothing,
      projection: options.projection,
      resolutions: options.resolutions,
      state: options.state
    }) || this;
    _this.canvasFunction_ = options.canvasFunction;
    _this.canvas_ = null;
    _this.renderedRevision_ = 0;
    _this.ratio_ = options.ratio !== void 0 ? options.ratio : 1.5;
    return _this;
  }
  ImageCanvasSource2.prototype.getImageInternal = function(extent, resolution, pixelRatio, projection) {
    resolution = this.findNearestResolution(resolution);
    var canvas = this.canvas_;
    if (canvas && this.renderedRevision_ == this.getRevision() && canvas.getResolution() == resolution && canvas.getPixelRatio() == pixelRatio && containsExtent(canvas.getExtent(), extent)) {
      return canvas;
    }
    extent = extent.slice();
    scaleFromCenter(extent, this.ratio_);
    var width = getWidth(extent) / resolution;
    var height = getHeight(extent) / resolution;
    var size = [width * pixelRatio, height * pixelRatio];
    var canvasElement = this.canvasFunction_.call(this, extent, resolution, pixelRatio, size, projection);
    if (canvasElement) {
      canvas = new ImageCanvas_default(extent, resolution, pixelRatio, canvasElement);
    }
    this.canvas_ = canvas;
    this.renderedRevision_ = this.getRevision();
    return canvas;
  };
  return ImageCanvasSource2;
}(Image_default4);
var ImageCanvas_default2 = ImageCanvasSource;

// node_modules/ol/source/ImageMapGuide.js
var __extends13 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var ImageMapGuide = function(_super) {
  __extends13(ImageMapGuide2, _super);
  function ImageMapGuide2(options) {
    var _this = _super.call(this, {
      imageSmoothing: options.imageSmoothing,
      projection: options.projection,
      resolutions: options.resolutions
    }) || this;
    _this.crossOrigin_ = options.crossOrigin !== void 0 ? options.crossOrigin : null;
    _this.displayDpi_ = options.displayDpi !== void 0 ? options.displayDpi : 96;
    _this.params_ = options.params || {};
    _this.url_ = options.url;
    _this.imageLoadFunction_ = options.imageLoadFunction !== void 0 ? options.imageLoadFunction : defaultImageLoadFunction;
    _this.hidpi_ = options.hidpi !== void 0 ? options.hidpi : true;
    _this.metersPerUnit_ = options.metersPerUnit !== void 0 ? options.metersPerUnit : 1;
    _this.ratio_ = options.ratio !== void 0 ? options.ratio : 1;
    _this.useOverlay_ = options.useOverlay !== void 0 ? options.useOverlay : false;
    _this.image_ = null;
    _this.renderedRevision_ = 0;
    return _this;
  }
  ImageMapGuide2.prototype.getParams = function() {
    return this.params_;
  };
  ImageMapGuide2.prototype.getImageInternal = function(extent, resolution, pixelRatio, projection) {
    resolution = this.findNearestResolution(resolution);
    pixelRatio = this.hidpi_ ? pixelRatio : 1;
    var image = this.image_;
    if (image && this.renderedRevision_ == this.getRevision() && image.getResolution() == resolution && image.getPixelRatio() == pixelRatio && containsExtent(image.getExtent(), extent)) {
      return image;
    }
    if (this.ratio_ != 1) {
      extent = extent.slice();
      scaleFromCenter(extent, this.ratio_);
    }
    var width = getWidth(extent) / resolution;
    var height = getHeight(extent) / resolution;
    var size = [width * pixelRatio, height * pixelRatio];
    if (this.url_ !== void 0) {
      var imageUrl = this.getUrl(this.url_, this.params_, extent, size, projection);
      image = new Image_default(extent, resolution, pixelRatio, imageUrl, this.crossOrigin_, this.imageLoadFunction_);
      image.addEventListener(EventType_default.CHANGE, this.handleImageChange.bind(this));
    } else {
      image = null;
    }
    this.image_ = image;
    this.renderedRevision_ = this.getRevision();
    return image;
  };
  ImageMapGuide2.prototype.getImageLoadFunction = function() {
    return this.imageLoadFunction_;
  };
  ImageMapGuide2.prototype.updateParams = function(params) {
    assign(this.params_, params);
    this.changed();
  };
  ImageMapGuide2.prototype.getUrl = function(baseUrl, params, extent, size, projection) {
    var scale3 = getScale(extent, size, this.metersPerUnit_, this.displayDpi_);
    var center = getCenter(extent);
    var baseParams = {
      "OPERATION": this.useOverlay_ ? "GETDYNAMICMAPOVERLAYIMAGE" : "GETMAPIMAGE",
      "VERSION": "2.0.0",
      "LOCALE": "en",
      "CLIENTAGENT": "ol/source/ImageMapGuide source",
      "CLIP": "1",
      "SETDISPLAYDPI": this.displayDpi_,
      "SETDISPLAYWIDTH": Math.round(size[0]),
      "SETDISPLAYHEIGHT": Math.round(size[1]),
      "SETVIEWSCALE": scale3,
      "SETVIEWCENTERX": center[0],
      "SETVIEWCENTERY": center[1]
    };
    assign(baseParams, params);
    return appendParams(baseUrl, baseParams);
  };
  ImageMapGuide2.prototype.setImageLoadFunction = function(imageLoadFunction) {
    this.image_ = null;
    this.imageLoadFunction_ = imageLoadFunction;
    this.changed();
  };
  return ImageMapGuide2;
}(Image_default4);
function getScale(extent, size, metersPerUnit, dpi) {
  var mcsW = getWidth(extent);
  var mcsH = getHeight(extent);
  var devW = size[0];
  var devH = size[1];
  var mpp = 0.0254 / dpi;
  if (devH * mcsW > devW * mcsH) {
    return mcsW * metersPerUnit / (devW * mpp);
  } else {
    return mcsH * metersPerUnit / (devH * mpp);
  }
}
var ImageMapGuide_default = ImageMapGuide;

// node_modules/ol/source/ImageStatic.js
var __extends14 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var Static = function(_super) {
  __extends14(Static2, _super);
  function Static2(options) {
    var _this = this;
    var crossOrigin = options.crossOrigin !== void 0 ? options.crossOrigin : null;
    var imageLoadFunction = options.imageLoadFunction !== void 0 ? options.imageLoadFunction : defaultImageLoadFunction;
    _this = _super.call(this, {
      attributions: options.attributions,
      imageSmoothing: options.imageSmoothing,
      projection: get(options.projection)
    }) || this;
    _this.url_ = options.url;
    _this.imageExtent_ = options.imageExtent;
    _this.image_ = new Image_default(_this.imageExtent_, void 0, 1, _this.url_, crossOrigin, imageLoadFunction);
    _this.imageSize_ = options.imageSize ? options.imageSize : null;
    _this.image_.addEventListener(EventType_default.CHANGE, _this.handleImageChange.bind(_this));
    return _this;
  }
  Static2.prototype.getImageExtent = function() {
    return this.imageExtent_;
  };
  Static2.prototype.getImageInternal = function(extent, resolution, pixelRatio, projection) {
    if (intersects(extent, this.image_.getExtent())) {
      return this.image_;
    }
    return null;
  };
  Static2.prototype.getUrl = function() {
    return this.url_;
  };
  Static2.prototype.handleImageChange = function(evt) {
    if (this.image_.getState() == ImageState_default.LOADED) {
      var imageExtent = this.image_.getExtent();
      var image = this.image_.getImage();
      var imageWidth = void 0, imageHeight = void 0;
      if (this.imageSize_) {
        imageWidth = this.imageSize_[0];
        imageHeight = this.imageSize_[1];
      } else {
        imageWidth = image.width;
        imageHeight = image.height;
      }
      var extentWidth = getWidth(imageExtent);
      var extentHeight = getHeight(imageExtent);
      var xResolution = extentWidth / imageWidth;
      var yResolution = extentHeight / imageHeight;
      var targetWidth = imageWidth;
      var targetHeight = imageHeight;
      if (xResolution > yResolution) {
        targetWidth = Math.round(extentWidth / yResolution);
      } else {
        targetHeight = Math.round(extentHeight / xResolution);
      }
      if (targetWidth !== imageWidth || targetHeight !== imageHeight) {
        var context2 = createCanvasContext2D(targetWidth, targetHeight);
        assign(context2, this.getContextOptions());
        var canvas = context2.canvas;
        context2.drawImage(image, 0, 0, imageWidth, imageHeight, 0, 0, canvas.width, canvas.height);
        this.image_.setImage(canvas);
      }
    }
    _super.prototype.handleImageChange.call(this, evt);
  };
  return Static2;
}(Image_default4);
var ImageStatic_default = Static;

// node_modules/ol/source/WMSServerType.js
var WMSServerType_default = {
  CARMENTA_SERVER: "carmentaserver",
  GEOSERVER: "geoserver",
  MAPSERVER: "mapserver",
  QGIS: "qgis"
};

// node_modules/ol/source/ImageWMS.js
var __extends15 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var GETFEATUREINFO_IMAGE_SIZE = [101, 101];
var ImageWMS = function(_super) {
  __extends15(ImageWMS2, _super);
  function ImageWMS2(opt_options) {
    var _this = this;
    var options = opt_options ? opt_options : {};
    _this = _super.call(this, {
      attributions: options.attributions,
      imageSmoothing: options.imageSmoothing,
      projection: options.projection,
      resolutions: options.resolutions
    }) || this;
    _this.crossOrigin_ = options.crossOrigin !== void 0 ? options.crossOrigin : null;
    _this.url_ = options.url;
    _this.imageLoadFunction_ = options.imageLoadFunction !== void 0 ? options.imageLoadFunction : defaultImageLoadFunction;
    _this.params_ = options.params || {};
    _this.v13_ = true;
    _this.updateV13_();
    _this.serverType_ = options.serverType;
    _this.hidpi_ = options.hidpi !== void 0 ? options.hidpi : true;
    _this.image_ = null;
    _this.imageSize_ = [0, 0];
    _this.renderedRevision_ = 0;
    _this.ratio_ = options.ratio !== void 0 ? options.ratio : 1.5;
    return _this;
  }
  ImageWMS2.prototype.getFeatureInfoUrl = function(coordinate, resolution, projection, params) {
    if (this.url_ === void 0) {
      return void 0;
    }
    var projectionObj = get(projection);
    var sourceProjectionObj = this.getProjection();
    if (sourceProjectionObj && sourceProjectionObj !== projectionObj) {
      resolution = calculateSourceResolution(sourceProjectionObj, projectionObj, coordinate, resolution);
      coordinate = transform(coordinate, projectionObj, sourceProjectionObj);
    }
    var extent = getForViewAndSize(coordinate, resolution, 0, GETFEATUREINFO_IMAGE_SIZE);
    var baseParams = {
      "SERVICE": "WMS",
      "VERSION": DEFAULT_WMS_VERSION,
      "REQUEST": "GetFeatureInfo",
      "FORMAT": "image/png",
      "TRANSPARENT": true,
      "QUERY_LAYERS": this.params_["LAYERS"]
    };
    assign(baseParams, this.params_, params);
    var x = Math.floor((coordinate[0] - extent[0]) / resolution);
    var y = Math.floor((extent[3] - coordinate[1]) / resolution);
    baseParams[this.v13_ ? "I" : "X"] = x;
    baseParams[this.v13_ ? "J" : "Y"] = y;
    return this.getRequestUrl_(extent, GETFEATUREINFO_IMAGE_SIZE, 1, sourceProjectionObj || projectionObj, baseParams);
  };
  ImageWMS2.prototype.getLegendUrl = function(resolution, params) {
    if (this.url_ === void 0) {
      return void 0;
    }
    var baseParams = {
      "SERVICE": "WMS",
      "VERSION": DEFAULT_WMS_VERSION,
      "REQUEST": "GetLegendGraphic",
      "FORMAT": "image/png"
    };
    if (params === void 0 || params["LAYER"] === void 0) {
      var layers = this.params_.LAYERS;
      var isSingleLayer = !Array.isArray(layers) || layers.length === 1;
      if (!isSingleLayer) {
        return void 0;
      }
      baseParams["LAYER"] = layers;
    }
    if (resolution !== void 0) {
      var mpu = this.getProjection() ? this.getProjection().getMetersPerUnit() : 1;
      var pixelSize = 28e-5;
      baseParams["SCALE"] = resolution * mpu / pixelSize;
    }
    assign(baseParams, params);
    return appendParams(this.url_, baseParams);
  };
  ImageWMS2.prototype.getParams = function() {
    return this.params_;
  };
  ImageWMS2.prototype.getImageInternal = function(extent, resolution, pixelRatio, projection) {
    if (this.url_ === void 0) {
      return null;
    }
    resolution = this.findNearestResolution(resolution);
    if (pixelRatio != 1 && (!this.hidpi_ || this.serverType_ === void 0)) {
      pixelRatio = 1;
    }
    var imageResolution = resolution / pixelRatio;
    var center = getCenter(extent);
    var viewWidth = Math.ceil(getWidth(extent) / imageResolution);
    var viewHeight = Math.ceil(getHeight(extent) / imageResolution);
    var viewExtent = getForViewAndSize(center, imageResolution, 0, [
      viewWidth,
      viewHeight
    ]);
    var requestWidth = Math.ceil(this.ratio_ * getWidth(extent) / imageResolution);
    var requestHeight = Math.ceil(this.ratio_ * getHeight(extent) / imageResolution);
    var requestExtent = getForViewAndSize(center, imageResolution, 0, [
      requestWidth,
      requestHeight
    ]);
    var image = this.image_;
    if (image && this.renderedRevision_ == this.getRevision() && image.getResolution() == resolution && image.getPixelRatio() == pixelRatio && containsExtent(image.getExtent(), viewExtent)) {
      return image;
    }
    var params = {
      "SERVICE": "WMS",
      "VERSION": DEFAULT_WMS_VERSION,
      "REQUEST": "GetMap",
      "FORMAT": "image/png",
      "TRANSPARENT": true
    };
    assign(params, this.params_);
    this.imageSize_[0] = Math.round(getWidth(requestExtent) / imageResolution);
    this.imageSize_[1] = Math.round(getHeight(requestExtent) / imageResolution);
    var url2 = this.getRequestUrl_(requestExtent, this.imageSize_, pixelRatio, projection, params);
    this.image_ = new Image_default(requestExtent, resolution, pixelRatio, url2, this.crossOrigin_, this.imageLoadFunction_);
    this.renderedRevision_ = this.getRevision();
    this.image_.addEventListener(EventType_default.CHANGE, this.handleImageChange.bind(this));
    return this.image_;
  };
  ImageWMS2.prototype.getImageLoadFunction = function() {
    return this.imageLoadFunction_;
  };
  ImageWMS2.prototype.getRequestUrl_ = function(extent, size, pixelRatio, projection, params) {
    assert(this.url_ !== void 0, 9);
    params[this.v13_ ? "CRS" : "SRS"] = projection.getCode();
    if (!("STYLES" in this.params_)) {
      params["STYLES"] = "";
    }
    if (pixelRatio != 1) {
      switch (this.serverType_) {
        case WMSServerType_default.GEOSERVER:
          var dpi = 90 * pixelRatio + 0.5 | 0;
          if ("FORMAT_OPTIONS" in params) {
            params["FORMAT_OPTIONS"] += ";dpi:" + dpi;
          } else {
            params["FORMAT_OPTIONS"] = "dpi:" + dpi;
          }
          break;
        case WMSServerType_default.MAPSERVER:
          params["MAP_RESOLUTION"] = 90 * pixelRatio;
          break;
        case WMSServerType_default.CARMENTA_SERVER:
        case WMSServerType_default.QGIS:
          params["DPI"] = 90 * pixelRatio;
          break;
        default:
          assert(false, 8);
          break;
      }
    }
    params["WIDTH"] = size[0];
    params["HEIGHT"] = size[1];
    var axisOrientation = projection.getAxisOrientation();
    var bbox;
    if (this.v13_ && axisOrientation.substr(0, 2) == "ne") {
      bbox = [extent[1], extent[0], extent[3], extent[2]];
    } else {
      bbox = extent;
    }
    params["BBOX"] = bbox.join(",");
    return appendParams(this.url_, params);
  };
  ImageWMS2.prototype.getUrl = function() {
    return this.url_;
  };
  ImageWMS2.prototype.setImageLoadFunction = function(imageLoadFunction) {
    this.image_ = null;
    this.imageLoadFunction_ = imageLoadFunction;
    this.changed();
  };
  ImageWMS2.prototype.setUrl = function(url2) {
    if (url2 != this.url_) {
      this.url_ = url2;
      this.image_ = null;
      this.changed();
    }
  };
  ImageWMS2.prototype.updateParams = function(params) {
    assign(this.params_, params);
    this.updateV13_();
    this.image_ = null;
    this.changed();
  };
  ImageWMS2.prototype.updateV13_ = function() {
    var version = this.params_["VERSION"] || DEFAULT_WMS_VERSION;
    this.v13_ = compareVersions(version, "1.3") >= 0;
  };
  return ImageWMS2;
}(Image_default4);
var ImageWMS_default = ImageWMS;

// node_modules/ol/source/Raster.js
var __extends16 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var hasImageData = true;
try {
  new ImageData(10, 10);
} catch (_3) {
  hasImageData = false;
}
var context;
function newImageData(data, width, height) {
  if (hasImageData) {
    return new ImageData(data, width, height);
  }
  if (!context) {
    context = document.createElement("canvas").getContext("2d");
  }
  var imageData = context.createImageData(width, height);
  imageData.data.set(data);
  return imageData;
}
function createMinion(operation) {
  var workerHasImageData = true;
  try {
    new ImageData(10, 10);
  } catch (_3) {
    workerHasImageData = false;
  }
  function newWorkerImageData(data, width, height) {
    if (workerHasImageData) {
      return new ImageData(data, width, height);
    } else {
      return { data, width, height };
    }
  }
  return function(data) {
    var buffers = data["buffers"];
    var meta = data["meta"];
    var imageOps = data["imageOps"];
    var width = data["width"];
    var height = data["height"];
    var numBuffers = buffers.length;
    var numBytes = buffers[0].byteLength;
    if (imageOps) {
      var images = new Array(numBuffers);
      for (var b = 0; b < numBuffers; ++b) {
        images[b] = newWorkerImageData(new Uint8ClampedArray(buffers[b]), width, height);
      }
      var output_1 = operation(images, meta).data;
      return output_1.buffer;
    }
    var output = new Uint8ClampedArray(numBytes);
    var arrays = new Array(numBuffers);
    var pixels = new Array(numBuffers);
    for (var b = 0; b < numBuffers; ++b) {
      arrays[b] = new Uint8ClampedArray(buffers[b]);
      pixels[b] = [0, 0, 0, 0];
    }
    for (var i = 0; i < numBytes; i += 4) {
      for (var j = 0; j < numBuffers; ++j) {
        var array = arrays[j];
        pixels[j][0] = array[i];
        pixels[j][1] = array[i + 1];
        pixels[j][2] = array[i + 2];
        pixels[j][3] = array[i + 3];
      }
      var pixel = operation(pixels, meta);
      output[i] = pixel[0];
      output[i + 1] = pixel[1];
      output[i + 2] = pixel[2];
      output[i + 3] = pixel[3];
    }
    return output.buffer;
  };
}
function createWorker(config, onMessage) {
  var lib = Object.keys(config.lib || {}).map(function(name) {
    return "var " + name + " = " + config.lib[name].toString() + ";";
  });
  var lines = lib.concat([
    "var __minion__ = (" + createMinion.toString() + ")(",
    config.operation.toString(),
    ");",
    'self.addEventListener("message", function(event) {',
    "  var buffer = __minion__(event.data);",
    "  self.postMessage({buffer: buffer, meta: event.data.meta}, [buffer]);",
    "});"
  ]);
  var blob2 = new Blob(lines, { type: "text/javascript" });
  var source2 = URL.createObjectURL(blob2);
  var worker = new Worker(source2);
  worker.addEventListener("message", onMessage);
  return worker;
}
function createFauxWorker(config, onMessage) {
  var minion = createMinion(config.operation);
  var terminated = false;
  return {
    postMessage: function(data) {
      setTimeout(function() {
        if (terminated) {
          return;
        }
        onMessage({ data: { buffer: minion(data), meta: data["meta"] } });
      }, 0);
    },
    terminate: function() {
      terminated = true;
    }
  };
}
var Processor = function(_super) {
  __extends16(Processor2, _super);
  function Processor2(config) {
    var _this = _super.call(this) || this;
    _this._imageOps = !!config.imageOps;
    var threads;
    if (config.threads === 0) {
      threads = 0;
    } else if (_this._imageOps) {
      threads = 1;
    } else {
      threads = config.threads || 1;
    }
    var workers = new Array(threads);
    if (threads) {
      for (var i = 0; i < threads; ++i) {
        workers[i] = createWorker(config, _this._onWorkerMessage.bind(_this, i));
      }
    } else {
      workers[0] = createFauxWorker(config, _this._onWorkerMessage.bind(_this, 0));
    }
    _this._workers = workers;
    _this._queue = [];
    _this._maxQueueLength = config.queue || Infinity;
    _this._running = 0;
    _this._dataLookup = {};
    _this._job = null;
    return _this;
  }
  Processor2.prototype.process = function(inputs, meta, callback) {
    this._enqueue({
      inputs,
      meta,
      callback
    });
    this._dispatch();
  };
  Processor2.prototype._enqueue = function(job) {
    this._queue.push(job);
    while (this._queue.length > this._maxQueueLength) {
      this._queue.shift().callback(null, null);
    }
  };
  Processor2.prototype._dispatch = function() {
    if (this._running || this._queue.length === 0) {
      return;
    }
    var job = this._queue.shift();
    this._job = job;
    var width = job.inputs[0].width;
    var height = job.inputs[0].height;
    var buffers = job.inputs.map(function(input) {
      return input.data.buffer;
    });
    var threads = this._workers.length;
    this._running = threads;
    if (threads === 1) {
      this._workers[0].postMessage({
        buffers,
        meta: job.meta,
        imageOps: this._imageOps,
        width,
        height
      }, buffers);
      return;
    }
    var length = job.inputs[0].data.length;
    var segmentLength = 4 * Math.ceil(length / 4 / threads);
    for (var i = 0; i < threads; ++i) {
      var offset = i * segmentLength;
      var slices = [];
      for (var j = 0, jj = buffers.length; j < jj; ++j) {
        slices.push(buffers[j].slice(offset, offset + segmentLength));
      }
      this._workers[i].postMessage({
        buffers: slices,
        meta: job.meta,
        imageOps: this._imageOps,
        width,
        height
      }, slices);
    }
  };
  Processor2.prototype._onWorkerMessage = function(index, event) {
    if (this.disposed) {
      return;
    }
    this._dataLookup[index] = event.data;
    --this._running;
    if (this._running === 0) {
      this._resolveJob();
    }
  };
  Processor2.prototype._resolveJob = function() {
    var job = this._job;
    var threads = this._workers.length;
    var data, meta;
    if (threads === 1) {
      data = new Uint8ClampedArray(this._dataLookup[0]["buffer"]);
      meta = this._dataLookup[0]["meta"];
    } else {
      var length_1 = job.inputs[0].data.length;
      data = new Uint8ClampedArray(length_1);
      meta = new Array(threads);
      var segmentLength = 4 * Math.ceil(length_1 / 4 / threads);
      for (var i = 0; i < threads; ++i) {
        var buffer4 = this._dataLookup[i]["buffer"];
        var offset = i * segmentLength;
        data.set(new Uint8ClampedArray(buffer4), offset);
        meta[i] = this._dataLookup[i]["meta"];
      }
    }
    this._job = null;
    this._dataLookup = {};
    job.callback(null, newImageData(data, job.inputs[0].width, job.inputs[0].height), meta);
    this._dispatch();
  };
  Processor2.prototype.disposeInternal = function() {
    for (var i = 0; i < this._workers.length; ++i) {
      this._workers[i].terminate();
    }
    this._workers.length = 0;
  };
  return Processor2;
}(Disposable_default);
var RasterEventType = {
  BEFOREOPERATIONS: "beforeoperations",
  AFTEROPERATIONS: "afteroperations"
};
var RasterOperationType = {
  PIXEL: "pixel",
  IMAGE: "image"
};
var RasterSourceEvent = function(_super) {
  __extends16(RasterSourceEvent2, _super);
  function RasterSourceEvent2(type, frameState, data) {
    var _this = _super.call(this, type) || this;
    _this.extent = frameState.extent;
    _this.resolution = frameState.viewState.resolution / frameState.pixelRatio;
    _this.data = data;
    return _this;
  }
  return RasterSourceEvent2;
}(Event_default);
var RasterSource = function(_super) {
  __extends16(RasterSource2, _super);
  function RasterSource2(options) {
    var _this = _super.call(this, {
      projection: null
    }) || this;
    _this.on;
    _this.once;
    _this.un;
    _this.processor_ = null;
    _this.operationType_ = options.operationType !== void 0 ? options.operationType : RasterOperationType.PIXEL;
    _this.threads_ = options.threads !== void 0 ? options.threads : 1;
    _this.layers_ = createLayers(options.sources);
    var changed = _this.changed.bind(_this);
    for (var i = 0, ii = _this.layers_.length; i < ii; ++i) {
      _this.layers_[i].addEventListener(EventType_default.CHANGE, changed);
    }
    _this.tileQueue_ = new TileQueue_default(function() {
      return 1;
    }, _this.changed.bind(_this));
    _this.requestedFrameState_;
    _this.renderedImageCanvas_ = null;
    _this.renderedRevision_;
    _this.frameState_ = {
      animate: false,
      coordinateToPixelTransform: create(),
      declutterTree: null,
      extent: null,
      index: 0,
      layerIndex: 0,
      layerStatesArray: getLayerStatesArray(_this.layers_),
      pixelRatio: 1,
      pixelToCoordinateTransform: create(),
      postRenderFunctions: [],
      size: [0, 0],
      tileQueue: _this.tileQueue_,
      time: Date.now(),
      usedTiles: {},
      viewState: {
        rotation: 0
      },
      viewHints: [],
      wantedTiles: {}
    };
    _this.setAttributions(function(frameState) {
      var attributions = [];
      for (var index = 0, iMax = options.sources.length; index < iMax; ++index) {
        var sourceOrLayer = options.sources[index];
        var source2 = sourceOrLayer instanceof Source_default ? sourceOrLayer : sourceOrLayer.getSource();
        var attributionGetter = source2.getAttributions();
        if (typeof attributionGetter === "function") {
          var sourceAttribution = attributionGetter(frameState);
          attributions.push.apply(attributions, sourceAttribution);
        }
      }
      return attributions.length !== 0 ? attributions : null;
    });
    if (options.operation !== void 0) {
      _this.setOperation(options.operation, options.lib);
    }
    return _this;
  }
  RasterSource2.prototype.setOperation = function(operation, opt_lib) {
    if (this.processor_) {
      this.processor_.dispose();
    }
    this.processor_ = new Processor({
      operation,
      imageOps: this.operationType_ === RasterOperationType.IMAGE,
      queue: 1,
      lib: opt_lib,
      threads: this.threads_
    });
    this.changed();
  };
  RasterSource2.prototype.updateFrameState_ = function(extent, resolution, projection) {
    var frameState = assign({}, this.frameState_);
    frameState.viewState = assign({}, frameState.viewState);
    var center = getCenter(extent);
    frameState.extent = extent.slice();
    frameState.size[0] = Math.round(getWidth(extent) / resolution);
    frameState.size[1] = Math.round(getHeight(extent) / resolution);
    frameState.time = Date.now();
    var viewState = frameState.viewState;
    viewState.center = center;
    viewState.projection = projection;
    viewState.resolution = resolution;
    return frameState;
  };
  RasterSource2.prototype.allSourcesReady_ = function() {
    var ready = true;
    var source2;
    for (var i = 0, ii = this.layers_.length; i < ii; ++i) {
      source2 = this.layers_[i].getSource();
      if (source2.getState() !== State_default.READY) {
        ready = false;
        break;
      }
    }
    return ready;
  };
  RasterSource2.prototype.getImage = function(extent, resolution, pixelRatio, projection) {
    if (!this.allSourcesReady_()) {
      return null;
    }
    var frameState = this.updateFrameState_(extent, resolution, projection);
    this.requestedFrameState_ = frameState;
    if (this.renderedImageCanvas_) {
      var renderedResolution = this.renderedImageCanvas_.getResolution();
      var renderedExtent = this.renderedImageCanvas_.getExtent();
      if (resolution !== renderedResolution || !equals(extent, renderedExtent)) {
        this.renderedImageCanvas_ = null;
      }
    }
    if (!this.renderedImageCanvas_ || this.getRevision() !== this.renderedRevision_) {
      this.processSources_();
    }
    frameState.tileQueue.loadMoreTiles(16, 16);
    if (frameState.animate) {
      requestAnimationFrame(this.changed.bind(this));
    }
    return this.renderedImageCanvas_;
  };
  RasterSource2.prototype.processSources_ = function() {
    var frameState = this.requestedFrameState_;
    var len = this.layers_.length;
    var imageDatas = new Array(len);
    for (var i = 0; i < len; ++i) {
      frameState.layerIndex = i;
      var imageData = getImageData(this.layers_[i], frameState);
      if (imageData) {
        imageDatas[i] = imageData;
      } else {
        return;
      }
    }
    var data = {};
    this.dispatchEvent(new RasterSourceEvent(RasterEventType.BEFOREOPERATIONS, frameState, data));
    this.processor_.process(imageDatas, data, this.onWorkerComplete_.bind(this, frameState));
  };
  RasterSource2.prototype.onWorkerComplete_ = function(frameState, err, output, data) {
    if (err || !output) {
      return;
    }
    var extent = frameState.extent;
    var resolution = frameState.viewState.resolution;
    if (resolution !== this.requestedFrameState_.viewState.resolution || !equals(extent, this.requestedFrameState_.extent)) {
      return;
    }
    var context2;
    if (this.renderedImageCanvas_) {
      context2 = this.renderedImageCanvas_.getImage().getContext("2d");
    } else {
      var width = Math.round(getWidth(extent) / resolution);
      var height = Math.round(getHeight(extent) / resolution);
      context2 = createCanvasContext2D(width, height);
      this.renderedImageCanvas_ = new ImageCanvas_default(extent, resolution, 1, context2.canvas);
    }
    context2.putImageData(output, 0, 0);
    this.changed();
    this.renderedRevision_ = this.getRevision();
    this.dispatchEvent(new RasterSourceEvent(RasterEventType.AFTEROPERATIONS, frameState, data));
    if (frameState.animate) {
      requestAnimationFrame(this.changed.bind(this));
    }
  };
  RasterSource2.prototype.disposeInternal = function() {
    if (this.processor_) {
      this.processor_.dispose();
    }
    _super.prototype.disposeInternal.call(this);
  };
  return RasterSource2;
}(Image_default4);
RasterSource.prototype.dispose;
var sharedContext = null;
function getImageData(layer, frameState) {
  var renderer = layer.getRenderer();
  if (!renderer) {
    throw new Error("Unsupported layer type: " + layer);
  }
  if (!renderer.prepareFrame(frameState)) {
    return null;
  }
  var width = frameState.size[0];
  var height = frameState.size[1];
  if (width === 0 || height === 0) {
    return null;
  }
  var container = renderer.renderFrame(frameState, null);
  var element;
  if (container) {
    element = container.firstElementChild;
  }
  if (!(element instanceof HTMLCanvasElement)) {
    throw new Error("Unsupported rendered element: " + element);
  }
  if (element.width === width && element.height === height) {
    var context_1 = element.getContext("2d");
    return context_1.getImageData(0, 0, width, height);
  }
  if (!sharedContext) {
    sharedContext = createCanvasContext2D(width, height);
  } else {
    var canvas = sharedContext.canvas;
    if (canvas.width !== width || canvas.height !== height) {
      sharedContext = createCanvasContext2D(width, height);
    } else {
      sharedContext.clearRect(0, 0, width, height);
    }
  }
  sharedContext.drawImage(element, 0, 0, width, height);
  return sharedContext.getImageData(0, 0, width, height);
}
function getLayerStatesArray(layers) {
  return layers.map(function(layer) {
    return layer.getLayerState();
  });
}
function createLayers(sources) {
  var len = sources.length;
  var layers = new Array(len);
  for (var i = 0; i < len; ++i) {
    layers[i] = createLayer(sources[i]);
  }
  return layers;
}
function createLayer(layerOrSource) {
  var layer;
  if (layerOrSource instanceof Source_default) {
    if (layerOrSource instanceof Tile_default2) {
      layer = new Tile_default3({ source: layerOrSource });
    } else if (layerOrSource instanceof Image_default4) {
      layer = new Image_default2({ source: layerOrSource });
    }
  } else {
    layer = layerOrSource;
  }
  return layer;
}
var Raster_default = RasterSource;

// node_modules/ol/source/Stamen.js
var __extends17 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var ATTRIBUTIONS = [
  'Map tiles by <a href="https://stamen.com/" target="_blank">Stamen Design</a>, under <a href="https://creativecommons.org/licenses/by/3.0/" target="_blank">CC BY 3.0</a>.',
  ATTRIBUTION
];
var LayerConfig = {
  "terrain": {
    extension: "jpg",
    opaque: true
  },
  "terrain-background": {
    extension: "jpg",
    opaque: true
  },
  "terrain-labels": {
    extension: "png",
    opaque: false
  },
  "terrain-lines": {
    extension: "png",
    opaque: false
  },
  "toner-background": {
    extension: "png",
    opaque: true
  },
  "toner": {
    extension: "png",
    opaque: true
  },
  "toner-hybrid": {
    extension: "png",
    opaque: false
  },
  "toner-labels": {
    extension: "png",
    opaque: false
  },
  "toner-lines": {
    extension: "png",
    opaque: false
  },
  "toner-lite": {
    extension: "png",
    opaque: true
  },
  "watercolor": {
    extension: "jpg",
    opaque: true
  }
};
var ProviderConfig = {
  "terrain": {
    minZoom: 0,
    maxZoom: 18
  },
  "toner": {
    minZoom: 0,
    maxZoom: 20
  },
  "watercolor": {
    minZoom: 0,
    maxZoom: 18
  }
};
var Stamen = function(_super) {
  __extends17(Stamen2, _super);
  function Stamen2(options) {
    var _this = this;
    var i = options.layer.indexOf("-");
    var provider = i == -1 ? options.layer : options.layer.slice(0, i);
    var providerConfig = ProviderConfig[provider];
    var layerConfig = LayerConfig[options.layer];
    var url2 = options.url !== void 0 ? options.url : "https://stamen-tiles-{a-d}.a.ssl.fastly.net/" + options.layer + "/{z}/{x}/{y}." + layerConfig.extension;
    _this = _super.call(this, {
      attributions: ATTRIBUTIONS,
      cacheSize: options.cacheSize,
      crossOrigin: "anonymous",
      imageSmoothing: options.imageSmoothing,
      maxZoom: options.maxZoom != void 0 ? options.maxZoom : providerConfig.maxZoom,
      minZoom: options.minZoom != void 0 ? options.minZoom : providerConfig.minZoom,
      opaque: layerConfig.opaque,
      reprojectionErrorThreshold: options.reprojectionErrorThreshold,
      tileLoadFunction: options.tileLoadFunction,
      transition: options.transition,
      url: url2,
      wrapX: options.wrapX,
      zDirection: options.zDirection
    }) || this;
    return _this;
  }
  return Stamen2;
}(XYZ_default);
var Stamen_default = Stamen;

// node_modules/ol/source/TileArcGISRest.js
var __extends18 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var TileArcGISRest = function(_super) {
  __extends18(TileArcGISRest2, _super);
  function TileArcGISRest2(opt_options) {
    var _this = this;
    var options = opt_options ? opt_options : {};
    _this = _super.call(this, {
      attributions: options.attributions,
      cacheSize: options.cacheSize,
      crossOrigin: options.crossOrigin,
      imageSmoothing: options.imageSmoothing,
      projection: options.projection,
      reprojectionErrorThreshold: options.reprojectionErrorThreshold,
      tileGrid: options.tileGrid,
      tileLoadFunction: options.tileLoadFunction,
      url: options.url,
      urls: options.urls,
      wrapX: options.wrapX !== void 0 ? options.wrapX : true,
      transition: options.transition,
      zDirection: options.zDirection
    }) || this;
    _this.params_ = options.params || {};
    _this.hidpi_ = options.hidpi !== void 0 ? options.hidpi : true;
    _this.tmpExtent_ = createEmpty();
    _this.setKey(_this.getKeyForParams_());
    return _this;
  }
  TileArcGISRest2.prototype.getKeyForParams_ = function() {
    var i = 0;
    var res = [];
    for (var key in this.params_) {
      res[i++] = key + "-" + this.params_[key];
    }
    return res.join("/");
  };
  TileArcGISRest2.prototype.getParams = function() {
    return this.params_;
  };
  TileArcGISRest2.prototype.getRequestUrl_ = function(tileCoord, tileSize, tileExtent, pixelRatio, projection, params) {
    var urls = this.urls;
    if (!urls) {
      return void 0;
    }
    var srid = projection.getCode().split(/:(?=\d+$)/).pop();
    params["SIZE"] = tileSize[0] + "," + tileSize[1];
    params["BBOX"] = tileExtent.join(",");
    params["BBOXSR"] = srid;
    params["IMAGESR"] = srid;
    params["DPI"] = Math.round(params["DPI"] ? params["DPI"] * pixelRatio : 90 * pixelRatio);
    var url2;
    if (urls.length == 1) {
      url2 = urls[0];
    } else {
      var index = modulo(hash(tileCoord), urls.length);
      url2 = urls[index];
    }
    var modifiedUrl = url2.replace(/MapServer\/?$/, "MapServer/export").replace(/ImageServer\/?$/, "ImageServer/exportImage");
    return appendParams(modifiedUrl, params);
  };
  TileArcGISRest2.prototype.getTilePixelRatio = function(pixelRatio) {
    return this.hidpi_ ? pixelRatio : 1;
  };
  TileArcGISRest2.prototype.updateParams = function(params) {
    assign(this.params_, params);
    this.setKey(this.getKeyForParams_());
  };
  TileArcGISRest2.prototype.tileUrlFunction = function(tileCoord, pixelRatio, projection) {
    var tileGrid = this.getTileGrid();
    if (!tileGrid) {
      tileGrid = this.getTileGridForProjection(projection);
    }
    if (tileGrid.getResolutions().length <= tileCoord[0]) {
      return void 0;
    }
    if (pixelRatio != 1 && !this.hidpi_) {
      pixelRatio = 1;
    }
    var tileExtent = tileGrid.getTileCoordExtent(tileCoord, this.tmpExtent_);
    var tileSize = toSize(tileGrid.getTileSize(tileCoord[0]), this.tmpSize);
    if (pixelRatio != 1) {
      tileSize = scale2(tileSize, pixelRatio, this.tmpSize);
    }
    var baseParams = {
      "F": "image",
      "FORMAT": "PNG32",
      "TRANSPARENT": true
    };
    assign(baseParams, this.params_);
    return this.getRequestUrl_(tileCoord, tileSize, tileExtent, pixelRatio, projection, baseParams);
  };
  return TileArcGISRest2;
}(TileImage_default);
var TileArcGISRest_default = TileArcGISRest;

// node_modules/ol/source/TileDebug.js
var __extends19 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var TileDebug = function(_super) {
  __extends19(TileDebug2, _super);
  function TileDebug2(opt_options) {
    var _this = this;
    var options = opt_options || {};
    _this = _super.call(this, {
      opaque: false,
      projection: options.projection,
      tileGrid: options.tileGrid,
      wrapX: options.wrapX !== void 0 ? options.wrapX : true,
      zDirection: options.zDirection,
      url: options.template || "z:{z} x:{x} y:{y}",
      tileLoadFunction: function(tile, text) {
        var z = tile.getTileCoord()[0];
        var tileSize = toSize(_this.tileGrid.getTileSize(z));
        var context2 = createCanvasContext2D(tileSize[0], tileSize[1]);
        context2.strokeStyle = "grey";
        context2.strokeRect(0.5, 0.5, tileSize[0] + 0.5, tileSize[1] + 0.5);
        context2.fillStyle = "grey";
        context2.strokeStyle = "white";
        context2.textAlign = "center";
        context2.textBaseline = "middle";
        context2.font = "24px sans-serif";
        context2.lineWidth = 4;
        context2.strokeText(text, tileSize[0] / 2, tileSize[1] / 2, tileSize[0]);
        context2.fillText(text, tileSize[0] / 2, tileSize[1] / 2, tileSize[0]);
        tile.setImage(context2.canvas);
      }
    }) || this;
    return _this;
  }
  return TileDebug2;
}(XYZ_default);
var TileDebug_default = TileDebug;

// node_modules/ol/source/TileWMS.js
var __extends20 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var TileWMS = function(_super) {
  __extends20(TileWMS2, _super);
  function TileWMS2(opt_options) {
    var _this = this;
    var options = opt_options ? opt_options : {};
    var params = options.params || {};
    var transparent = "TRANSPARENT" in params ? params["TRANSPARENT"] : true;
    _this = _super.call(this, {
      attributions: options.attributions,
      attributionsCollapsible: options.attributionsCollapsible,
      cacheSize: options.cacheSize,
      crossOrigin: options.crossOrigin,
      imageSmoothing: options.imageSmoothing,
      opaque: !transparent,
      projection: options.projection,
      reprojectionErrorThreshold: options.reprojectionErrorThreshold,
      tileClass: options.tileClass,
      tileGrid: options.tileGrid,
      tileLoadFunction: options.tileLoadFunction,
      url: options.url,
      urls: options.urls,
      wrapX: options.wrapX !== void 0 ? options.wrapX : true,
      transition: options.transition,
      zDirection: options.zDirection
    }) || this;
    _this.gutter_ = options.gutter !== void 0 ? options.gutter : 0;
    _this.params_ = params;
    _this.v13_ = true;
    _this.serverType_ = options.serverType;
    _this.hidpi_ = options.hidpi !== void 0 ? options.hidpi : true;
    _this.tmpExtent_ = createEmpty();
    _this.updateV13_();
    _this.setKey(_this.getKeyForParams_());
    return _this;
  }
  TileWMS2.prototype.getFeatureInfoUrl = function(coordinate, resolution, projection, params) {
    var projectionObj = get(projection);
    var sourceProjectionObj = this.getProjection();
    var tileGrid = this.getTileGrid();
    if (!tileGrid) {
      tileGrid = this.getTileGridForProjection(projectionObj);
    }
    var z = tileGrid.getZForResolution(resolution, this.zDirection);
    var tileCoord = tileGrid.getTileCoordForCoordAndZ(coordinate, z);
    if (tileGrid.getResolutions().length <= tileCoord[0]) {
      return void 0;
    }
    var tileResolution = tileGrid.getResolution(tileCoord[0]);
    var tileExtent = tileGrid.getTileCoordExtent(tileCoord, this.tmpExtent_);
    var tileSize = toSize(tileGrid.getTileSize(tileCoord[0]), this.tmpSize);
    var gutter = this.gutter_;
    if (gutter !== 0) {
      tileSize = buffer2(tileSize, gutter, this.tmpSize);
      tileExtent = buffer(tileExtent, tileResolution * gutter, tileExtent);
    }
    if (sourceProjectionObj && sourceProjectionObj !== projectionObj) {
      tileResolution = calculateSourceResolution(sourceProjectionObj, projectionObj, coordinate, tileResolution);
      tileExtent = transformExtent(tileExtent, projectionObj, sourceProjectionObj);
      coordinate = transform(coordinate, projectionObj, sourceProjectionObj);
    }
    var baseParams = {
      "SERVICE": "WMS",
      "VERSION": DEFAULT_WMS_VERSION,
      "REQUEST": "GetFeatureInfo",
      "FORMAT": "image/png",
      "TRANSPARENT": true,
      "QUERY_LAYERS": this.params_["LAYERS"]
    };
    assign(baseParams, this.params_, params);
    var x = Math.floor((coordinate[0] - tileExtent[0]) / tileResolution);
    var y = Math.floor((tileExtent[3] - coordinate[1]) / tileResolution);
    baseParams[this.v13_ ? "I" : "X"] = x;
    baseParams[this.v13_ ? "J" : "Y"] = y;
    return this.getRequestUrl_(tileCoord, tileSize, tileExtent, 1, sourceProjectionObj || projectionObj, baseParams);
  };
  TileWMS2.prototype.getLegendUrl = function(resolution, params) {
    if (this.urls[0] === void 0) {
      return void 0;
    }
    var baseParams = {
      "SERVICE": "WMS",
      "VERSION": DEFAULT_WMS_VERSION,
      "REQUEST": "GetLegendGraphic",
      "FORMAT": "image/png"
    };
    if (params === void 0 || params["LAYER"] === void 0) {
      var layers = this.params_.LAYERS;
      var isSingleLayer = !Array.isArray(layers) || layers.length === 1;
      if (!isSingleLayer) {
        return void 0;
      }
      baseParams["LAYER"] = layers;
    }
    if (resolution !== void 0) {
      var mpu = this.getProjection() ? this.getProjection().getMetersPerUnit() : 1;
      var pixelSize = 28e-5;
      baseParams["SCALE"] = resolution * mpu / pixelSize;
    }
    assign(baseParams, params);
    return appendParams(this.urls[0], baseParams);
  };
  TileWMS2.prototype.getGutter = function() {
    return this.gutter_;
  };
  TileWMS2.prototype.getParams = function() {
    return this.params_;
  };
  TileWMS2.prototype.getRequestUrl_ = function(tileCoord, tileSize, tileExtent, pixelRatio, projection, params) {
    var urls = this.urls;
    if (!urls) {
      return void 0;
    }
    params["WIDTH"] = tileSize[0];
    params["HEIGHT"] = tileSize[1];
    params[this.v13_ ? "CRS" : "SRS"] = projection.getCode();
    if (!("STYLES" in this.params_)) {
      params["STYLES"] = "";
    }
    if (pixelRatio != 1) {
      switch (this.serverType_) {
        case WMSServerType_default.GEOSERVER:
          var dpi = 90 * pixelRatio + 0.5 | 0;
          if ("FORMAT_OPTIONS" in params) {
            params["FORMAT_OPTIONS"] += ";dpi:" + dpi;
          } else {
            params["FORMAT_OPTIONS"] = "dpi:" + dpi;
          }
          break;
        case WMSServerType_default.MAPSERVER:
          params["MAP_RESOLUTION"] = 90 * pixelRatio;
          break;
        case WMSServerType_default.CARMENTA_SERVER:
        case WMSServerType_default.QGIS:
          params["DPI"] = 90 * pixelRatio;
          break;
        default:
          assert(false, 52);
          break;
      }
    }
    var axisOrientation = projection.getAxisOrientation();
    var bbox = tileExtent;
    if (this.v13_ && axisOrientation.substr(0, 2) == "ne") {
      var tmp = void 0;
      tmp = tileExtent[0];
      bbox[0] = tileExtent[1];
      bbox[1] = tmp;
      tmp = tileExtent[2];
      bbox[2] = tileExtent[3];
      bbox[3] = tmp;
    }
    params["BBOX"] = bbox.join(",");
    var url2;
    if (urls.length == 1) {
      url2 = urls[0];
    } else {
      var index = modulo(hash(tileCoord), urls.length);
      url2 = urls[index];
    }
    return appendParams(url2, params);
  };
  TileWMS2.prototype.getTilePixelRatio = function(pixelRatio) {
    return !this.hidpi_ || this.serverType_ === void 0 ? 1 : pixelRatio;
  };
  TileWMS2.prototype.getKeyForParams_ = function() {
    var i = 0;
    var res = [];
    for (var key in this.params_) {
      res[i++] = key + "-" + this.params_[key];
    }
    return res.join("/");
  };
  TileWMS2.prototype.updateParams = function(params) {
    assign(this.params_, params);
    this.updateV13_();
    this.setKey(this.getKeyForParams_());
  };
  TileWMS2.prototype.updateV13_ = function() {
    var version = this.params_["VERSION"] || DEFAULT_WMS_VERSION;
    this.v13_ = compareVersions(version, "1.3") >= 0;
  };
  TileWMS2.prototype.tileUrlFunction = function(tileCoord, pixelRatio, projection) {
    var tileGrid = this.getTileGrid();
    if (!tileGrid) {
      tileGrid = this.getTileGridForProjection(projection);
    }
    if (tileGrid.getResolutions().length <= tileCoord[0]) {
      return void 0;
    }
    if (pixelRatio != 1 && (!this.hidpi_ || this.serverType_ === void 0)) {
      pixelRatio = 1;
    }
    var tileResolution = tileGrid.getResolution(tileCoord[0]);
    var tileExtent = tileGrid.getTileCoordExtent(tileCoord, this.tmpExtent_);
    var tileSize = toSize(tileGrid.getTileSize(tileCoord[0]), this.tmpSize);
    var gutter = this.gutter_;
    if (gutter !== 0) {
      tileSize = buffer2(tileSize, gutter, this.tmpSize);
      tileExtent = buffer(tileExtent, tileResolution * gutter, tileExtent);
    }
    if (pixelRatio != 1) {
      tileSize = scale2(tileSize, pixelRatio, this.tmpSize);
    }
    var baseParams = {
      "SERVICE": "WMS",
      "VERSION": DEFAULT_WMS_VERSION,
      "REQUEST": "GetMap",
      "FORMAT": "image/png",
      "TRANSPARENT": true
    };
    assign(baseParams, this.params_);
    return this.getRequestUrl_(tileCoord, tileSize, tileExtent, pixelRatio, projection, baseParams);
  };
  return TileWMS2;
}(TileImage_default);
var TileWMS_default = TileWMS;

// node_modules/ol/source/UTFGrid.js
var __extends21 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var CustomTile2 = function(_super) {
  __extends21(CustomTile3, _super);
  function CustomTile3(tileCoord, state, src, extent, preemptive, jsonp2) {
    var _this = _super.call(this, tileCoord, state) || this;
    _this.src_ = src;
    _this.extent_ = extent;
    _this.preemptive_ = preemptive;
    _this.grid_ = null;
    _this.keys_ = null;
    _this.data_ = null;
    _this.jsonp_ = jsonp2;
    return _this;
  }
  CustomTile3.prototype.getImage = function() {
    return null;
  };
  CustomTile3.prototype.getData = function(coordinate) {
    if (!this.grid_ || !this.keys_) {
      return null;
    }
    var xRelative = (coordinate[0] - this.extent_[0]) / (this.extent_[2] - this.extent_[0]);
    var yRelative = (coordinate[1] - this.extent_[1]) / (this.extent_[3] - this.extent_[1]);
    var row = this.grid_[Math.floor((1 - yRelative) * this.grid_.length)];
    if (typeof row !== "string") {
      return null;
    }
    var code = row.charCodeAt(Math.floor(xRelative * row.length));
    if (code >= 93) {
      code--;
    }
    if (code >= 35) {
      code--;
    }
    code -= 32;
    var data = null;
    if (code in this.keys_) {
      var id = this.keys_[code];
      if (this.data_ && id in this.data_) {
        data = this.data_[id];
      } else {
        data = id;
      }
    }
    return data;
  };
  CustomTile3.prototype.forDataAtCoordinate = function(coordinate, callback, opt_request) {
    if (this.state == TileState_default.EMPTY && opt_request === true) {
      this.state = TileState_default.IDLE;
      listenOnce(this, EventType_default.CHANGE, function(e) {
        callback(this.getData(coordinate));
      }, this);
      this.loadInternal_();
    } else {
      if (opt_request === true) {
        setTimeout(function() {
          callback(this.getData(coordinate));
        }.bind(this), 0);
      } else {
        callback(this.getData(coordinate));
      }
    }
  };
  CustomTile3.prototype.getKey = function() {
    return this.src_;
  };
  CustomTile3.prototype.handleError_ = function() {
    this.state = TileState_default.ERROR;
    this.changed();
  };
  CustomTile3.prototype.handleLoad_ = function(json) {
    this.grid_ = json["grid"];
    this.keys_ = json["keys"];
    this.data_ = json["data"];
    this.state = TileState_default.LOADED;
    this.changed();
  };
  CustomTile3.prototype.loadInternal_ = function() {
    if (this.state == TileState_default.IDLE) {
      this.state = TileState_default.LOADING;
      if (this.jsonp_) {
        jsonp(this.src_, this.handleLoad_.bind(this), this.handleError_.bind(this));
      } else {
        var client = new XMLHttpRequest();
        client.addEventListener("load", this.onXHRLoad_.bind(this));
        client.addEventListener("error", this.onXHRError_.bind(this));
        client.open("GET", this.src_);
        client.send();
      }
    }
  };
  CustomTile3.prototype.onXHRLoad_ = function(event) {
    var client = event.target;
    if (!client.status || client.status >= 200 && client.status < 300) {
      var response = void 0;
      try {
        response = JSON.parse(client.responseText);
      } catch (err) {
        this.handleError_();
        return;
      }
      this.handleLoad_(response);
    } else {
      this.handleError_();
    }
  };
  CustomTile3.prototype.onXHRError_ = function(event) {
    this.handleError_();
  };
  CustomTile3.prototype.load = function() {
    if (this.preemptive_) {
      this.loadInternal_();
    } else {
      this.setState(TileState_default.EMPTY);
    }
  };
  return CustomTile3;
}(Tile_default);
var UTFGrid = function(_super) {
  __extends21(UTFGrid2, _super);
  function UTFGrid2(options) {
    var _this = _super.call(this, {
      projection: get("EPSG:3857"),
      state: State_default.LOADING,
      zDirection: options.zDirection
    }) || this;
    _this.preemptive_ = options.preemptive !== void 0 ? options.preemptive : true;
    _this.tileUrlFunction_ = nullTileUrlFunction;
    _this.template_ = void 0;
    _this.jsonp_ = options.jsonp || false;
    if (options.url) {
      if (_this.jsonp_) {
        jsonp(options.url, _this.handleTileJSONResponse.bind(_this), _this.handleTileJSONError.bind(_this));
      } else {
        var client = new XMLHttpRequest();
        client.addEventListener("load", _this.onXHRLoad_.bind(_this));
        client.addEventListener("error", _this.onXHRError_.bind(_this));
        client.open("GET", options.url);
        client.send();
      }
    } else if (options.tileJSON) {
      _this.handleTileJSONResponse(options.tileJSON);
    } else {
      assert(false, 51);
    }
    return _this;
  }
  UTFGrid2.prototype.onXHRLoad_ = function(event) {
    var client = event.target;
    if (!client.status || client.status >= 200 && client.status < 300) {
      var response = void 0;
      try {
        response = JSON.parse(client.responseText);
      } catch (err) {
        this.handleTileJSONError();
        return;
      }
      this.handleTileJSONResponse(response);
    } else {
      this.handleTileJSONError();
    }
  };
  UTFGrid2.prototype.onXHRError_ = function(event) {
    this.handleTileJSONError();
  };
  UTFGrid2.prototype.getTemplate = function() {
    return this.template_;
  };
  UTFGrid2.prototype.forDataAtCoordinateAndResolution = function(coordinate, resolution, callback, opt_request) {
    if (this.tileGrid) {
      var z = this.tileGrid.getZForResolution(resolution, this.zDirection);
      var tileCoord = this.tileGrid.getTileCoordForCoordAndZ(coordinate, z);
      var tile = this.getTile(tileCoord[0], tileCoord[1], tileCoord[2], 1, this.getProjection());
      tile.forDataAtCoordinate(coordinate, callback, opt_request);
    } else {
      if (opt_request === true) {
        setTimeout(function() {
          callback(null);
        }, 0);
      } else {
        callback(null);
      }
    }
  };
  UTFGrid2.prototype.handleTileJSONError = function() {
    this.setState(State_default.ERROR);
  };
  UTFGrid2.prototype.handleTileJSONResponse = function(tileJSON) {
    var epsg4326Projection = get("EPSG:4326");
    var sourceProjection = this.getProjection();
    var extent;
    if (tileJSON["bounds"] !== void 0) {
      var transform2 = getTransformFromProjections(epsg4326Projection, sourceProjection);
      extent = applyTransform(tileJSON["bounds"], transform2);
    }
    var gridExtent = extentFromProjection(sourceProjection);
    var minZoom = tileJSON["minzoom"] || 0;
    var maxZoom = tileJSON["maxzoom"] || 22;
    var tileGrid = createXYZ({
      extent: gridExtent,
      maxZoom,
      minZoom
    });
    this.tileGrid = tileGrid;
    this.template_ = tileJSON["template"];
    var grids = tileJSON["grids"];
    if (!grids) {
      this.setState(State_default.ERROR);
      return;
    }
    this.tileUrlFunction_ = createFromTemplates(grids, tileGrid);
    if (tileJSON["attribution"] !== void 0) {
      var attributionExtent_1 = extent !== void 0 ? extent : gridExtent;
      this.setAttributions(function(frameState) {
        if (intersects(attributionExtent_1, frameState.extent)) {
          return [tileJSON["attribution"]];
        }
        return null;
      });
    }
    this.setState(State_default.READY);
  };
  UTFGrid2.prototype.getTile = function(z, x, y, pixelRatio, projection) {
    var tileCoordKey = getKeyZXY(z, x, y);
    if (this.tileCache.containsKey(tileCoordKey)) {
      return this.tileCache.get(tileCoordKey);
    } else {
      var tileCoord = [z, x, y];
      var urlTileCoord = this.getTileCoordForTileUrlFunction(tileCoord, projection);
      var tileUrl = this.tileUrlFunction_(urlTileCoord, pixelRatio, projection);
      var tile = new CustomTile2(tileCoord, tileUrl !== void 0 ? TileState_default.IDLE : TileState_default.EMPTY, tileUrl !== void 0 ? tileUrl : "", this.tileGrid.getTileCoordExtent(tileCoord), this.preemptive_, this.jsonp_);
      this.tileCache.set(tileCoordKey, tile);
      return tile;
    }
  };
  UTFGrid2.prototype.useTile = function(z, x, y) {
    var tileCoordKey = getKeyZXY(z, x, y);
    if (this.tileCache.containsKey(tileCoordKey)) {
      this.tileCache.get(tileCoordKey);
    }
  };
  return UTFGrid2;
}(Tile_default2);
var UTFGrid_default = UTFGrid;

// node_modules/ol/source/WMTSRequestEncoding.js
var WMTSRequestEncoding_default = {
  KVP: "KVP",
  REST: "REST"
};

// node_modules/ol/tilegrid/WMTS.js
var __extends22 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var WMTSTileGrid = function(_super) {
  __extends22(WMTSTileGrid2, _super);
  function WMTSTileGrid2(options) {
    var _this = _super.call(this, {
      extent: options.extent,
      origin: options.origin,
      origins: options.origins,
      resolutions: options.resolutions,
      tileSize: options.tileSize,
      tileSizes: options.tileSizes,
      sizes: options.sizes
    }) || this;
    _this.matrixIds_ = options.matrixIds;
    return _this;
  }
  WMTSTileGrid2.prototype.getMatrixId = function(z) {
    return this.matrixIds_[z];
  };
  WMTSTileGrid2.prototype.getMatrixIds = function() {
    return this.matrixIds_;
  };
  return WMTSTileGrid2;
}(TileGrid_default);

// node_modules/ol/source/WMTS.js
var __extends23 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var WMTS = function(_super) {
  __extends23(WMTS2, _super);
  function WMTS2(options) {
    var _this = this;
    var requestEncoding = options.requestEncoding !== void 0 ? options.requestEncoding : WMTSRequestEncoding_default.KVP;
    var tileGrid = options.tileGrid;
    var urls = options.urls;
    if (urls === void 0 && options.url !== void 0) {
      urls = expandUrl(options.url);
    }
    _this = _super.call(this, {
      attributions: options.attributions,
      attributionsCollapsible: options.attributionsCollapsible,
      cacheSize: options.cacheSize,
      crossOrigin: options.crossOrigin,
      imageSmoothing: options.imageSmoothing,
      projection: options.projection,
      reprojectionErrorThreshold: options.reprojectionErrorThreshold,
      tileClass: options.tileClass,
      tileGrid,
      tileLoadFunction: options.tileLoadFunction,
      tilePixelRatio: options.tilePixelRatio,
      urls,
      wrapX: options.wrapX !== void 0 ? options.wrapX : false,
      transition: options.transition,
      zDirection: options.zDirection
    }) || this;
    _this.version_ = options.version !== void 0 ? options.version : "1.0.0";
    _this.format_ = options.format !== void 0 ? options.format : "image/jpeg";
    _this.dimensions_ = options.dimensions !== void 0 ? options.dimensions : {};
    _this.layer_ = options.layer;
    _this.matrixSet_ = options.matrixSet;
    _this.style_ = options.style;
    _this.requestEncoding_ = requestEncoding;
    _this.setKey(_this.getKeyForDimensions_());
    if (urls && urls.length > 0) {
      _this.tileUrlFunction = createFromTileUrlFunctions(urls.map(_this.createFromWMTSTemplate.bind(_this)));
    }
    return _this;
  }
  WMTS2.prototype.setUrls = function(urls) {
    this.urls = urls;
    var key = urls.join("\n");
    this.setTileUrlFunction(createFromTileUrlFunctions(urls.map(this.createFromWMTSTemplate.bind(this))), key);
  };
  WMTS2.prototype.getDimensions = function() {
    return this.dimensions_;
  };
  WMTS2.prototype.getFormat = function() {
    return this.format_;
  };
  WMTS2.prototype.getLayer = function() {
    return this.layer_;
  };
  WMTS2.prototype.getMatrixSet = function() {
    return this.matrixSet_;
  };
  WMTS2.prototype.getRequestEncoding = function() {
    return this.requestEncoding_;
  };
  WMTS2.prototype.getStyle = function() {
    return this.style_;
  };
  WMTS2.prototype.getVersion = function() {
    return this.version_;
  };
  WMTS2.prototype.getKeyForDimensions_ = function() {
    var i = 0;
    var res = [];
    for (var key in this.dimensions_) {
      res[i++] = key + "-" + this.dimensions_[key];
    }
    return res.join("/");
  };
  WMTS2.prototype.updateDimensions = function(dimensions) {
    assign(this.dimensions_, dimensions);
    this.setKey(this.getKeyForDimensions_());
  };
  WMTS2.prototype.createFromWMTSTemplate = function(template) {
    var requestEncoding = this.requestEncoding_;
    var context2 = {
      "layer": this.layer_,
      "style": this.style_,
      "tilematrixset": this.matrixSet_
    };
    if (requestEncoding == WMTSRequestEncoding_default.KVP) {
      assign(context2, {
        "Service": "WMTS",
        "Request": "GetTile",
        "Version": this.version_,
        "Format": this.format_
      });
    }
    template = requestEncoding == WMTSRequestEncoding_default.KVP ? appendParams(template, context2) : template.replace(/\{(\w+?)\}/g, function(m, p) {
      return p.toLowerCase() in context2 ? context2[p.toLowerCase()] : m;
    });
    var tileGrid = this.tileGrid;
    var dimensions = this.dimensions_;
    return function(tileCoord, pixelRatio, projection) {
      if (!tileCoord) {
        return void 0;
      } else {
        var localContext_1 = {
          "TileMatrix": tileGrid.getMatrixId(tileCoord[0]),
          "TileCol": tileCoord[1],
          "TileRow": tileCoord[2]
        };
        assign(localContext_1, dimensions);
        var url2 = template;
        if (requestEncoding == WMTSRequestEncoding_default.KVP) {
          url2 = appendParams(url2, localContext_1);
        } else {
          url2 = url2.replace(/\{(\w+?)\}/g, function(m, p) {
            return localContext_1[p];
          });
        }
        return url2;
      }
    };
  };
  return WMTS2;
}(TileImage_default);
var WMTS_default = WMTS;
export {
  BingMaps_default as BingMaps,
  CartoDB_default as CartoDB,
  Cluster_default as Cluster,
  DataTile_default2 as DataTile,
  GeoTIFF_default as GeoTIFF,
  IIIF_default as IIIF,
  Image_default4 as Image,
  ImageArcGISRest_default as ImageArcGISRest,
  ImageCanvas_default2 as ImageCanvas,
  ImageMapGuide_default as ImageMapGuide,
  ImageStatic_default as ImageStatic,
  ImageWMS_default as ImageWMS,
  OSM_default as OSM,
  Raster_default as Raster,
  Source_default as Source,
  Stamen_default as Stamen,
  Tile_default2 as Tile,
  TileArcGISRest_default as TileArcGISRest,
  TileDebug_default as TileDebug,
  TileImage_default as TileImage,
  TileJSON_default as TileJSON,
  TileWMS_default as TileWMS,
  UTFGrid_default as UTFGrid,
  UrlTile_default as UrlTile,
  Vector_default as Vector,
  VectorTile_default as VectorTile,
  WMTS_default as WMTS,
  XYZ_default as XYZ,
  Zoomify_default as Zoomify
};
//# sourceMappingURL=ol_source.js.map
